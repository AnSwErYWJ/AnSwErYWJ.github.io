<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Git速查手册（第二版）]]></title>
      <url>http://answerywj.com/2019/02/12/my-git-help-v2/</url>
      <content type="html"><![CDATA[<p>本文是对之前<a href="http://answerywj.com/2016/08/28/Git%E9%80%9F%E6%9F%A5%E6%89%8B%E5%86%8C/">Git速查手册</a>的更新，增加了一些这段时间使用到的命令。</p>
<hr>
<a id="more"></a>
<h2 id="配置git"><a href="#配置git" class="headerlink" title="配置git"></a>配置git</h2><p>笔者使用的是v2.1.0，推荐大家使用v1.8以上的<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">版本</a>。 查看git版本：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="comment">--version</span></span><br></pre></td></tr></table></figure></p>
<p>配置命令<code>git config</code>分为三个级别：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--system : 系统级,位于 /etc/gitconfig .</span><br><span class="line">--global : 用户级,位于 ~/.gitconfig .</span><br><span class="line">--local : 仓库级,位于 repo/.git<span class="built_in">/config </span>,default并且优先级最高.</span><br></pre></td></tr></table></figure></p>
<p>首先需要删除global用户信息,防止不同git软件之间的冲突：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git<span class="built_in"> config </span>--global --unset user.name</span><br><span class="line">$ git<span class="built_in"> config </span>--global --unset user.email</span><br></pre></td></tr></table></figure></p>
<p>设置用户信息.若同时使用gitlab和github,推荐配置local用户信息：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git<span class="built_in"> config </span>--local user.name <span class="string">"username"</span></span><br><span class="line">$ git<span class="built_in"> config </span>--local user.email <span class="string">"email"</span></span><br></pre></td></tr></table></figure></p>
<p>git支持https和ssh等协议.https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，而ssh支持的原生git协议速度最快。<br>检查本机SSH公钥:<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">ls</span> ~<span class="string">/.ssh</span></span><br></pre></td></tr></table></figure></p>
<p>若存在,则将<code>id_rsa.pub</code>添加到github的SSH keys中。若不存在,则生成:<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>ssh-keygen -t rsa -C <span class="string">"your_email@youremail.com"</span></span><br></pre></td></tr></table></figure></p>
<p>当ssh配置完成后，再次检查ssh连接情况：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br><span class="line">Hi! You’ve successfully authenticated, <span class="keyword">but</span> GitHub <span class="keyword">does</span> <span class="keyword">not</span> provide shell access.</span><br></pre></td></tr></table></figure></p>
<p>若出现上述信息，则表示设置成功。<br>若使用https访问, 则进行如下配置,并且设置超时时间避免重复输入密码：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global http<span class="selector-class">.sslverify</span> false</span><br><span class="line">$ git config --global credential<span class="selector-class">.helper</span> <span class="string">'cache --timeout=3600'</span></span><br></pre></td></tr></table></figure></p>
<p>设置可视化diff和merge工具, linux系统上推荐使用meld或者diffuse：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git<span class="built_in"> config </span>--global diff.tool meld</span><br><span class="line">$ git<span class="built_in"> config </span>--global merge.tool meld</span><br></pre></td></tr></table></figure></p>
<p>保存用户名,密码, 避免每次<code>pull/push</code>操作都需要手动输入：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git<span class="built_in"> config </span>--global credential.helper store</span><br><span class="line"><span class="comment"># 执行上免的命令后, 下次操作输入的密码会被保存</span></span><br></pre></td></tr></table></figure></p>
<p>设置颜色,利于使用：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git<span class="built_in"> config </span>--global color.ui.<span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>设置别名：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git<span class="built_in"> config </span>--global alias checkout co</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>上面的命令将<code>checkout</code>设置为别名<code>co</code>。</p>
</blockquote>
<p>最后,查看一下所有的设置：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git<span class="built_in"> config </span>--local --list</span><br><span class="line">$ git<span class="built_in"> config </span>--global --list</span><br><span class="line">$ git<span class="built_in"> config </span>--system --list</span><br></pre></td></tr></table></figure></p>
<h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><p><img src="http://o9zpdspb3.bkt.clouddn.com/git%E5%B7%A5%E4%BD%9C%E6%B5%81.jpg" alt="工作流"></p>
<p>工作区就是你的本地仓库文件夹,不过其中的<code>.git</code>目录不属于工作区,而是版本库。里面存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。<br>现在来解释一下前面的添加和提交操作：  </p>
<ol>
<li><code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</li>
<li><code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。<br>因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。</li>
</ol>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>获取远程仓库：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">clone</span> <span class="title">git</span>@github.com:USERNAME/repo.git</span><br></pre></td></tr></table></figure></p>
<p>将本地的仓库添加到远程：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>cd repo</span><br><span class="line"><span class="variable">$ </span>git init</span><br><span class="line"><span class="variable">$ </span>git remote add origin git<span class="variable">@github</span>.<span class="symbol">com:</span>USERNAME/repo.git</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>origin</code>就是一个名字，是<code>git</code>为你默认创建的指向这个远程代码库的标签。</p>
</blockquote>
<p>添加修改:<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">add</span><span class="bash"> &lt;filename&gt; </span></span><br><span class="line">$ git <span class="keyword">add</span><span class="bash"> .  <span class="comment"># 添加当前目录所有修改过的文件  </span></span></span><br><span class="line">$ git <span class="keyword">add</span><span class="bash"> *  <span class="comment"># 递归地添加执行命令时所在的目录中的所有文件</span></span></span><br></pre></td></tr></table></figure></p>
<p>提交修改:<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git commit -m <span class="string">"commit message"</span></span><br><span class="line"><span class="variable">$ </span>git commit -am <span class="string">"commit message"</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>commit message</code>的填写可以参考<a href="http://blog.jobbole.com/92713/" target="_blank" rel="noopener">写好 Git Commit 信息的 7 个建议</a>。<br><code>am</code>将添加和提交合并为一步,但只对本来就存在的文件有效。</p>
</blockquote>
<p>推送修改：<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">push</span> -u <span class="built_in">origin</span> &lt;<span class="built_in">feature</span>-branch-name&gt;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>-u</code>选项可以将本地分支与远程分支关联,下次<code>git pull</code>操作时可以不带参数.具体参见<a href="http://stackoverflow.com/questions/5697750/what-exactly-does-the-u-do-git-push-u-origin-master-vs-git-push-origin-ma" target="_blank" rel="noopener">这里</a>。</p>
</blockquote>
<p>查看远程仓库：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin git@github<span class="selector-class">.com</span>:USERNAME/repo<span class="selector-class">.git</span> (push)</span><br><span class="line">origin git@github<span class="selector-class">.com</span>:USERNAME/repo<span class="selector-class">.git</span> (fetch)</span><br></pre></td></tr></table></figure></p>
<p>fork后同步上游仓库的更新：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一次需要添加上游仓库</span></span><br><span class="line"><span class="variable">$ </span>git remote add upstream git<span class="variable">@github</span>.<span class="symbol">com:</span>USERNAME/repo.git</span><br><span class="line"> </span><br><span class="line"><span class="variable">$ </span>git remote -v</span><br><span class="line">origin  git<span class="variable">@github</span>.<span class="symbol">com:</span>USERNAME/repo.git (push)</span><br><span class="line">origin  git<span class="variable">@github</span>.<span class="symbol">com:</span>USERNAME/repo.git (fetch)</span><br><span class="line">upstream  git<span class="variable">@github</span>.<span class="symbol">com:</span>USERNAME/repo.git  (push)</span><br><span class="line">upstream  git<span class="variable">@github</span>.<span class="symbol">com:</span>USERNAME/repo.git (fetch)</span><br><span class="line"></span><br><span class="line"><span class="variable">$ </span>git fetch upstream </span><br><span class="line"><span class="variable">$ </span>git difftool &lt;branch-name&gt; upstream/master</span><br><span class="line"><span class="variable">$ </span>git merge upstream/master</span><br><span class="line"><span class="variable">$ </span>git mergetool</span><br></pre></td></tr></table></figure></p>
<p>引用公共代码：<br>代码引用在git上有两种方式：<code>submodule</code>和<code>subtree</code>，推荐使用<a href="http://aoxuis.me/post/2013-08-06-git-subtree" target="_blank" rel="noopener">subtree</a>方式。<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 第一次初始化</span><br><span class="line">$ git remote <span class="keyword">add </span>-f &lt;remote-<span class="keyword">subtree-repository-name&gt; </span>&lt;remote-<span class="keyword">subtree-repository-url&gt;</span></span><br><span class="line"><span class="keyword">$ </span>git <span class="keyword">subtree </span><span class="keyword">add </span>--prefix=&lt;local-<span class="keyword">subtree-directory&gt; </span>&lt;remote-<span class="keyword">subtree-repository&gt; </span>&lt;remote-<span class="keyword">subtree-branch-name&gt; </span>--squash</span><br><span class="line"></span><br><span class="line"># 同步<span class="keyword">subtree的更新</span></span><br><span class="line"><span class="keyword">$ </span>git <span class="keyword">subtree </span>pull --prefix=&lt;local-<span class="keyword">subtree-directory&gt; </span>&lt;remote-<span class="keyword">subtree-repository&gt; </span>&lt;remote-<span class="keyword">subtree-branch-name&gt; </span>--squash</span><br><span class="line"></span><br><span class="line"># 推送到远程<span class="keyword">subtree库</span></span><br><span class="line"><span class="keyword">$ </span>git <span class="keyword">subtree </span><span class="keyword">push </span>--prefix=&lt;local-<span class="keyword">subtree-directory&gt; </span>&lt;remote-<span class="keyword">subtree-repository&gt; </span>&lt;remote-<span class="keyword">subtree-branch-name&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="使用标签"><a href="#使用标签" class="headerlink" title="使用标签"></a>使用标签</h2><p>查看标签 ：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span></span><br></pre></td></tr></table></figure></p>
<p>创建标签 ：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span> <span class="title">-a</span> <span class="tag">&lt;tagname&gt;</span> -m <span class="string">"tag message"</span> <span class="comment"># 创建标签在当前最新提交的commit上</span></span><br><span class="line">$ git <span class="keyword">tag</span> <span class="title">-a</span> <span class="tag">&lt;tagname&gt;</span> -m <span class="string">"tag message"</span> <span class="tag">&lt;commit id&gt;</span> <span class="comment"># 创建标签在指定的commit上</span></span><br></pre></td></tr></table></figure></p>
<p>推送标签到远程：<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">push</span> origin &lt;tagname&gt; <span class="meta"># 推送一个本地标签</span></span><br><span class="line">$ git <span class="keyword">push</span> origin --tags <span class="meta"># 推送全部未推送过的本地标签</span></span><br></pre></td></tr></table></figure></p>
<p>删除标签：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git tag -d &lt;tagname&gt; <span class="comment"># 删除一个本地标签；</span></span><br><span class="line"><span class="variable">$ </span>git push origin <span class="symbol">:refs/tags/&lt;tagname&gt;</span> <span class="comment"># 删除一个远程标签。</span></span><br></pre></td></tr></table></figure></p>
<h2 id="撤销与回退"><a href="#撤销与回退" class="headerlink" title="撤销与回退"></a>撤销与回退</h2><p>查看当前仓库状态:<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git status</span><br></pre></td></tr></table></figure></p>
<p>查看文件更改：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git difftool <span class="tag">&lt;<span class="name">filename</span>&gt;</span></span><br><span class="line">$ git mergetool <span class="tag">&lt;<span class="name">filename</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>查看提交历史:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --pretty=oneline <span class="comment">#只保留commit id 和 commit message</span></span></span><br></pre></td></tr></table></figure></p>
<p>撤销工作区<code>Tracked files</code>的修改：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout <span class="comment">-- &lt;filename&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>撤销工作区<code>Untracked files</code>的修改：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#####</span><br><span class="line"># n:查看将会删除的文件，防止误删</span><br><span class="line"># f:Untracked的文件</span><br><span class="line"># d:Untracked的目录</span><br><span class="line"># x:包含gitignore的Untracked文件和目录一并删掉，慎用！</span><br><span class="line">#####</span><br><span class="line"></span><br><span class="line">git clean -nfd</span><br><span class="line">git clean -fd</span><br></pre></td></tr></table></figure></p>
<p>撤销所有已经提交到暂存区的修改：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">reset</span> <span class="keyword">HEAD</span> .</span><br></pre></td></tr></table></figure></p>
<p>撤销提交到暂存区的某个文件或文件夹：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">reset</span> <span class="keyword">HEAD</span> -filename</span><br></pre></td></tr></table></figure></p>
<p>回退版本，即回退暂存区的修改：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">reset</span> <span class="comment">--hard &lt;commit-id&gt;</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>上一个版本的<code>commit-id</code>可以用<code>HEAD^</code>表示，上上个版本为<code>HEAD^^</code>，上100个版本可以表示为<code>HEAD~100</code>以此类推。</p>
</blockquote>
<p>回退版本后，若需要返回原来的版本，会发现找不到未来的<code>commit id</code>，则需要查看操作命令历史进行查找：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git reflog</span><br></pre></td></tr></table></figure></p>
<p>从版本库删除文件：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm <span class="tag">&lt;<span class="name">filename</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>若你的代码已经<code>push</code>到线上，则推荐使用下面这个命令回滚：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git revert &lt;commit-<span class="built_in">id</span>&gt;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>revert</code>是用一次新的<code>commit</code>来回滚之前的<code>commit</code>，更安全;<code>reset</code>则是直接删除指定的<code>commit</code>，若直接<code>push</code>会导致冲突。</p>
</blockquote>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>查看所有分支，有<code>*</code>标记的是当前分支：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">branch </span>-a</span><br></pre></td></tr></table></figure></p>
<p>创建本地分支：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout &lt;<span class="keyword">new</span><span class="type">branch</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>创建并切换本地分支：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b &lt;<span class="keyword">new</span><span class="type">branch</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>从标签创建分支：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch <span class="params">&lt;branch&gt;</span> <span class="params">&lt;tagname&gt;</span></span><br><span class="line">$ git checkout <span class="params">&lt;branch&gt;</span> <span class="meta"># 切换到新建分支</span></span><br></pre></td></tr></table></figure></p>
<p>推送新建本地分支到远程：<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> git push -u origin &lt;remote-branch-name&gt;</span><br><span class="line">  <span class="keyword">or</span></span><br><span class="line"><span class="symbol">$</span> git push --<span class="keyword">set</span>-upstream <span class="comment">origin &lt;remote-branch-name&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>删除本地分支：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">branch </span>-d &lt;<span class="keyword">branch&gt;</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>若当前分支因为有修改未提交或其它情况不能删除，请使用<code>-D</code>选项强制删除。</p>
</blockquote>
<p>删除远程分支(三种方法)：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git push origin --delete &lt;remote-branch-name&gt;</span><br><span class="line"><span class="variable">$ </span>git push origin -d &lt;remote-branch-name&gt;</span><br><span class="line"><span class="variable">$ </span>git push origin <span class="symbol">:&lt;remote-branch-name&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>清除无用的分支：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git remote prune origin</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>说明：remote上的一个分支被其他人删除后，需要更新本地的分支列表。</p>
</blockquote>
<p>获取远程分支到本地已有分支：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch --<span class="built_in">set</span>-upstream &lt;<span class="built_in">local</span>-branch&gt; origin/branch</span></span><br></pre></td></tr></table></figure></p>
<p>获取远程分支到本地并新建本地分支：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -<span class="keyword">b </span>&lt;local-<span class="keyword">branch&gt; </span>&lt;remote-<span class="keyword">branch&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>同步当前分支的更新，使用<code>git pull</code>并不保险：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载最新的代码到远程跟踪分支, 即origin/&lt;branch-name&gt;</span></span><br><span class="line">$ git fetch <span class="keyword">origin </span>&lt;<span class="keyword">branch-name&gt; </span></span><br><span class="line"><span class="comment"># 查看更新内容</span></span><br><span class="line">$ git <span class="keyword">difftool </span>&lt;<span class="keyword">branch-name&gt; </span><span class="keyword">origin/&lt;branch-name&gt;</span></span><br><span class="line"><span class="keyword"># </span>尝试合并远程跟踪分支的代码到本地分支 </span><br><span class="line">$ git merge <span class="keyword">origin/&lt;branch-name&gt;</span></span><br><span class="line"><span class="keyword"># </span>借助mergetool解决冲突              </span><br><span class="line">$ git mergetool</span><br></pre></td></tr></table></figure></p>
<p>同步其它分支的更新，本例拉取<code>master</code>分支更新：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin <span class="literal">master</span></span><br><span class="line">$ git difftool <span class="tag">&lt;branch-name&gt;</span> origin/<span class="literal">master</span></span><br><span class="line">$ git merge origin/<span class="literal">master</span></span><br><span class="line">$ git mergetool</span><br></pre></td></tr></table></figure></p>
<h2 id="暂存"><a href="#暂存" class="headerlink" title="暂存"></a>暂存</h2><p>当你需要切换分支时,若当前工作区还有些修改没有完成,又不适合提交的,操作切换分支是会提示出错的.这时就需要将这些修改暂存起来:<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git stash save <span class="string">"message"</span></span><br></pre></td></tr></table></figure></p>
<p>查看:<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash <span class="built_in">list</span></span><br></pre></td></tr></table></figure></p>
<p>恢复:<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git stash <span class="keyword">pop</span> [--<span class="keyword">index</span>] [stash@&#123;num&#125;]　</span><br><span class="line">  <span class="keyword">or</span></span><br><span class="line">$ git stash apply [--<span class="keyword">index</span>] [stash@&#123;num&#125;]　<span class="comment"># 不删除已恢复的进度.</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>--index</code>表示不仅恢复工作区,还会恢复暂存区;<code>num</code>是你要恢复的操作的序列号,默认恢复最新进度.</p>
</blockquote>
<p>删除进度:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash <span class="keyword">drop</span> [stash@&#123;<span class="keyword">num</span>&#125;] <span class="comment"># 删除指定进度</span></span><br><span class="line">$ git stash <span class="keyword">clear</span> <span class="comment"># 删除所有</span></span><br></pre></td></tr></table></figure></p>
<h2 id="清理本地仓库"><a href="#清理本地仓库" class="headerlink" title="清理本地仓库"></a>清理本地仓库</h2><ul>
<li><p>检查是否有无用的大文件。</p>
</li>
<li><p>清理无用的分支和标签：</p>
  <figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d <span class="tag">&lt;branch-name&gt;</span></span><br><span class="line">$ git <span class="keyword">tag</span> <span class="title">-d</span> <span class="tag">&lt;tag-name&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>清理<code>.git</code>目录，一般本地仓库过大都是由于存在过多的<code>loose object</code>:</p>
  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git gc <span class="attribute">--prune</span>=now</span><br></pre></td></tr></table></figure>
<blockquote>
<p>tips: 在执行<code>push</code>操作时，<code>git</code>会自动执行一次<code>gc</code>操作，不过只有<code>loose object</code>达到一定数量后才会真正调用，建议手动执行。</p>
</blockquote>
</li>
</ul>
<h2 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h2><p>当你的仓库中有一些文件，类似密码或者数据库文件不需要提交但又必须放在仓库目录下，每次<code>git status</code>都会提示<code>Untracked</code>，看着让人很不爽，提供两种方法解决这个问题</p>
<h3 id="本地"><a href="#本地" class="headerlink" title="本地"></a>本地</h3><p>在代码仓库目录创建一个<code>.gitignore</code>文件，编写规则如下：<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tmp/  <span class="comment"># 忽略tmp文件夹下所有内容</span></span><br><span class="line">*<span class="string">.ini</span> <span class="comment"># 忽略所有ini文件</span></span><br><span class="line">!data/ <span class="comment">#忽略除了data文件夹的所有内容</span></span><br></pre></td></tr></table></figure></p>
<h3 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h3><p>在用户目录创建一个<code>.gitignore_global</code>文件，编写规则同<code>.gitignore</code>，并修改<code>~/.gitconfig</code><br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[core]</span></span><br><span class="line">	excludesfile = ~/.gitignore_global</span><br></pre></td></tr></table></figure></p>
<p>如果添加的忽略对象已经<code>Tracked</code>，纳入了版本管理中，则需要在代码仓库中先把本地缓存删除,改变成<code>Untracked</code>状态<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm -r <span class="comment">--cached .</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><a href="https://github.com/github/gitignore" target="_blank" rel="noopener"><code>.gitignore</code>模版</a></p>
</blockquote>
<h2 id="处理大型二进制文件"><a href="#处理大型二进制文件" class="headerlink" title="处理大型二进制文件"></a>处理大型二进制文件</h2><p>由于git在存储二进制文件时效率不高,所以需要借助<a href="http://www.oschina.net/news/71365/git-annex-lfs-bigfiles-fat-media-bigstore-sym" target="_blank" rel="noopener">第三方组件</a>。</p>
<h2 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h2><p>查看帮助：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git --<span class="built_in">help</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰老师的git教程</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">常用Git命令清单</a></li>
<li><a href="https://git-scm.com/book/en/v2" target="_blank" rel="noopener">Git-Book</a></li>
<li><a href="https://git-scm.com/docs" target="_blank" rel="noopener">Git-Reference</a></li>
<li><a href="https://segmentfault.com/a/1190000002783245" target="_blank" rel="noopener">Git push与pull的默认行为</a></li>
<li><a href="http://www.tuicool.com/articles/rUBNBvI" target="_blank" rel="noopener">git stash 详解</a></li>
</ol>
<h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p>
<ul>
<li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li>
<li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li>
<li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li>
<li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li>
<li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li>
</ul>
<p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>
]]></content>
      
        <categories>
            
            <category> Git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Daily Record]]></title>
      <url>http://answerywj.com/2018/10/16/daily-record/</url>
      <content type="html"><![CDATA[<p>本文主要整理日常遇到的问题</p>
<hr>
<a id="more"></a>
<h2 id="2018-03-27"><a href="#2018-03-27" class="headerlink" title="2018.03.27"></a>2018.03.27</h2><ol>
<li>结构体初始化后需要进行清空<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_send_mqtt_handshake_opts</span> <span class="title">opts</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;opts, <span class="number">0</span>, <span class="keyword">sizeof</span>(opts));</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="2018-03-28"><a href="#2018-03-28" class="headerlink" title="2018.03.28"></a>2018.03.28</h2><ol>
<li>宏定义与函数名冲突，若宏定义在函数名的声明或定义之前，则会进行字符串替换，导致编译会报错</li>
<li>MQTT QOS 学习<figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">qos 0</span>: 最多分发一次，消息可能送达一次也可能根本没送达，取决于底层的网络能力，接收者不会响应，发送者不会重发</span><br><span class="line"></span><br><span class="line"><span class="attribute">qos 1</span>: 至少分发一次，服务质量确保消息至少送达一次，需要PUBACK报文确认</span><br><span class="line"></span><br><span class="line"><span class="attribute">qos 2</span>: 仅分发一次，最高等级的服务质量，消息丢失和重复都是不可接受的</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="2018-05-29"><a href="#2018-05-29" class="headerlink" title="2018.05.29"></a>2018.05.29</h2><ol>
<li>布尔值变量的命名尽量使用如下规则：<code>is_xxx</code></li>
<li><code>lua</code>字符串拼接操作：若存在大量的字符串拼接操作，如循环等，不要使用<code>..</code>，因为每次都会申请临时内存，新建一个新的字符串，会导致内存来不及回收，可以使用<code>table.insert + table.contact</code></li>
<li><code>sscanf</code>可以进行字符串分割和字符串数字转数字等，很强大！！！</li>
</ol>
<h2 id="2018-07-19"><a href="#2018-07-19" class="headerlink" title="2018.07.19"></a>2018.07.19</h2><ol>
<li>两个库有相同的符号，同时链接的话，运行时可能串库调用</li>
</ol>
<h2 id="2018-08-17"><a href="#2018-08-17" class="headerlink" title="2018.08.17"></a>2018.08.17</h2><ol>
<li>越界访问内存导致<code>free</code>失败的原因</li>
</ol>
<p><code>molloc</code>一块内存，在<code>free</code>的时候只需要传递指针首地址操作系统(或者说C语言)就可以对内存进行释放，那么它是怎么知道应该释放多大的内存呢?<br>其实C语言是维护了一个数据结构类似如下的结构，这个结构中主要有两个数据：一个是当前内存块的大小，另外一个是指向下一个空闲内存块：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="class"><span class="keyword">struct</span> <span class="title">Header</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> <span class="title">header</span> *<span class="title">ptr</span>;</span> /*<span class="keyword">next</span> block <span class="keyword">if</span> on free list*<span class="regexp">/</span></span><br><span class="line"><span class="regexp">        unsigned size; /</span>*size <span class="keyword">of</span> this block*<span class="regexp">/</span></span><br><span class="line"><span class="regexp">    &#125; header;</span></span><br></pre></td></tr></table></figure></p>
<p>其实我们在<code>molloc(10)</code>一块内存的时候，真正申请的不止是<code>10</code>个字节大小的内存，而是要加上一个<code>struct Header</code>结构体的大小，<code>molloc</code>返回给我们的内存想当于是p+sizeof(Header)的指针，而在free的时候，则C语言只需要将<code>p-sizeof(Header)</code>就能找到<code>header</code>结构，从而知道内存块大小。</p>
<h2 id="2018-10-16"><a href="#2018-10-16" class="headerlink" title="2018.10.16"></a>2018.10.16</h2><ol>
<li>使用<code>valgrind</code>对可执行程序做内存检查，发现会存在<code>still reachable</code>的问题，可排除编码的问题。<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valgrind <span class="attribute">--tool</span>=memcheck <span class="attribute">--leak-check</span>=<span class="literal">yes</span> <span class="attribute">--show-reachable</span>=<span class="literal">yes</span> <span class="attribute">--track-origins</span>=<span class="literal">yes</span> a.out</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>查阅资料发现，许多<code>C++</code>库都实现了自己的内存分配管理器，在内存释放时不是将其直接还给系统，而是留在内存池中供下次使用，这导致程序退出时会被检测到<code>still reachable</code>。将使用<code>C++</code>库的地方去除再次验证，无该错误。<br>参考：<a href="https://stackoverflow.com/questions/30376601/valgrind-memory-still-reachable-with-trivial-program-using-iostream" target="_blank" rel="noopener">https://stackoverflow.com/questions/30376601/valgrind-memory-still-reachable-with-trivial-program-using-iostream</a></p>
<h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p>
<ul>
<li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li>
<li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li>
<li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li>
<li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li>
<li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li>
</ul>
<p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>
]]></content>
      
        <categories>
            
            <category> Working </category>
            
        </categories>
        
        
        <tags>
            
            <tag> record </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C代码覆盖率测试工具Gcov]]></title>
      <url>http://answerywj.com/2018/09/25/coverage-of-c/</url>
      <content type="html"><![CDATA[<p>代码覆盖率测试反映了测试的广度与深度，量化了测试和开发质量，是十分有必要的，业界目前有针对各种语言的覆盖率测试工具，本文主要介绍<code>C/C++</code>相关的覆盖率测试工具<code>Gcov</code><br><a id="more"></a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>Gcov</code>是一个测试覆盖程序，是集成在<code>GCC</code>中的，随<code>GCC</code>一起发布</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="基本块BB"><a href="#基本块BB" class="headerlink" title="基本块BB"></a>基本块BB</h4><p>基本块指一段程序的第一条语句被执行过一次后，这段程序中的每一跳语句都需要执行一次，称为基本块，因此基本块中的所有语句的执行次数是相同的，一般由多个顺序执行语句后边跟一个跳转语句组成</p>
<h4 id="跳转ARC"><a href="#跳转ARC" class="headerlink" title="跳转ARC"></a>跳转ARC</h4><p>从一个<code>BB</code>到另外一个<code>BB</code>的跳转叫做一个<code>ARC</code>,要想知道程序中的每个语句和分支的执行次数，就必须知道每个<code>BB</code>和<code>ARC</code>的执行次数</p>
<h4 id="程序流图"><a href="#程序流图" class="headerlink" title="程序流图"></a>程序流图</h4><p>如果把<code>BB</code>作为一个节点，这样一个函数中的所有<code>BB</code>就构成了一个有向图，要想知道程序中的每个语句和分支的执行次数，就必须知道每个<code>BB</code>和<code>ARC</code>的执行次数，根据图论可以知道有向图中<code>BB</code>的入度和出度是相同的，所以只要知道了部分的<code>BB</code>或者<code>ARC</code>大小，就可以推断所有的大小，这里选择由<code>ARC</code>的执行次数来推断<code>BB</code>的执行次数，所以对部分<code>ARC</code>插桩，只要满足可以统计出来所有的<code>BB</code>和<code>ARC</code>的执行次数即可</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>测试程序首先进行编译预处理，生成汇编文件，并完成插桩，插桩的过程中会向源文件的末尾插入一个静态数组，数组的大小就是这个源文件中桩点的个数，数组的值就是桩点的执行次数，每个桩点插入3~4条汇编语句，直接插入生成的<code>*.s</code>文件中，最后汇编文件经过汇编生成目标文件，在程序运行过程中桩点负责收集程序的执行信息</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>测试代码如下：<br><code>say.c</code>:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">say</span><span class="params">(<span class="keyword">char</span> *what)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"------ %s\n"</span>, what);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>main.c</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">say</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">1</span>]) &#123;</span><br><span class="line">        say(<span class="string">"hello"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        say(<span class="string">"bye"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>添加<code>-fprofile-arcs -ftest-coverage -fPIC</code>编译参数编译程序，生成可执行程序和<code>*.gcno</code>文件，里面记录了行信息和程序流图信息：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -fprofile-arcs -ftest-coverage -fPIC -O0 say<span class="selector-class">.c</span> main.c</span><br><span class="line"></span><br><span class="line">$ ls</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-class">.out</span>  main<span class="selector-class">.c</span>  main<span class="selector-class">.gcno</span>  say<span class="selector-class">.c</span>  say.gcno</span><br></pre></td></tr></table></figure></p>
<h3 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h3><p>运行可执行文件，生成<code>*.gcda</code>在默认生成在相应<code>*.o</code>文件目录，里面记录了<code>*.c</code>文件中程序的执行情况，包括跳变次数等:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./<span class="selector-tag">a</span>.out</span><br><span class="line">------ bye</span><br><span class="line"></span><br><span class="line">$ ls</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-class">.out</span>  main<span class="selector-class">.c</span>  main<span class="selector-class">.gcda</span>  main<span class="selector-class">.gcno</span>  say<span class="selector-class">.c</span>  say<span class="selector-class">.gcda</span>  say.gcno</span><br></pre></td></tr></table></figure></p>
<p>可以通过设置环境变量<code>GCOV_PREFIX=/xxx/xxx</code>和<code>GCOV_PREFIX_STRIP=x</code>来改变路径，其中<code>GCOV_PREFIX_STRIP</code>表示去掉源代码路径中的前几级，默认为<code>0</code>，比如源代码路径为<code>/a/b/c/d.c</code>，<code>GCOV_PREFIX_STRIP=2</code>，则实际使用的路径是<code>c/d.c</code>，如果<code>GCOV_PREFIX=/e/f</code>，则<code>.gcda</code>实际存放的路径是<code>/e/f/c/d.gcda</code></p>
<h3 id="报告生成"><a href="#报告生成" class="headerlink" title="报告生成"></a>报告生成</h3><p>针对某一个文件的执行情况，可以通过如下命令生成报告，并创建<code>*.gcov</code>文件：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gcov -<span class="selector-tag">a</span> main.c</span><br><span class="line">File <span class="string">'main.c'</span></span><br><span class="line">Lines executed:<span class="number">80.00%</span> of <span class="number">5</span></span><br><span class="line">Creating <span class="string">'main.c.gcov'</span></span><br></pre></td></tr></table></figure></p>
<p>常用选项，更多可参考<a href="https://gcc.gnu.org/onlinedocs/gcc/Invoking-Gcov.html#Invoking-Gcov" target="_blank" rel="noopener">Invoking gcov</a>：<br><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-b：分支覆盖</span></span><br><span class="line"><span class="deletion">-a：所有基本块覆盖</span></span><br><span class="line"><span class="deletion">-f：函数覆盖</span></span><br></pre></td></tr></table></figure></p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>在编译时不要加优化选项，否则代码会发生变化，无法准确定位</li>
<li>代码中复杂的宏，比如宏展开后是循环或者其他控制结构，可以用内联函数来代替，因为<code>gcov</code>只统计宏调用出现的那一行</li>
<li>代码每一行最好只有一条语句</li>
<li><code>*.gcno</code>与<code>*.gcda</code>需要匹配，两个文件是有时间戳来记录是不是匹配的</li>
<li>若是编译动态库，需要在链接时<code>-lgcov</code></li>
</ol>
<h3 id="图形化展示"><a href="#图形化展示" class="headerlink" title="图形化展示"></a>图形化展示</h3><p><code>gcov</code>生成的报告分散在各个源码文件所对应的<code>*.gcov</code>文件中，难以汇总分析，并且可视化效果较差，所以需要转化成可视图形化报告，有<code>lcov</code>或<code>gcovr</code>两个工具可以完成，两者功能基本相同，本文主要介绍<code>gcovr</code>，是一个用<code>Python</code>编写的开源软件，大小只有几十KB，安装参见<a href="https://gcovr.com/installation.html" target="_blank" rel="noopener">官网</a></p>
<h4 id="列表形式"><a href="#列表形式" class="headerlink" title="列表形式"></a>列表形式</h4><ol>
<li>代码覆盖率<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ gcovr -r .</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line"><span class="code">                           GCC Code Coverage Report</span></span><br><span class="line">Directory: .</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">File                                       Lines    Exec  Cover   Missing</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">main.c                                         5       4    80%   15</span><br><span class="line">say.c                                          3       3   100%   </span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">TOTAL                                          8       7    87%</span><br><span class="line">------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>报告展示程序运行后覆盖了<code>80%</code>的代码</p>
<ol start="2">
<li>分支覆盖率<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ gcovr -b -r .</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line"><span class="code">                           GCC Code Coverage Report</span></span><br><span class="line">Directory: .</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">File                                    Branches   Taken  Cover   Missing</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">main.c                                         2       1    50%   14</span><br><span class="line">say.c                                          0       0    --%   </span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">TOTAL                                          2       1    50%</span><br><span class="line">------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>报告展示了在<code>main.c</code>中有一个分支没有执行到</p>
<h4 id="XML文件形式"><a href="#XML文件形式" class="headerlink" title="XML文件形式"></a>XML文件形式</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">$ gcovr --xml-pretty -r .</span><br><span class="line"><span class="meta">&lt;?xml version="1.0" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE coverage</span></span><br><span class="line"><span class="meta">  SYSTEM 'http://cobertura.sourceforge.net/xml/coverage-04.dtd'&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">coverage</span> <span class="attr">branch-rate</span>=<span class="string">"0.5"</span> <span class="attr">branches-covered</span>=<span class="string">"1"</span> <span class="attr">branches-valid</span>=<span class="string">"2"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">complexity</span>=<span class="string">"0.0"</span> <span class="attr">line-rate</span>=<span class="string">"0.875"</span> <span class="attr">lines-covered</span>=<span class="string">"7"</span> <span class="attr">lines-valid</span>=<span class="string">"8"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">timestamp</span>=<span class="string">"1537930892"</span> <span class="attr">version</span>=<span class="string">"gcovr 3.4"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">sources</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span>&gt;</span>.<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">sources</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">packages</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">package</span> <span class="attr">branch-rate</span>=<span class="string">"0.5"</span> <span class="attr">complexity</span>=<span class="string">"0.0"</span> <span class="attr">line-rate</span>=<span class="string">"0.875"</span> <span class="attr">name</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">classes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">branch-rate</span>=<span class="string">"0.5"</span> <span class="attr">complexity</span>=<span class="string">"0.0"</span> <span class="attr">filename</span>=<span class="string">"main.c"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">line-rate</span>=<span class="string">"0.8"</span> <span class="attr">name</span>=<span class="string">"main_c"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">methods</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">lines</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">line</span> <span class="attr">branch</span>=<span class="string">"false"</span> <span class="attr">hits</span>=<span class="string">"1"</span> <span class="attr">number</span>=<span class="string">"12"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">line</span> <span class="attr">branch</span>=<span class="string">"true"</span> <span class="attr">condition-coverage</span>=<span class="string">"50% (1/2)"</span> <span class="attr">hits</span>=<span class="string">"1"</span> <span class="attr">number</span>=<span class="string">"14"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">conditions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">condition</span> <span class="attr">coverage</span>=<span class="string">"50%"</span> <span class="attr">number</span>=<span class="string">"0"</span> <span class="attr">type</span>=<span class="string">"jump"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">conditions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">line</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">line</span> <span class="attr">branch</span>=<span class="string">"false"</span> <span class="attr">hits</span>=<span class="string">"0"</span> <span class="attr">number</span>=<span class="string">"15"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">line</span> <span class="attr">branch</span>=<span class="string">"false"</span> <span class="attr">hits</span>=<span class="string">"1"</span> <span class="attr">number</span>=<span class="string">"17"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">line</span> <span class="attr">branch</span>=<span class="string">"false"</span> <span class="attr">hits</span>=<span class="string">"1"</span> <span class="attr">number</span>=<span class="string">"19"</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">lines</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">branch-rate</span>=<span class="string">"0.0"</span> <span class="attr">complexity</span>=<span class="string">"0.0"</span> <span class="attr">filename</span>=<span class="string">"say.c"</span> <span class="attr">line-rate</span>=<span class="string">"1.0"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">name</span>=<span class="string">"say_c"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">methods</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">lines</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">line</span> <span class="attr">branch</span>=<span class="string">"false"</span> <span class="attr">hits</span>=<span class="string">"1"</span> <span class="attr">number</span>=<span class="string">"10"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">line</span> <span class="attr">branch</span>=<span class="string">"false"</span> <span class="attr">hits</span>=<span class="string">"1"</span> <span class="attr">number</span>=<span class="string">"11"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">line</span> <span class="attr">branch</span>=<span class="string">"false"</span> <span class="attr">hits</span>=<span class="string">"1"</span> <span class="attr">number</span>=<span class="string">"12"</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">lines</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">classes</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">packages</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">coverage</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="HTML文件形式"><a href="#HTML文件形式" class="headerlink" title="HTML文件形式"></a>HTML文件形式</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcovr -r . --<span class="selector-tag">html</span> -o xxx.html</span><br><span class="line">$ ls</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-class">.out</span>  main<span class="selector-class">.c</span>  main<span class="selector-class">.gcda</span>  main<span class="selector-class">.gcno</span>  say<span class="selector-class">.c</span>  say<span class="selector-class">.gcda</span>  say<span class="selector-class">.gcno</span>  xxx.html</span><br></pre></td></tr></table></figure>
<p>可以发现添加<code>--html</code>参数后，可以生成<code>html</code>文件，用浏览器打开，如下图：<br><img src="http://o9zpdspb3.bkt.clouddn.com/gcovr_xxx.png" alt="gcovr_xxx.png"></p>
<p>还可以添加<code>--html-details</code>选项，为每个代码文件单独生成<code>html</code><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcovr -r . --<span class="selector-tag">html</span> --html-<span class="selector-tag">details</span> -o xxx.html</span><br><span class="line">$ ls</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-class">.out</span>  main<span class="selector-class">.c</span>  main<span class="selector-class">.gcda</span>  main<span class="selector-class">.gcno</span>  say<span class="selector-class">.c</span>  say<span class="selector-class">.gcda</span>  say<span class="selector-class">.gcno</span>  xxx<span class="selector-class">.html</span>  xxx<span class="selector-class">.main</span><span class="selector-class">.c</span><span class="selector-class">.html</span>  xxx<span class="selector-class">.say</span><span class="selector-class">.c</span><span class="selector-class">.html</span></span><br></pre></td></tr></table></figure></p>
<p>可以发现多了<code>xxx.main.c.html</code>和<code>xxx.say.c.html</code>，用浏览器打开<code>xxx.html</code>，如下图：<br><img src="http://o9zpdspb3.bkt.clouddn.com/gcovr_xxx_detail.png" alt="gcovr_xxx_detail.png"><br>文件名较之前带上了下划线，单击文件名，可以看到具体的代码覆盖情况，如下图：<br><img src="http://o9zpdspb3.bkt.clouddn.com/gcovr_xxx_main.png" alt="gcovr_xxx_main.png"></p>
<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>其它功能，如<code>Filters</code>等，可以参考<a href="https://gcovr.com/guide.html" target="_blank" rel="noopener">官方文档</a></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc/Gcov.html#Gcov" target="_blank" rel="noopener">gcov—a Test Coverage Program</a></li>
<li><a href="https://blog.csdn.net/bryanlai0720/article/details/38729535" target="_blank" rel="noopener">关于C++ code coverage tool 的研究 —GCOV 实现原理</a></li>
<li><a href="https://gcovr.com/installation.html" target="_blank" rel="noopener">gcovr官网</a></li>
</ul>
<h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p>
<ul>
<li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li>
<li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li>
<li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li>
<li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li>
<li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li>
</ul>
<p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>
]]></content>
      
        <categories>
            
            <category> C </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 代码覆盖率 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[cJSON的秘密]]></title>
      <url>http://answerywj.com/2018/05/03/introduction-of-cjson/</url>
      <content type="html"><![CDATA[<p>学习使用cJSON过程的一些发现和总结，不涉及具体的函数<br><a id="more"></a></p>
<h2 id="cJSON简介"><a href="#cJSON简介" class="headerlink" title="cJSON简介"></a>cJSON简介</h2><p><code>cJSON</code>是一个快速，高性能的<code>json</code>解析器，由<code>C</code>语言编写，仅包含<code>cJSON.c</code>和<code>cJSON.h</code>两个文件，不支持跨平台；跨平台推荐纯<code>lua</code>写的<a href="http://dkolf.de/src/dkjson-lua.fsl/home" target="_blank" rel="noopener"><code>dkjson</code></a></p>
<h2 id="cJSON结构体"><a href="#cJSON结构体" class="headerlink" title="cJSON结构体"></a>cJSON结构体</h2><p><code>cJSON</code>结构体的组成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cJSON</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cJSON</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cJSON</span> *<span class="title">child</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> type;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> *valuestring;</span><br><span class="line">	<span class="keyword">int</span> valueint;</span><br><span class="line">	<span class="keyword">double</span> valuedouble;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> *<span class="built_in">string</span>;</span><br><span class="line">&#125; cJSON;</span><br></pre></td></tr></table></figure>
<p>其中</p>
<ul>
<li><code>next</code>指向链表中下一个兄弟节点，<code>prev</code>指向本节点前一个节点</li>
<li><code>child</code>节点只有对象和数组有，并且<code>child</code>节点是双向链表的头节点，<code>child</code>的<code>prev</code>一般为<code>NULL</code>，不指向任何节点，双向链表的最后一个兄弟节点的<code>next</code>是无指向的</li>
<li><code>type</code>取值有<code>Null/True/False/Number/String/Array/Object</code>，这些值类型都在<code>cJSON.h</code>中通过宏定义了</li>
<li><code>String</code>类型节点有<code>valuestring</code>，<code>Number</code>类型节点有<code>valueint</code>和<code>valuedouble</code></li>
<li><code>string</code>表示节点的名称，所有的节点都是一个链表，都具有<code>string</code>值</li>
</ul>
<blockquote>
<p><code>cJSON</code>默认所有值都为<code>0</code>，除非额外为其赋有意义的值</p>
</blockquote>
<h3 id="cJSON树结构"><a href="#cJSON树结构" class="headerlink" title="cJSON树结构"></a>cJSON树结构</h3><p><code>cJSON</code>使用树结构存储<code>JSON</code>的各个节点，而这个树结构是使用双向链表实现的(实线表示节点间有真实的引用关系，而虚线表示逻辑上的引用关系)：<br><img src="http://o9zpdspb3.bkt.clouddn.com/cJSON%E6%A0%91%E7%8A%B6%E7%BB%93%E6%9E%84.png" alt="cJSON树结构"></p>
<ul>
<li>树结构的每一层都是一个双向链表，表示一堆兄弟节点</li>
<li>当前层的所有节点都是当前链表头节点的父节点的子节点</li>
</ul>
<p>下面举例说明：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"Jack (\"Bee\") Nimble"</span>, </span><br><span class="line">    <span class="attr">"format"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>:       <span class="string">"rect"</span>, </span><br><span class="line">        <span class="attr">"width"</span>:      <span class="number">1920</span>, </span><br><span class="line">        <span class="attr">"height"</span>:     <span class="number">1080</span>, </span><br><span class="line">        <span class="attr">"interlace"</span>:  <span class="literal">false</span>, </span><br><span class="line">        <span class="attr">"frame rate"</span>: <span class="number">24</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>name</code>和<code>format</code>节点组成一个链表，<code>type</code>、<code>width</code>、<code>height</code>、<code>interlace</code>和<code>frame rate</code>节点组成一个链表</li>
<li>根节点包含节点类型<code>Object</code>和子节点<code>name</code></li>
<li>子节点包含节点名称<code>name</code>、节点值<code>Jack (&quot;Bee&quot;) Nimble</code>和兄弟节点<code>format</code></li>
<li><code>format</code>节点包含节点类型<code>Object</code>、节点名称<code>format</code>和子节点<code>type</code></li>
<li><code>type</code>节点包含节点类型<code>String</code>、节点名称<code>type</code>、节点值<code>rect</code>和兄弟节点<code>width</code></li>
<li><code>width</code>节点包含节点类型<code>Number</code>、节点名称<code>width</code>、节点值<code>1920</code>和兄弟节点<code>height</code></li>
<li><code>height</code>节点包含节点类型<code>Number</code>、节点名称<code>height</code>、节点值<code>1080</code>和兄弟节点<code>interlace</code> </li>
<li><code>interlace</code>节点包含节点类型<code>False</code>、节点名称<code>interlace</code>和兄弟节点<code>frame rate</code></li>
<li><code>frame rate</code>节点包含节点类型<code>Number</code>、节点名称<code>frame tate</code>和节点值<code>25</code></li>
</ul>
<h2 id="cJSON内存管理"><a href="#cJSON内存管理" class="headerlink" title="cJSON内存管理"></a>cJSON内存管理</h2><p><code>cJson</code>分为自动和手动两种使用方式：</p>
<ul>
<li>在自动模式下，<code>cJSON</code>使用默认的<code>malloc</code>和<code>free</code>函数管理内存，在<code>cJSON</code>中，每个节点都是<code>malloc</code>而来，每个节点的<code>string</code>和<code>valuestring</code>也是<code>malloc</code>而来，使用<code>cJSON_Delete</code>函数可以递归释放<code>JSON</code>树中<code>malloc</code>的节点内存和字符内存，使用<code>cJSON_Print</code>函数后，则需要手动释放<code>cJSON_Print</code>函数分配的内存，避免内存泄露</li>
<li>在手动模式下，<code>cJSON</code>提供了钩子函数来帮助用户自定义内存管理函数，如果不设置，这默认为<code>malloc</code>和<code>free</code></li>
</ul>
<figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cJSON_Hooks</span> js_hook = </span>&#123;xxx_malloc, xxx_free&#125;;</span><br><span class="line">cJSON_InitHooks(&amp;js_hook);</span><br></pre></td></tr></table></figure>
<h2 id="cJSON序列化"><a href="#cJSON序列化" class="headerlink" title="cJSON序列化"></a>cJSON序列化</h2><p><code>cJSON</code>序列化就是把<code>cJSON</code>输出，有两种形式：</p>
<ul>
<li>格式化输出<code>char  *cJSON_Print(cJSON *item);</code></li>
<li>压缩输出<code>char  *cJSON_PrintUnformatted(cJSON *item);</code></li>
</ul>
<p>需要注意的是<code>cJSON</code>采用了预先将要输的内容全部以字符串形式存储在内存中，最后输出整个字符串的方法，而不是边分析<code>json</code>数据边输出，所以对于比较大的<code>json</code>数据来说，内存就是个问题了</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://github.com/faycheng/cJSON" target="_blank" rel="noopener">cJson源码和源码分析</a></li>
</ul>
<h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p>
<ul>
<li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li>
<li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li>
<li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li>
<li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li>
<li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li>
</ul>
<p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>
]]></content>
      
        <categories>
            
            <category> C </category>
            
        </categories>
        
        
        <tags>
            
            <tag> cJSON </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux下core文件使用]]></title>
      <url>http://answerywj.com/2018/03/07/usage-of-core-in-linux/</url>
      <content type="html"><![CDATA[<p>有时候程序会异常退出而不带任何日志，此时就可以使用<code>code</code>文件进行分析，它会记录程序运行的内存，寄存器，堆栈指针等信息</p>
<hr>
<a id="more"></a>
<h2 id="什么是core文件"><a href="#什么是core文件" class="headerlink" title="什么是core文件"></a>什么是core文件</h2><p>通常在<code>Linux</code>下遇到程序异常退出或者中止，我们都会使用<code>core</code>文件进行分析，其中包含了程序运行时的内存，寄存器，堆栈指针等信息，格式为<code>ELF</code>，可以理解是程序工作当前状态转储成一个文件，通过工具分析这个文件，我们可以定位到程序异常退出或者终止时相应的堆栈调用等信息，为解决问题提供帮助。</p>
<h2 id="使用core文件调试"><a href="#使用core文件调试" class="headerlink" title="使用core文件调试"></a>使用core文件调试</h2><h3 id="生成方法"><a href="#生成方法" class="headerlink" title="生成方法"></a>生成方法</h3><ol>
<li><p>查看当前<code>core</code>文件的状态</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ulimit -a</span><br><span class="line">...</span><br><span class="line">-c: core file size <span class="params">(blocks)</span>         0  # 关闭状态</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开生成开关</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ulimit -c unlimited</span><br><span class="line">ulimit -a</span><br><span class="line">...</span><br><span class="line">-c: core file size <span class="params">(blocks)</span>         unlimited</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>对<code>core</code>文件的大小进行限制，单位为<code>blocks</code>，一般<code>1 block=512 bytes</code>，设置太小可能导致不会生成文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">ulimit</span> -c 1024</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">ulimit</span> -a</span></span><br><span class="line">...</span><br><span class="line">-c: core file size (blocks)         1024</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭生成开关</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ulimit -c <span class="number">0</span></span><br><span class="line">ulimit -a</span><br><span class="line">...</span><br><span class="line">-c: core file size <span class="params">(blocks)</span>         0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>上面对<code>core</code>文件的操作仅对当前生效，若需要永久生效，则要将相应操作写入<code>/etc/profile</code></p>
</blockquote>
<h3 id="生成路径"><a href="#生成路径" class="headerlink" title="生成路径"></a>生成路径</h3><p><code>core</code>文件默认生成在程序的工作目录，可以对生成路径进行设置，需要保证对对应目录有足够空间并具有写权限<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="regexp">/MyCoreDumpDir/</span>core.%e.%p &gt; <span class="regexp">/proc/</span>sys<span class="regexp">/kernel/</span>core_pattern</span><br></pre></td></tr></table></figure></p>
<p>其中命名使用的参数列表<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%p - <span class="keyword">insert</span> pid <span class="keyword">into</span> filename  <span class="comment"># 添加 pid </span></span><br><span class="line">%u - <span class="keyword">insert</span> <span class="keyword">current</span> uid <span class="keyword">into</span> filename  <span class="comment"># 添加当前 uid </span></span><br><span class="line">%g - <span class="keyword">insert</span> <span class="keyword">current</span> gid <span class="keyword">into</span> filename  <span class="comment"># 添加当前 gid </span></span><br><span class="line">%s - <span class="keyword">insert</span> signal that caused the coredump <span class="keyword">into</span> the filename  <span class="comment"># 添加导致产生 core 的信号 </span></span><br><span class="line">%t - <span class="keyword">insert</span> UNIX <span class="built_in">time</span> that the coredump occurred <span class="keyword">into</span> filename  <span class="comment"># 添加 core 文件生成时的 unix 时间 </span></span><br><span class="line">%h - <span class="keyword">insert</span> hostname <span class="keyword">where</span> the coredump happened <span class="keyword">into</span> filename  <span class="comment"># 添加主机名 </span></span><br><span class="line">%e - <span class="keyword">insert</span> coredumping executable <span class="keyword">name</span> <span class="keyword">into</span> filename  <span class="comment"># 添加命令名</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>/proc/sys/kernel/core_uses_pid</code>这个文件的值若为１，则无论时候配置<code>%p</code>,最后生成的<code>core</code>文件都会添加<code>pid</code></p>
</blockquote>
<h3 id="调试方法"><a href="#调试方法" class="headerlink" title="调试方法"></a>调试方法</h3><p>可以使用<code>gdb</code>对<code>core</code>文件进行调试，编译是需要带上<code>-g</code>选项<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gdb <span class="selector-tag">a</span>.out</span><br><span class="line">...</span><br><span class="line">(gdb) core-file core</span><br><span class="line">...</span><br><span class="line">(gdb) bt </span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>如需要在<code>PC</code>上调试嵌入式设备产生的<code>core</code>文件，则需要选取相应平台的<code>gdb</code>工具，并在进入<code>gdb</code>后设置符号文件的位置<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ xxx-xxx-gdb <span class="selector-tag">a</span>.out</span><br><span class="line">...</span><br><span class="line">(gdb) solib-search-path xxx<span class="selector-class">.so</span>:xxx.so</span><br><span class="line">...</span><br><span class="line">(gdb) core-file core</span><br><span class="line">...</span><br><span class="line">(gdb) bt</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p>
<ul>
<li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li>
<li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li>
<li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li>
<li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li>
<li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li>
</ul>
<p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> core dump </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Speex介绍]]></title>
      <url>http://answerywj.com/2017/12/29/Introduction-of-speex/</url>
      <content type="html"><![CDATA[<p>本文将对<em>Speex</em>相关的概念进行介绍</p>
<hr>
<a id="more"></a>
<p>[TOC]</p>
<p><em>Speex</em>编解码器是一款开源且免费的语音编解码器，遵循<em>BSD</em>协议，为分封网络（<em>packet network</em>）和网络电话（<em>VoIP</em>）而设计，支持文件的压缩</p>
<blockquote>
<p>为网络电话而不是移动电话而设计，意味着<em>Speex</em>对数据丢失具有鲁棒性，但是对数据包损坏不鲁棒，在<em>VoIP</em>中的数据包要么完整到达，要么不能到达</p>
</blockquote>
<p><em>Speex</em>选用CELP（码激励线性预测编码）编码技术，在高比特率和低比特率都稳定可靠，复杂性适度并且占用内存较少</p>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="采样率"><a href="#采样率" class="headerlink" title="采样率"></a>采样率</h3><p>采样率是每秒钟采集到的信号样本数，单位是<em>Hertz</em>（<em>Hz</em>），<em>Speex</em>为三种不同的采样率而设计：<em>8kHz</em>（窄带），<em>16kHz</em>（宽带）和<em>32kHz</em>（超宽带）</p>
<h3 id="比特率"><a href="#比特率" class="headerlink" title="比特率"></a>比特率</h3><p>在对语音信号编码时，比特率定义为单位时间内的比特数，单位是比特每秒（<em>bps</em>）或通常的千比特每秒（<em>kbps</em>）</p>
<blockquote>
<p>注意千比特每秒（<em>kbps</em>）和千字节每秒（<em>kBps</em>）的区别。</p>
</blockquote>
<h3 id="质量（可变）"><a href="#质量（可变）" class="headerlink" title="质量（可变）"></a>质量（可变）</h3><p><em>Speex</em>是有损的编解码器，意味着压缩率以输入语音信号的保真度为代价，质量越高，压缩后的比特率越大，音质也越好<br><em>Speex</em>可以控制质量和比特率之间的折中，大多数时间由一个范围在<em>0</em>到<em>10</em>之间的质量参数控制</p>
<blockquote>
<p>在不变比特率（<em>CBR</em>）中，质量参数是一个整数； 在可变比特率（<em>VBR</em>）中，质量参数是一个浮点数。</p>
</blockquote>
<h3 id="复杂度（可变）"><a href="#复杂度（可变）" class="headerlink" title="复杂度（可变）"></a>复杂度（可变）</h3><p><em>Speex</em>允许编码器拥有可变的复杂度，通过一个范围在<em>1</em>到<em>10</em>之间的整数控制搜索的执行来实现，复杂度越高，压缩率越高，CPU使用率越高，音质越好，类似于<em>gzip</em>和<em>bzip2</em>压缩工具的-1到<em>-9</em>选项<br>正常使用情况下，复杂度为<em>1</em>的噪声等级比复杂度为<em>10</em>的噪声等级高<em>1</em>到<em>2</em>个<em>dB</em>，但复杂度为<em>10</em>的<em>CPU</em>要求比复杂度为1的高<em>5</em>倍。</p>
<blockquote>
<p>实际应用中，最好的折中是复杂度<em>2</em>到<em>4</em>，但在编码非语音声音如<em>DTMF</em>声调时更高的复杂度经常被用到</p>
</blockquote>
<h3 id="可变比特率（VBR）"><a href="#可变比特率（VBR）" class="headerlink" title="可变比特率（VBR）"></a>可变比特率（<em>VBR</em>）</h3><p>可变比特率（<em>VBR</em>）允许编解码器自适应的根据待编码音频的“难度”动态地改变比特率，如元音和高能瞬态变化的声音需要高比特率以获得好的质量； 但是摩擦音（如<em>s，f</em>）用低比特率就能充分编码</p>
<ul>
<li>优点：<em>VBR</em>在相同的质量下能获得更低的比特率，或在不变比特率下获得更好的质量</li>
<li>缺点：在指定质量情况下，无法保证最终的平均比特率；在一些如网络电话（<em>VoIP</em>）这样的实时应用中，依赖于最大比特率，这在通信信道中必须足够低。</li>
</ul>
<h3 id="平均比特率（ABR）"><a href="#平均比特率（ABR）" class="headerlink" title="平均比特率（ABR）"></a>平均比特率（<em>ABR</em>）</h3><p>平均比特率解决了<em>VBR</em>中的一个问题，它动态地调整<em>VBR</em>质量以获得指定的比特率，因为质量和比特率是实时调整的，<em>ABR</em>的全局质量比正好达到目标平均比特率的<em>VBR</em>编码质量稍微差些。</p>
<h3 id="声音活动检测（VAD）"><a href="#声音活动检测（VAD）" class="headerlink" title="声音活动检测（VAD）"></a>声音活动检测（<em>VAD</em>）</h3><p><em>VAD</em>检测待编码的音频是语音还是无声/背景噪声，<em>VBR</em>编码中默认激活</p>
<blockquote>
<p><em>Speex</em>检测出非语言段并仅使用足够复现背景噪声的比特率进行编码，这叫“柔化噪音生成”（<em>CNG</em>）。</p>
</blockquote>
<h3 id="断续传输（DTX）"><a href="#断续传输（DTX）" class="headerlink" title="断续传输（DTX）"></a>断续传输（DTX）</h3><p>断续传输是<em>VAD/VBR</em>的附加操作，当背景噪声平稳时会完全停止传输</p>
<h3 id="知觉增强"><a href="#知觉增强" class="headerlink" title="知觉增强"></a>知觉增强</h3><p>知觉增强是解码器的一部分，当被启用时，能减少编解码过程中产生的噪声或失真的知觉</p>
<blockquote>
<p>在大多数情况下，知觉增强会带来声音客观上的偏离（如仅考虑<em>SNR</em>），但最后仍听起来更好（主管增强）</p>
</blockquote>
<h3 id="等待时间和算法延时"><a href="#等待时间和算法延时" class="headerlink" title="等待时间和算法延时"></a>等待时间和算法延时</h3><p>每一个语音编解码器在传输中都会引入延时，对于<em>Speex</em>，延时等于帧长加上处理每一帧需要前几帧的数量</p>
<blockquote>
<p>在窄带操作中延时为<em>30ms</em>，在宽带操作中延时为<em>34ms</em>，这不包括编解码帧时的<em>CPU</em>时间</p>
</blockquote>
<h2 id="相关组件"><a href="#相关组件" class="headerlink" title="相关组件"></a>相关组件</h2><h3 id="编解码器"><a href="#编解码器" class="headerlink" title="编解码器"></a>编解码器</h3><p><em>Speex</em>编解码器有以下特性</p>
<ol>
<li>免费软件/开源，免专利费和版税</li>
<li>利用嵌入比特流集成了窄带和宽带</li>
<li>大范围可用比特率（从<em>2.15kbps</em>到<em>44kbps</em>）</li>
<li>动态比特率转换（<em>AMR</em>）和可变比特率操作（<em>VBR</em>）</li>
<li>声音活动检测（<em>VAD</em>，与<em>VBR</em>集成）和断续传输（<em>DTX</em>）</li>
<li>可变复杂度</li>
<li>嵌入宽带结构（可伸缩采样率）</li>
<li><em>32kHz</em>超宽带采样率</li>
<li>强度立体声编码选项</li>
<li>定点实现</li>
</ol>
<h3 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h3><p>预处理器在对音频编码前对音频进行预处理，有三个主要功能</p>
<ol>
<li>噪声抑制<br>先降噪再进行编解码是有好处的，因为<em>Speex</em>编解码器通常会对噪声输入同样进行编解码，这将会扩大噪声，而降噪能大大减少这一影响</li>
<li>自动增益控制（<em>AGC</em>）<br>自动增益控制（<em>AGC</em>）是为了处理录音音量在不同设置里有很大差别这一问题，<em>AGC</em>将会调整信号音量到参考音量大小</li>
<li>声音活动检测（<em>VAD</em>）<br>预处理器提供的声音活动检测（<em>VAD</em>）比编解码器中直接提供的<em>VAD</em>更先进</li>
</ol>
<h3 id="自适应抖动缓冲器"><a href="#自适应抖动缓冲器" class="headerlink" title="自适应抖动缓冲器"></a>自适应抖动缓冲器</h3><p>当通过<em>UDP</em>（<em>User Datagram Protocal</em>，用户数据报协议）或<em>RTP</em>（<em>Real Time Protocal</em>，实时传输协议）传输声音（或其他任何内容）时，数据包可能丢失，不同延时到达，甚至乱序，抖动缓冲器的作用是对数据包进行重排序并保存在足够长的buffer（但有一定限度）里，然后将数据包发送去解码</p>
<h3 id="声学回声消除器"><a href="#声学回声消除器" class="headerlink" title="声学回声消除器"></a>声学回声消除器</h3><p>在任何免提式通信系统中（下图），远端的语音在本地扬声器播放时，经过在房间里传播后又会被麦克风录音，如果将麦克风录音直接又发送到远端，则远端的用户将会听到他自己的回声<br><img src="http://o9zpdspb3.bkt.clouddn.com/aec.png" alt="aec"><br>声学回声消除器就是为了在将录音发送到远端前消除声学回声，提高了远端接收的语音质量</p>
<h3 id="重采样器"><a href="#重采样器" class="headerlink" title="重采样器"></a>重采样器</h3><p>重采样指转换音频的采样率，在任意采样率间进行转换（采样率必须是有理数），能控制质量和复杂度的折中，可用于能混合不同采样率流，支持声卡不支持的采样率，能转码等</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="http://blog.csdn.net/YJJat1989/article/category/1879965" target="_blank" rel="noopener">http://blog.csdn.net/YJJat1989/article/category/1879965</a></li>
</ul>
<h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p>
<ul>
<li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li>
<li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li>
<li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li>
<li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li>
<li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li>
</ul>
<p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>
]]></content>
      
        <categories>
            
            <category> Knowledge </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Speex </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[线程同步机制条件变量的使用与思考]]></title>
      <url>http://answerywj.com/2017/12/15/condition-variables-of-thread-synchronization/</url>
      <content type="html"><![CDATA[<p>条件变量是<em>Linux</em>线程同步的一种机制，与互斥量一起使用时，允许线程以无竞争的方式等待特定条件的发生</p>
<hr>
<a id="more"></a>
<p>[TOC]</p>
<h2 id="关键函数"><a href="#关键函数" class="headerlink" title="关键函数"></a>关键函数</h2><h3 id="初始化与注销"><a href="#初始化与注销" class="headerlink" title="初始化与注销"></a>初始化与注销</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态初始化</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">thread_cond_t</span> *cond, </span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反初始化，即注销</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"></span><br><span class="line">返回值: 若成功，返回<span class="number">0</span>；否则，返回错误编码</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>只有在没有线程在该条件变量上等待时，才可以注销条件变量，否则会返回<code>EBUSY</code></li>
<li><code>Linux</code>在实现条件变量时，并没有为条件变量分配资源，所以在注销一个条件变量时，只需要注意该变量是否仍有等待线程即可</li>
</ul>
<h3 id="线程等待"><a href="#线程等待" class="headerlink" title="线程等待"></a>线程等待</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond, </span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond, </span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">pthread_mutex_t</span> *mutex, </span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">const</span> struct timespec *abstime)</span></span>;</span><br><span class="line"></span><br><span class="line">返回值: 若成功，返回<span class="number">0</span>；否则，返回错误编码</span><br></pre></td></tr></table></figure>
<p>执行过程如下：</p>
<ol>
<li>调用者把锁住的互斥量传给函数，然后函数自动把调用线程放到等待条件的线程列表上</li>
<li>对互斥量进行解锁，线程挂起进入等待(不占用<code>CPU</code>时间)　</li>
<li>函数被唤醒返回时，会自动对互斥量进行加锁</li>
</ol>
<blockquote>
<p><code>pthread_cond_timedwait</code>只是多了一个等待超时时间，通过<code>timespec</code>指定，超时返回错误<code>ETIMEDOUT</code></p>
</blockquote>
<h3 id="线程唤醒"><a href="#线程唤醒" class="headerlink" title="线程唤醒"></a>线程唤醒</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"></span><br><span class="line">返回值: 若成功，返回<span class="number">0</span>；否则，返回错误编码</span><br></pre></td></tr></table></figure>
<ul>
<li><code>pthread_cond_signal</code>至少能唤醒一个等待该条件的线程</li>
<li><code>pthread_cond_broadcast</code>则能唤醒等待该条件的所有线程<blockquote>
<p>需要注意的是，一定要在改变条件状态以后再给线程发信号</p>
</blockquote>
</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例代码可参考我的<a href="https://github.com/AnSwErYWJ/DogFood/blob/24acbfdd45e80032c988ccd05e3b12f9cfe01849/C/thread/t_cond.c" target="_blank" rel="noopener">github</a>，由于篇幅原因，不在此贴出</p>
<h2 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h2><h3 id="条件变量实质是什么"><a href="#条件变量实质是什么" class="headerlink" title="条件变量实质是什么"></a>条件变量实质是什么</h3><p>条件变量实质是利用线程间共享的全局变量进行同步的一种机制</p>
<h3 id="互斥量保护的是什么"><a href="#互斥量保护的是什么" class="headerlink" title="互斥量保护的是什么"></a>互斥量保护的是什么</h3><p>示例中的相关代码<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">pthread_mutex_lock</span>(&amp;(test-&gt;</span>mut));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">while</span> (test-&gt;</span>condition == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="title">pthread_cond_wait</span>(&amp;(test-&gt;</span><span class="function"><span class="title">cond</span>), &amp;(test-&gt;</span>mut));</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="title">pthread_mutex_unlock</span>(&amp;(test-&gt;</span>mut));</span><br></pre></td></tr></table></figure></p>
<p>互斥量是用来保护条件<code>test-&gt;condition</code>在读取时，它的值不被其它线程修改，如果条件成立，则此线程进入等待条件的线程队列，对互斥量进行解锁并开始等待</p>
<h3 id="为什么用while来判断条件"><a href="#为什么用while来判断条件" class="headerlink" title="为什么用while来判断条件"></a>为什么用while来判断条件</h3><p>如上面的代码所示，使用<code>while</code>对条件进行判断的原因如下：</p>
<ol>
<li>若先解锁互斥量，再唤醒等待线程，则条件可能被其它线程更改，使得等待条件再次成立，需要继续等待</li>
<li><code>pthread_cond_wait</code>可能存在意外返回的情况，则此时条件并没有被更改，需要继续等待。<blockquote>
<p>造成意外返回的原因是<code>Linux</code>中带阻塞功能的系统调用都会在进程收到<code>signal</code>后返回</p>
</blockquote>
</li>
</ol>
<h3 id="先唤醒线程还是先解锁"><a href="#先唤醒线程还是先解锁" class="headerlink" title="先唤醒线程还是先解锁"></a>先唤醒线程还是先解锁</h3><p>示例代码：</p>
<ol>
<li><p>情况一：先唤醒</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(<span class="name">&amp;</span>(<span class="name">test-&gt;mut</span>))<span class="comment">;</span></span><br><span class="line">test-&gt;condition = <span class="number">1</span></span><br><span class="line">pthread_cond_signal(<span class="name">&amp;</span>(<span class="name">test-&gt;cond</span>))<span class="comment">;</span></span><br><span class="line">pthread_mutex_unlock(<span class="name">&amp;</span>(<span class="name">test-&gt;mut</span>))<span class="comment">;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>情况二：先解锁</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(<span class="name">&amp;</span>(<span class="name">test-&gt;mut</span>))<span class="comment">;</span></span><br><span class="line">test-&gt;condition = <span class="number">1</span></span><br><span class="line">pthread_mutex_unlock(<span class="name">&amp;</span>(<span class="name">test-&gt;mut</span>))<span class="comment">;</span></span><br><span class="line">pthread_cond_signal(<span class="name">&amp;</span>(<span class="name">test-&gt;cond</span>))<span class="comment">;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>两种情况各有缺点：</p>
<ul>
<li>情况一在唤醒等待线程后，再解锁，使得等待线程在被唤醒后试图对互斥量进行加锁时，互斥量还未解锁，则线程又进入睡眠，待互斥量解锁成功后，再次被唤醒并对互斥量加锁，这样就会发生两次上下文切换，影响性能</li>
<li>情况二在唤醒等待线程前先解锁，使得其它线程可能先于等待线程获取互斥量，并对条件进行更改，使得条件变量失去作用</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://www.cnblogs.com/leijiangtao/p/4028338.html" target="_blank" rel="noopener">关于pthread_cond_wait使用while循环判断的理解</a></li>
<li><a href="https://www.cnblogs.com/zhx831/p/3543633.html" target="_blank" rel="noopener">Linux线程同步之条件变量pthread_cond_t</a></li>
<li><a href>APUE</a></li>
</ul>
<h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p>
<ul>
<li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li>
<li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li>
<li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li>
<li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li>
<li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li>
</ul>
<p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>
]]></content>
      
        <categories>
            
            <category> C </category>
            
        </categories>
        
        
        <tags>
            
            <tag> pthread </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GCC编译ARM篇]]></title>
      <url>http://answerywj.com/2017/08/04/gcc-compilation-of-arm-articles/</url>
      <content type="html"><![CDATA[<p><code>ARM</code> 平台下<code>GCC</code>编译相关介绍，待补充<br><a id="more"></a></p>
<h2 id="ARM处理器架构"><a href="#ARM处理器架构" class="headerlink" title="ARM处理器架构"></a>ARM处理器架构</h2><p><code>ARM</code>处理器架构，通过选项<code>-march</code>指定，如<code>-march=armv7-a</code>，常见的有</p>
<ol>
<li><code>armv5te</code><br><code>arm9</code>系列使用该架构</li>
<li><code>armv6</code><br><code>arm11</code>系列使用该架构</li>
<li><code>armv7-a</code><br><code>cortex-a</code>系列使用该架构，如<code>cortex-a5、a7、a8、a9、a12、a15</code></li>
<li><code>armv8</code><br><code>cortex-a</code>系列使用该架构，如<code>cortex-a53、a57、a72</code></li>
</ol>
<h2 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h2><p>指令集，通过选项<code>-m</code>指定，如<code>-mthumb</code>，常见的有</p>
<ol>
<li><code>thumb</code><br>16位指令集，它将32位arm指令的压缩成16位的指令编码方式，节省代码存储空间，实现低功耗</li>
<li><code>thumb-2</code><br>16位/32位指令集，对<code>thumb</code>指令集进行了扩充，增加了一些32位指令，改善<code>thumb</code>指令集的性能</li>
<li><code>arm</code><br>32位指令集, 兼容所有<code>arm</code>架构，性能高</li>
</ol>
<h2 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h2><p>浮点运算的类型，通过选项<code>-mfloat-abi</code>指定，如<code>-mfloat-abi=hard</code>，有三种类型</p>
<ol>
<li><code>soft</code><br>使用软浮点库进行浮点运算，不使用硬浮点单元，适用于不含<code>FPU</code>的<code>CPU</code></li>
<li><code>softfp</code><br>使用硬浮点单元进行浮点运算，生成硬浮点指令，调用接口的规则和<code>soft</code>兼容</li>
<li><code>hard</code><br>使用硬浮点单元进行浮点运算，生成硬浮点指令，与<code>softfp</code>的区别在于调用接口的规则不同</li>
</ol>
<p>硬浮点指令的类型，通过选项<code>-mfpu</code>指定，如<code>-mfpu=neon</code>，常用的有两种</p>
<ol>
<li><code>vfp</code><br>其中<code>vfpv2</code>应用于<code>armv5te, armv6</code>架构中的浮点计算指令集，<code>vfpv3</code>和<code>vfpv4</code>应用于部分<code>armv7a</code>架构中的浮点计算指令集</li>
<li><code>neon</code><br>应用于<code>cortex-a</code>系列处理器，性能好</li>
</ol>
<h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p>
<ul>
<li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li>
<li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li>
<li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li>
<li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li>
<li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li>
</ul>
<p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>
]]></content>
      
        <categories>
            
            <category> Compile </category>
            
        </categories>
        
        
        <tags>
            
            <tag> gcc </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[UNIX下IO模型分析]]></title>
      <url>http://answerywj.com/2017/06/27/unix-io-model-analysis/</url>
      <content type="html"><![CDATA[<p>对<em>UNIX</em>下的五种常见<em>IO</em>模型分析，帮助理解<br><a id="more"></a></p>
<h2 id="IO操作的两个阶段"><a href="#IO操作的两个阶段" class="headerlink" title="IO操作的两个阶段"></a>IO操作的两个阶段</h2><p>以读数据操作为例：</p>
<ol>
<li>等待内核数据准备（数据拷贝到内核缓冲区）</li>
<li>将数据从内核拷贝到用户空间</li>
</ol>
<h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><p><em>UNIX</em>下共有五种常见的<em>IO</em>模型：<br><img src="http://o9zpdspb3.bkt.clouddn.com/5IO.png" alt="UNIX下共有五种常见的IO模型"></p>
<p>下面以<code>recvfrom</code>接口举例</p>
<h3 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h3><p>默认情况下，所有的套接字都是阻塞的<br><img src="http://o9zpdspb3.bkt.clouddn.com/blockingIO.png" alt="阻塞IO"><br>调用<code>recvfrom</code>接口，进程在<em>IO</em>操作的两个阶段都会阻塞，直到最终数据拷贝到用户空间或者过程中出现错误才会返回，进程在阻塞状态下是不占用<em>CPU</em>资源的</p>
<blockquote>
<p>最常见的错误是发生系统中断，此时需要重读，可参考<a href="https://github.com/AnSwErYWJ/DogFood/blob/master/C/RD.c" target="_blank" rel="noopener">这里</a></p>
</blockquote>
<h3 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h3><p>可以通过<code>fcntl(sockfd,F_SETFL,O_NONBLOCK)</code>将套接字设置成非阻塞<br><img src="http://o9zpdspb3.bkt.clouddn.com/noblockingIO.png" alt="非阻塞IO"><br>调用<code>recvfrom</code>接口，无论内核缓冲区是否有可用数据，进程都会立即返回，所以在<em>IO</em>操作的第一阶段是非阻塞的; 若无数据可用，内核将<code>errno</code>设置为为<code>EWOULDBLOCK</code>或者<code>EAGAIN</code>，进程可以使用轮询的方法，保证内核在数据准备好时，能立即拷贝到用户空间; 若有则立即将数据拷贝到用户空间，进程在数据拷贝到用户空间即<em>IO</em>操作的第二阶段是阻塞的;</p>
<blockquote>
<p>非阻塞<em>IO</em>过于消耗<em>CPU</em>时间，将大部分时间用于轮询</p>
</blockquote>
<h3 id="多路复用IO"><a href="#多路复用IO" class="headerlink" title="多路复用IO"></a>多路复用IO</h3><p>多路复用系统调用：<code>select</code>,<code>poll</code>和<code>epoll</code>，其中<em>windows</em>平台不支持<code>poll</code>和<code>epoll</code>，使用方法可以参考<a href="https://segmentfault.com/a/1190000003063859?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#articleHeader14" target="_blank" rel="noopener">I/O 多路复用之select、poll、epoll详解</a>和<a href="http://www.cnblogs.com/NerdWill/p/4996476.html" target="_blank" rel="noopener">Linux select/poll和epoll实现机制对比</a><br><img src="http://o9zpdspb3.bkt.clouddn.com/multiIO.png" alt=" 多路复用IO"><br>调用<code>select</code>，等待内核数据准备，所以<em>IO</em>操作的第一个阶段，进程是阻塞的，不过是阻塞在多路复用系统调用上，而不是<em>IO</em>系统调用上; 当<code>select</code>返回套接字可读条件时，再调用<code>recvfrom</code>将数据从内核拷贝到用户空间，<em>IO</em>操作的第二阶段，进程是阻塞的</p>
<p>多路复用<em>IO</em>和阻塞<em>IO</em>，在<em>IO</em>操作的两个阶段都是阻塞的，不过多路复用<em>IO</em>使用了两个系统调用，而阻塞<em>IO</em>只使用了一个，所以在连接数不是很多的情况下，阻塞<em>IO</em>可能性能更佳; 多路复用<em>IO</em>的优势在于可以同时监控多个用于<em>IO</em>的文件描述符。</p>
<blockquote>
<p>多线程中的阻塞<em>IO</em>，与多路复用<em>IO</em>极为相似</p>
</blockquote>
<h3 id="信号驱动IO"><a href="#信号驱动IO" class="headerlink" title="信号驱动IO"></a>信号驱动IO</h3><p><img src="http://o9zpdspb3.bkt.clouddn.com/signalIO.png" alt="信号驱动IO"><br>调用<code>sigaction</code>等系统调用安装信号处理函数，并立即返回，所以<em>IO</em>操作的第一阶段，进程是非阻塞的; 当内核数据准备好时，内核会产生一个信号，通知进程将数据从内核拷贝到用户空间，<em>IO</em>操作的第二阶段，进程是阻塞的</p>
<blockquote>
<p>使用方法：<a href="http://www.cnblogs.com/ittinybird/p/4574397.html" target="_blank" rel="noopener">IO的多路复用和信号驱动</a></p>
</blockquote>
<h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><p>异步<em>IO</em>有一组以<code>aio</code>开头的系统调用，使用方法可参考<a href="http://blog.csdn.net/tq02h2a/article/details/3825114" target="_blank" rel="noopener">Linux AIO机制</a><br><img src="http://o9zpdspb3.bkt.clouddn.com/asynIO.png" alt="异步IO"><br>调用异步<em>IO</em>系统调用，给内核传递描述字、缓冲区指针、缓冲区大小（与<code>read</code>相同的三个参数）、文件偏移（与<code>lseek</code>类似），告诉内核当整个操作完成时如何通知我们，并立即返回，在<em>IO</em>操作的两个阶段，进程都不阻塞</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="http://o9zpdspb3.bkt.clouddn.com/5IO-compare.png" alt="5种IO模式比较"></p>
<ul>
<li>同步<em>IO</em>和异步<em>IO</em>的主要区别是将数据从内核拷贝到用户空间是否阻塞，前者会在将数据从内核拷贝到用户空间时即<em>IO</em>操作的第二个阶段发生阻塞，而后者则在系统调用后直接返回，直到内核发送信号通知<em>IO</em>操作完成，在<em>IO</em>操作的两个阶段都没有阻塞</li>
<li>阻塞<em>IO</em>和非阻塞<em>IO</em>的主要区别是系统调用是否立即返回（默认将数据从内核拷贝到用户空间即<em>IO</em>操作的第二个阶段是立即返回的），前者会在<em>IO</em>操作的两个阶段完成前一直阻塞，后者在内核没有准备好数据的情况下立即返回，即只会在<em>IO</em>操作的第二个阶段阻塞</li>
<li>信号驱动<em>IO</em>和异步<em>IO</em>的主要区别在于前者由内核通知我们何时启动一个<em>IO</em>操作，在将数据从内核拷贝到用户空间过程中即<em>IO</em>操作的第一个阶段依旧是阻塞的，而后者是由内核通知我们<em>IO</em>操作何时完成，在<em>IO</em>操作的两个阶段都没有阻塞</li>
</ul>
<blockquote>
<p><a href="https://www.zhihu.com/question/19732473/answer/20851256" target="_blank" rel="noopener">知乎</a>上有一个比较生动的例子可以说明这几种模型之间的关系。</p>
</blockquote>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="http://about:blank" target="_blank" rel="noopener">UNIX网络编程 卷1：套接字联网API</a></li>
<li><a href="https://segmentfault.com/a/1190000003063859?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="noopener">Linux IO模式及 select、poll、epoll详解</a></li>
<li><a href="http://www.cnblogs.com/ittinybird/p/4666044.html" target="_blank" rel="noopener">Linux下5种IO模型的小结</a></li>
<li><a href="http://www.cnblogs.com/nufangrensheng/p/3588690.html" target="_blank" rel="noopener">UNIX网络编程读书笔记：I/O模型（阻塞、非阻塞、I/O复用、信号驱动、异步）</a></li>
<li><a href="http://blog.csdn.net/historyasamirror/article/details/5778378" target="_blank" rel="noopener"> IO - 同步，异步，阻塞，非阻塞 （亡羊补牢篇）</a></li>
<li><a href="http://blog.csdn.net/jay900323/article/details/18141217" target="_blank" rel="noopener">Linux五种IO模型性能分析</a></li>
</ul>
<h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p>
<ul>
<li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li>
<li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li>
<li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li>
<li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li>
<li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li>
</ul>
<p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IO </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[笔记 | OpenResty系列课程]]></title>
      <url>http://answerywj.com/2017/06/20/note-of-openresty-study/</url>
      <content type="html"><![CDATA[<p>观看<a href="http://www.stuq.org/course/1015/study" target="_blank" rel="noopener">OpenResty 系列课程</a>的学习笔记<br><a id="more"></a></p>
<h2 id="用-OpenResty-快乐的搭建高性能服务端"><a href="#用-OpenResty-快乐的搭建高性能服务端" class="headerlink" title="用 OpenResty 快乐的搭建高性能服务端"></a>用 OpenResty 快乐的搭建高性能服务端</h2><h3 id="1-1-OpenResty简介"><a href="#1-1-OpenResty简介" class="headerlink" title="1.1 OpenResty简介"></a>1.1 OpenResty简介</h3><p>高性能服务端的两个特点：</p>
<ul>
<li>缓存（内存&gt;SSD&gt;机械磁盘，本机&gt;网络，进程内&gt;进程外）</li>
<li>异步非阻塞（事件驱动）</li>
</ul>
<h3 id="1-2-hello-world"><a href="#1-2-hello-world" class="headerlink" title="1.2 hello world"></a>1.2 hello world</h3><p>参考资料：</p>
<ul>
<li><a href="http://openresty.org/en/" target="_blank" rel="noopener">官网</a></li>
<li><a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown" target="_blank" rel="noopener">文档</a></li>
</ul>
<p><code>OpenResty = Nginx + LuaJIT（LuaJIT虚拟机嵌在Nginx worker中）</code></p>
<p><a href="https://github.com/openresty/lua-nginx-module#lua_code_cache" target="_blank" rel="noopener">lua_code_cache</a>：<code>lua</code>代码缓存，默认开启，支持<code>set_by_lua_file</code>和<code>content_by_lua_file</code>等指令和<code>lua</code>模块，关闭后方便开发（不用重启Nginx），生产环境建议开启（影响性能）</p>
<p><a href="https://github.com/openresty/lua-nginx-module#content_by_lua_file" target="_blank" rel="noopener">content_by_lua_file</a>：指定要执行的<code>lua</code>文件</p>
<h3 id="1-3-OpenResty入门"><a href="#1-3-OpenResty入门" class="headerlink" title="1.3 OpenResty入门"></a>1.3 OpenResty入门</h3><p>书籍：<a href="https://moonbingbing.gitbooks.io/openresty-best-practices/content/index.html" target="_blank" rel="noopener">openresty最佳实践</a></p>
<p>运行时的错误日志保存在<code>logs/error.log</code>中</p>
<p><code>nginx.conf</code>示例片段：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">location</span> <span class="title">= /api</span>/random &#123;</span><br><span class="line"> content_by_lua_file lua/random.lua;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>random.lua</code>：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> args = ngx.req.get_uri_args() <span class="comment">--max is 100，set 0 to unlimit</span></span><br><span class="line"><span class="keyword">local</span> salt = args.salt</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> salt <span class="keyword">then</span></span><br><span class="line">  ngx.<span class="keyword">exit</span>(ngx.HTTP_BAD_REQUEST)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="built_in">string</span> = ngx.md5(ngx.<span class="built_in">time</span>() .. salt)</span><br><span class="line">ngx.<span class="built_in">say</span>(<span class="built_in">string</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="1-4-ngx-lua-API介绍"><a href="#1-4-ngx-lua-API介绍" class="headerlink" title="1.4 ngx lua API介绍"></a>1.4 ngx lua API介绍</h3><blockquote>
<p>Tips： 不要使用 <code>lua API</code>（阻塞），要用<code>ngx lua API</code>（非阻塞）</p>
</blockquote>
<h3 id="1-5-连接数据库"><a href="#1-5-连接数据库" class="headerlink" title="1.5 连接数据库"></a>1.5 连接数据库</h3><blockquote>
<p>Tips： 数据库操作的代码逻辑看上去是同步的，但是内部实现是异步的</p>
</blockquote>
<p>主要有<a href="https://github.com/openresty/lua-resty-redis" target="_blank" rel="noopener">lua-resty-redis</a>和<a href="https://github.com/openresty/lua-resty-mysql" target="_blank" rel="noopener">lua-resty-mysql</a></p>
<h3 id="1-6-OpenResty缓存"><a href="#1-6-OpenResty缓存" class="headerlink" title="1.6 OpenResty缓存"></a>1.6 OpenResty缓存</h3><ul>
<li><a href="https://github.com/openresty/lua-nginx-module#ngxshareddict" target="_blank" rel="noopener">share_dict</a>： 字典缓存，纯内存缓存，可以预设内存大小，多个<code>worker</code>共享，需要锁操作</li>
<li><a href="https://github.com/openresty/lua-resty-lrucache" target="_blank" rel="noopener">lua-resty-lrucache</a>：可以预设<code>key</code>个数，单个<code>worker</code>使用，内存使用翻倍  </li>
</ul>
<p>缓存失效风暴：在缓存超时时间触发的瞬间，所有的并发请求都同时执行数据库查询操作，数据库压力瞬间变大，下次请求又全部进入缓存，压力瞬间变小，出现两个极值。可以使用<a href="https://github.com/openresty/lua-resty-lock" target="_blank" rel="noopener">lua-resty-lock</a>对数据库查询操作加锁，使数据库查询只进行一次</p>
<h3 id="1-7-FFI和第三方模块"><a href="#1-7-FFI和第三方模块" class="headerlink" title="1.7 FFI和第三方模块"></a>1.7 FFI和第三方模块</h3><p><code>FFI</code>：<code>LuaJIT</code>的一个库，可以在<code>LuaJIT</code>中调用<code>C</code>的数据结构和外部<code>C</code>函数。如<a href="https://github.com/openresty/lua-resty-string/blob/master/lib/resty/random.lua" target="_blank" rel="noopener">random.lua</a><br>第三方模块：放在<code>/openresty/lualib/resty</code>目录下。</p>
<h3 id="1-8-子查询"><a href="#1-8-子查询" class="headerlink" title="1.8 子查询"></a>1.8 子查询</h3><p><code>ngx.location.capture</code>和<code>ngx.location.capture_multi</code>：在一个<code>location</code>内部，对另一个<code>location</code>进行请求，因为这不是<code>http</code>请求，是<code>C</code>级别的调用，所以有开销小的优点; 同时可以降级服务（某一个非关键服务<code>down</code>掉，可以继续使用），开放给前端就一个<code>api</code>接口即可，在这个<code>api</code>接口内做多个子查询，不需要前端调用多个<code>api</code>进行查询，避免由于某一个<code>api</code>服务挂掉而导致阻塞<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">location = /api/test_parallels &#123;</span><br><span class="line">content_by_lua_block &#123;</span><br><span class="line">local start_time = ngx.now()</span><br><span class="line">local res1, res2 = ngx.location.capture_multi(&#123;</span><br><span class="line">		  &#123;<span class="string">"/sum"</span>,&#123;args=&#123;<span class="attribute">a</span>=3, <span class="attribute">b</span>=8&#125;&#125;&#125;,</span><br><span class="line">		  &#123;<span class="string">"/subduction"</span>,&#123;args=&#123;<span class="attribute">a</span>=3, <span class="attribute">b</span>=8&#125;&#125;&#125;,</span><br><span class="line">		  &#125;)</span><br><span class="line">ngx.say(<span class="string">"status:"</span>, res1.status, <span class="string">"response:"</span>, res1.body)</span><br><span class="line">ngx.say(<span class="string">"status:"</span>, res2.status, <span class="string">"response:"</span>, res2.body)</span><br><span class="line">ngx.say(<span class="string">"time used:"</span>, ngx.now()-start_time)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="1-9-执行阶段"><a href="#1-9-执行阶段" class="headerlink" title="1.9 执行阶段"></a>1.9 执行阶段</h3><p>这个是<code>Nginx</code>和<code>OpenResty</code>独有的概念，不同的阶段有不同的处理行为，可参考<a href="https://moonbingbing.gitbooks.io/openresty-best-practices/content/ngx_lua/phase.html" target="_blank" rel="noopener">执行阶段概念</a></p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>更改conf后，检查conf文件是否正确：<code>nginx -t -c [conf]</code><br>重启：<code>nginx：nginx -s reload -p [path]</code></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="http://www.stuq.org/course/1015/study" target="_blank" rel="noopener">OpenResty 系列课程</a></li>
<li><a href="http://openresty.org/en/" target="_blank" rel="noopener">OpenResty官网</a></li>
<li><a href="https://github.com/openresty" target="_blank" rel="noopener">OpenResty</a></li>
</ul>
<h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p>
<ul>
<li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li>
<li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li>
<li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li>
<li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li>
<li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li>
</ul>
<p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>
]]></content>
      
        <categories>
            
            <category> OpenResty </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OpenResty </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[记一次踩坑|空table应该编码为数组还是对象]]></title>
      <url>http://answerywj.com/2017/06/16/table-encode-as-array-or-object/</url>
      <content type="html"><![CDATA[<p><code>Json</code>有两种比较常用的数据类型：被<code>{}</code>包裹的对象（<code>object</code>），被<code>[]</code>包裹的数组（<code>array</code>）</p>
<a id="more"></a>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>从第三方<code>API</code>返回的<code>json</code>数据，存在一个<code>key</code>的值为空数组，可是经过<code>decode</code>和<code>encode</code>这两步操作后，这个<code>key</code>的值就变为空对象了：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span>(<span class="string">'cjson'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> raw = &#123;&#125;</span><br><span class="line">raw.name = <span class="string">'answer'</span></span><br><span class="line">raw.list = &#123;&#125;</span><br><span class="line"><span class="keyword">local</span> str = cjson.encode(raw)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'after cjson encode:'</span>, str)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">after</span> cjson encode:	&#123;<span class="string">"name"</span>:<span class="string">"answer"</span>,<span class="string">"list"</span>:&#123;&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>cjson</code>对于空的<code>table</code>，会默认处理为<code>object</code>，对于<code>Lua</code>本身，是无法区分空数组和空字典的（数组和字典融合到一起了），但是对于强类型语言(<code>C/C++, Java</code>等)，这时候就会出现问题，必须作容错处理</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="使用encode-empty-table-as-object方法"><a href="#使用encode-empty-table-as-object方法" class="headerlink" title="使用encode_empty_table_as_object方法"></a>使用<code>encode_empty_table_as_object</code>方法</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span>(<span class="string">'cjson'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> raw = &#123;&#125;</span><br><span class="line">raw.name = <span class="string">'answer'</span></span><br><span class="line">raw.list = &#123;&#125;</span><br><span class="line">cjson.encode_empty_table_as_object(<span class="literal">false</span>)</span><br><span class="line"><span class="keyword">local</span> str = cjson.encode(raw)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'after cjson encode:'</span>, str)</span><br></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">after cjson encode:	&#123;<span class="string">"name"</span>:<span class="string">"answer"</span>,<span class="string">"list"</span>:<span class="string">[]</span>&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="更换dkjson库"><a href="#更换dkjson库" class="headerlink" title="更换dkjson库"></a>更换<code>dkjson</code>库</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> dkjson = <span class="built_in">require</span>(<span class="string">'dkjson'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> raw = &#123;&#125;</span><br><span class="line">raw.name = <span class="string">'answer'</span></span><br><span class="line">raw.list = &#123;&#125;</span><br><span class="line"><span class="keyword">local</span> str = dkjson.encode(raw)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'after cjson encode:'</span>, str)</span><br></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">after cjson encode:	&#123;<span class="string">"name"</span>:<span class="string">"answer"</span>,<span class="string">"list"</span>:<span class="string">[]</span>&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用metatable将table标记为array"><a href="#使用metatable将table标记为array" class="headerlink" title="使用metatable将table标记为array"></a>使用<code>metatable</code>将<code>table</code>标记为<code>array</code></h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span>(<span class="string">'cjson'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> raw = &#123;&#125;</span><br><span class="line">raw.name = <span class="string">'answer'</span></span><br><span class="line">raw.list = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(raw.list, cjson.empty_array_mt)</span><br><span class="line"><span class="keyword">local</span> str = cjson.encode(raw)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'after cjson encode:'</span>, str)</span><br></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">after cjson encode:	&#123;<span class="string">"name"</span>:<span class="string">"answer"</span>,<span class="string">"list"</span>:<span class="string">[]</span>&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://moonbingbing.gitbooks.io/openresty-best-practices/content/json/array_or_object.html" target="_blank" rel="noopener">编码为 array 还是 object</a></li>
<li><a href="http://blog.csdn.net/ljfrocky/article/details/53034932?_t=t" target="_blank" rel="noopener">使用lua CJSON库如何将空table编码成数组</a></li>
<li><a href="https://github.com/openresty/lua-cjson" target="_blank" rel="noopener">openresty/lua-cjson</a></li>
</ul>
<h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p>
<ul>
<li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li>
<li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li>
<li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li>
<li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li>
<li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li>
</ul>
<p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>
]]></content>
      
        <categories>
            
            <category> Lua </category>
            
        </categories>
        
        
        <tags>
            
            <tag> lua-cjson </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[科普|云计算的四种服务模式介绍]]></title>
      <url>http://answerywj.com/2017/03/23/Introduction-to-four-service-of-cloud-computing/</url>
      <content type="html"><![CDATA[<p>本文将介绍<em>SaaS</em>，<em>BaaS</em>，<em>PaaS</em>和<em>IaaS</em>这四种云计算服务模式，并分析之间的联系和区别。</p>
<a id="more"></a>
<h2 id="四种服务模式介绍"><a href="#四种服务模式介绍" class="headerlink" title="四种服务模式介绍"></a>四种服务模式介绍</h2><ul>
<li>SaaS（Software as a Service）：软件即服务，<em>SaaS</em>公司提供完整并可直接使用的应用程序，用户通过网页浏览器即可接入使用。比较知名的<em>SaaS</em>有<em>GoToMeeting</em>，<em>WebEx</em>和<em>Salesforce</em>。</li>
<li>BaaS（Backend as a Service）：后端即服务，为移动应用开发者提供后端云服务，包括云端数据存储、账户管理和消息推送等，简化了应用开发流程。这里推荐一篇对<em>BaaS</em>介绍的<a href="http://www.jianshu.com/p/4381f0a0692e" target="_blank" rel="noopener">文章</a>。</li>
<li>PaaS（Platform as a Service）：平台即服务，也被叫做中间件。用户通过<em>Internet</em>可以使用<em>PaaS</em>公司在网上提供的各种开发和分发应用的解决方案，比如虚拟服务器和操作系统等，软件的开发和运行都可以在提供的平台上进行。不仅节约了硬件成本，更大大提高了协作开发的效率。比较知名的<em>PaaS</em>有<em>Google App Engine</em>，<em>Microsoft Azure</em>和<em>AppFog</em>。</li>
<li>IaaS（Infrastructure as a Service）：基础设施即服务，用户通过租用<em>IaaS</em>公司的服务器，存储和网络硬件，利用<em>Internet</em>就可以完善地获取计算机基础设施服务，大大节约了硬件成本。比较知名的<em>IaaS</em>有<em>Amazon</em>，<em>Microsoft</em>和<em>Aliyun</em>等。</li>
</ul>
<h2 id="四种服务模式的关系"><a href="#四种服务模式的关系" class="headerlink" title="四种服务模式的关系"></a>四种服务模式的关系</h2><ul>
<li><em>PaaS</em>构建在<em>IaaS</em>之上，在基础架构之外还提供了业务软件的运行环境。</li>
<li><em>SaaS</em>同<em>PaaS</em>的区别在于，使用<em>SaaS</em>的不是软件的开发人员，而是软件的最终用户。</li>
<li><em>BaaS</em>属于<em>PaaS</em>的范畴，但两者也有区别。<em>BaaS</em>简化了应用开发流程，而<em>PaaS</em>简化了应用部署流程。</li>
</ul>
<p><img src="http://o9zpdspb3.bkt.clouddn.com/Introduction-to-four-service-of-cloud-computing.jpg" alt></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="http://www.jianshu.com/p/6148c47792c3" target="_blank" rel="noopener">云计算的三种服务模式</a></li>
<li><a href="http://www.jianshu.com/p/4381f0a0692e" target="_blank" rel="noopener">三分钟了解什么是 BaaS</a></li>
</ul>
<h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p>
<ul>
<li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li>
<li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li>
<li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li>
<li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li>
<li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li>
</ul>
<p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>
]]></content>
      
        <categories>
            
            <category> Knowledge </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Cloud Computing </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[UNIX网络编程-listen函数及其包裹函数介绍]]></title>
      <url>http://answerywj.com/2017/02/23/listen-in-unix/</url>
      <content type="html"><![CDATA[<p>本文将介绍UNIX网络编程中<code>listen</code>函数及其包裹函数。</p>
<hr>
<a id="more"></a>
<h3 id="函数简介"><a href="#函数简介" class="headerlink" title="函数简介"></a>函数简介</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line">                                返回：若成功则为<span class="number">0</span>，若出错则为<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>目前<code>listen</code>函数仅为<code>TCP</code>服务器调用，主要完成两个任务：</p>
<ol>
<li>将<code>socket</code>函数创建的还未建立连接的主动套接字转换为被动(监听)套接字，使内核接受指向该套接字的连接。</li>
<li>使用第二个参数规定了内核为相应套接字排队的最大连接个数。</li>
</ol>
<blockquote>
<p>tips：<code>socket</code>函数创建的套接字被默认为一个主动套接字，即该套接字为将调用<code>connect</code>函数发起连接的客户套接字。而<code>listen</code>函数导致该套接字从<code>CLOSED</code>状态转换为<code>LISTEN</code>状态。</p>
</blockquote>
<h3 id="包裹函数-下载"><a href="#包裹函数-下载" class="headerlink" title="包裹函数(下载)"></a>包裹函数(<a href="https://github.com/AnSwErYWJ/UNP/blob/master/TCP/Listen.c" target="_blank" rel="noopener">下载</a>)</h3><p>历史上总是将<code>backlog</code>设为5，但已无法满足现在服务器的需求了，所以需要指定一个较大的<code>backlog</code>才能满足繁忙的需求。一种方法是使用一个常值，可是每次增长都需要重新编译，比较麻烦；另一种方法是设定默认值，然后允许通过命令行或环境变量覆盖默认值：<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">void Listen(<span class="built_in">int</span> fd,<span class="built_in">int</span> backlog)</span><br><span class="line">&#123;</span><br><span class="line">    char *<span class="built_in">ptr</span><span class="comment">;</span></span><br><span class="line">    <span class="keyword">if</span>((<span class="built_in">ptr</span> = getenv(<span class="string">"LISTENQ"</span>)) != <span class="literal">NULL</span>)</span><br><span class="line">        backlog = atoi(<span class="built_in">ptr</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(listen(fd,backlog) == <span class="number">-1</span>)</span><br><span class="line">        perror(<span class="string">"Listen error"</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样就可以通过设置环境变量<code>LISTENQ</code>来动态配置<code>backlog</code>的大小。</p>
<blockquote>
<p>tips：<code>backlog</code>为0不代表就不会有客户连接到你的机器。如果不想让客户连接，请直接关闭该套接字。</p>
</blockquote>
<h3 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h3><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p>
<ul>
<li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li>
<li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li>
<li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li>
<li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li>
<li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li>
</ul>
<p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>
]]></content>
      
        <categories>
            
            <category> C </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tcp </tag>
            
            <tag> listen </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[WAVE音频文件格式分析--实现C语言读写文件头]]></title>
      <url>http://answerywj.com/2017/01/09/wave/</url>
      <content type="html"><![CDATA[<p>本文将详细分析WAVE音频文件的格式,并通过C语言对wave文件头进行读写操作。</p>
<hr>
<a id="more"></a>
<h2 id="WAVE音频文件格式分析–实现C语言读写文件头"><a href="#WAVE音频文件格式分析–实现C语言读写文件头" class="headerlink" title="WAVE音频文件格式分析–实现C语言读写文件头"></a>WAVE音频文件格式分析–实现C语言读写文件头</h2><h3 id="WAVE音频文件"><a href="#WAVE音频文件" class="headerlink" title="WAVE音频文件"></a>WAVE音频文件</h3><p>WAVE文件格式是一种由微软和IBM联合开发的用于音频数字存储的标准, 它采用<em>RIFF(Resource Interchange File Format,资源交换文件标准)</em>文件格式结构文件的扩展名为<em>“WAV”</em>, 所有的<em>WAV</em>都有一个文件头, 数据本身的格式为<em>PCM</em>或压缩型.  </p>
<h3 id="WAVE文件头"><a href="#WAVE文件头" class="headerlink" title="WAVE文件头"></a>WAVE文件头</h3><p><em>WAVE</em>文件分成两部分:文件头和数据块. <em>WAV</em>格式文件主要有两种文件头: 标准的44字节文件头和经过了一些软件处理的58字节文件头.<br><em>WAVE</em>文件头包含RIFF数据块,一个<em>“fmt”</em>数据块和一个<em>“data”</em>数据块</p>
<blockquote>
<p>本文所介绍的<em>WAV</em>文件头是标准的44字节文件头.</p>
</blockquote>
<h3 id="WAVE文件格式"><a href="#WAVE文件格式" class="headerlink" title="WAVE文件格式"></a>WAVE文件格式</h3><p><img src="http://o9zpdspb3.bkt.clouddn.com/wave.png" alt="wave format"></p>
<blockquote>
<p><strong>纠正</strong>: ByteRate应该为每秒存储的字节数</p>
</blockquote>
<p>通过<em>WAVE</em>文件头信息,我们可以计算出播放时长:<br><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">文件播放时长 </span>=<span class="string"> Subchunk2Size/ByteRate</span></span><br></pre></td></tr></table></figure></p>
<h3 id="C语言实现对WAVE文件头的读写"><a href="#C语言实现对WAVE文件头的读写" class="headerlink" title="C语言实现对WAVE文件头的读写"></a>C语言实现对<strong>WAVE</strong>文件头的读写</h3><p>这里我提供了几个接口供大家使用,<a href="https://github.com/AnSwErYWJ/AudioResamplerate/blob/master/src/waveHeader/handle_wave.c" target="_blank" rel="noopener">handle_wave.c</a> 和 <a href="https://github.com/AnSwErYWJ/AudioResamplerate/blob/master/include/waveHeader/handle_wave.h" target="_blank" rel="noopener">handle_wave.h</a>.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _HANDLE_WAVE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _HANDLE_WAVE_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span>  riff_id[<span class="number">4</span>];                       <span class="comment">//"RIFF"</span></span><br><span class="line">    <span class="keyword">int</span>   riff_datasize;                    <span class="comment">// RIFF chunk data size,exclude riff_id[4] and riff_datasize,total - 8</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>  riff_type[<span class="number">4</span>];                     <span class="comment">// "WAVE"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>  fmt_id[<span class="number">4</span>];                        <span class="comment">// "fmt "</span></span><br><span class="line">    <span class="keyword">int</span>   fmt_datasize;                     <span class="comment">// fmt chunk data size,16 for pcm</span></span><br><span class="line">    <span class="keyword">short</span> fmt_compression_code;             <span class="comment">// 1 for PCM</span></span><br><span class="line">    <span class="keyword">short</span> fmt_channels;                     <span class="comment">// 1(mono) or 2(stereo)</span></span><br><span class="line">    <span class="keyword">int</span>   fmt_sample_rate;                  <span class="comment">// samples per second</span></span><br><span class="line">    <span class="keyword">int</span>   fmt_avg_bytes_per_sec;            <span class="comment">// sample_rate * channels * bit_per_sample / 8</span></span><br><span class="line">    <span class="keyword">short</span> fmt_block_align;                  <span class="comment">// number bytes per sample, bit_per_sample * channels / 8</span></span><br><span class="line">    <span class="keyword">short</span> fmt_bit_per_sample;               <span class="comment">// bits of each sample(8,16,32).</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>  data_id[<span class="number">4</span>];                       <span class="comment">// "data"</span></span><br><span class="line">    <span class="keyword">int</span>   data_datasize;                    <span class="comment">// data chunk size,pcm_size - 44</span></span><br><span class="line">&#125;WaveHeader_t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_wavheader</span><span class="params">(WaveHeader_t *wavheader)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_wavheader</span><span class="params">(FILE *fp,WaveHeader_t *wavheader)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write_wavheader</span><span class="params">(FILE *fp,WaveHeader_t wavheader)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_wavheader</span><span class="params">(WaveHeader_t wavheader)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"handle_wave.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* read and write integer from file stream */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_int</span><span class="params">(FILE *fp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *s;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    s = (<span class="keyword">char</span> *)&amp;i;</span><br><span class="line">    <span class="keyword">size_t</span> len = <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;n &lt; len;n++)</span><br><span class="line">    &#123;</span><br><span class="line">    	s[n]=getc(fp);</span><br><span class="line">    	<span class="comment">//printf("%x\n",s[n]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">put_int</span><span class="params">(<span class="keyword">int</span> i,FILE *fp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *s;</span><br><span class="line">    s=(<span class="keyword">char</span> *)&amp;i;</span><br><span class="line">    <span class="keyword">size_t</span> len = <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;n &lt; len;n++)</span><br><span class="line">    &#123;</span><br><span class="line">    	putc(s[n],fp);</span><br><span class="line">        <span class="comment">//printf("%x\n",s[n]);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="title">get_sint</span><span class="params">(FILE *fp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *s;</span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> i;</span><br><span class="line">    s = (<span class="keyword">char</span> *)&amp;i;</span><br><span class="line">    <span class="keyword">size_t</span> len = <span class="keyword">sizeof</span>(<span class="keyword">short</span>);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;n &lt; len;n++)</span><br><span class="line">    &#123;</span><br><span class="line">    	s[n]=getc(fp);</span><br><span class="line">    	<span class="comment">//printf("%x\n",s[n]);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="title">put_sint</span><span class="params">(<span class="keyword">short</span> <span class="keyword">int</span> i,FILE *fp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *s;</span><br><span class="line">    s=(<span class="keyword">char</span> *)&amp;i;</span><br><span class="line">    <span class="keyword">size_t</span> len = <span class="keyword">sizeof</span>(<span class="keyword">short</span>);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;n &lt; len;n++)</span><br><span class="line">    &#123;</span><br><span class="line">    	putc(s[n],fp);</span><br><span class="line">        <span class="comment">//printf("%x\n",s[n]);</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_wavheader</span><span class="params">(WaveHeader_t *wavheader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">sprintf</span>(wavheader-&gt;riff_id,<span class="string">"RIFF"</span>);</span><br><span class="line">    wavheader-&gt;riff_datasize = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(wavheader-&gt;riff_type,<span class="string">"WAVE"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(wavheader-&gt;fmt_id,<span class="string">"fmt "</span>);</span><br><span class="line">    wavheader-&gt;fmt_datasize = <span class="number">16</span>;</span><br><span class="line">    wavheader-&gt;fmt_compression_code = <span class="number">1</span>;</span><br><span class="line">    wavheader-&gt;fmt_channels = <span class="number">-1</span>;</span><br><span class="line">    wavheader-&gt;fmt_sample_rate = <span class="number">-1</span>;</span><br><span class="line">    wavheader-&gt;fmt_avg_bytes_per_sec = <span class="number">-1</span>;</span><br><span class="line">    wavheader-&gt;fmt_block_align = <span class="number">-1</span>;</span><br><span class="line">    wavheader-&gt;fmt_bit_per_sample = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(wavheader-&gt;data_id,<span class="string">"data"</span>);</span><br><span class="line">    wavheader-&gt;data_datasize = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_wavheader</span><span class="params">(FILE *fp,WaveHeader_t *wavheader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (fp ==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    fread(wavheader-&gt;riff_id,<span class="number">4</span>,<span class="number">1</span>,fp);</span><br><span class="line">    wavheader-&gt;riff_datasize = get_int(fp);</span><br><span class="line">    fread(wavheader-&gt;riff_type,<span class="number">4</span>,<span class="number">1</span>,fp);</span><br><span class="line">    fread(wavheader-&gt;fmt_id,<span class="number">4</span>,<span class="number">1</span>,fp);</span><br><span class="line">    wavheader-&gt;fmt_datasize = get_int(fp);</span><br><span class="line">    wavheader-&gt;fmt_compression_code = get_sint(fp);</span><br><span class="line">    wavheader-&gt;fmt_channels = get_sint(fp);</span><br><span class="line">    wavheader-&gt;fmt_sample_rate = get_int(fp);</span><br><span class="line">    wavheader-&gt;fmt_avg_bytes_per_sec = get_int(fp);</span><br><span class="line">    wavheader-&gt;fmt_block_align = get_sint(fp);</span><br><span class="line">    wavheader-&gt;fmt_bit_per_sample = get_sint(fp);</span><br><span class="line">    fread(wavheader-&gt;data_id,<span class="number">4</span>,<span class="number">1</span>,fp);</span><br><span class="line">    wavheader-&gt;data_datasize = get_int(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write_wavheader</span><span class="params">(FILE *fp,WaveHeader_t wavheader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (fp ==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    fwrite(wavheader.riff_id,<span class="number">4</span>,<span class="number">1</span>,fp);</span><br><span class="line">    put_int(wavheader.riff_datasize,fp);</span><br><span class="line">    fwrite(wavheader.riff_type,<span class="number">4</span>,<span class="number">1</span>,fp);</span><br><span class="line">    fwrite(wavheader.fmt_id,<span class="number">4</span>,<span class="number">1</span>,fp);</span><br><span class="line">    put_int(wavheader.fmt_datasize,fp);</span><br><span class="line">    put_sint(wavheader.fmt_compression_code,fp);</span><br><span class="line">    put_sint(wavheader.fmt_channels,fp);</span><br><span class="line">    put_int(wavheader.fmt_sample_rate,fp);</span><br><span class="line">    put_int(wavheader.fmt_avg_bytes_per_sec,fp);</span><br><span class="line">    put_sint(wavheader.fmt_block_align,fp);</span><br><span class="line">    put_sint(wavheader.fmt_bit_per_sample,fp);</span><br><span class="line">    fwrite(wavheader.data_id,<span class="number">4</span>,<span class="number">1</span>,fp);</span><br><span class="line">    put_int(wavheader.data_datasize,fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_wavheader</span><span class="params">(WaveHeader_t wavheader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"wavheader.riff_id: %c%c%c%c\n"</span>,wavheader.riff_id[<span class="number">0</span>],wavheader.riff_id[<span class="number">1</span>],wavheader.riff_id[<span class="number">2</span>],wavheader.riff_id[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"wavheader.riff_datasize: %d\n"</span>,wavheader.riff_datasize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"wavheader.riff_type: %c%c%c%c\n"</span>,wavheader.riff_type[<span class="number">0</span>],wavheader.riff_type[<span class="number">1</span>],wavheader.riff_type[<span class="number">2</span>],wavheader.riff_type[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"wavheader.fmt_id: %c%c%c%c\n"</span>,wavheader.fmt_id[<span class="number">0</span>],wavheader.fmt_id[<span class="number">1</span>],wavheader.fmt_id[<span class="number">2</span>],wavheader.fmt_id[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"wavheader.fmt_datasize: %d\n"</span>,wavheader.fmt_datasize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"wavheader.fmt_compression_code: %hd\n"</span>,wavheader.fmt_compression_code);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"wavheader.fmt_channels: %hd\n"</span>,wavheader.fmt_channels);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"wavheader.fmt_sample_rate: %d\n"</span>,wavheader.fmt_sample_rate);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"wavheader.fmt_avg_bytes_per_sec: %d\n"</span>,wavheader.fmt_avg_bytes_per_sec);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"wavheader.fmt_block_align: %hd\n"</span>,wavheader.fmt_block_align);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"wavheader.fmt_bit_per_sample: %hd\n"</span>,wavheader.fmt_bit_per_sample);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"wavheader.data_id: %c%c%c%c\n"</span>,wavheader.data_id[<span class="number">0</span>],wavheader.data_id[<span class="number">1</span>],wavheader.data_id[<span class="number">2</span>],wavheader.data_id[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"wavheader.data_datasize: %d\n"</span>,wavheader.data_datasize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p>
<ul>
<li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li>
<li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li>
<li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li>
<li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li>
<li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li>
</ul>
<p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>
]]></content>
      
        <categories>
            
            <category> C </category>
            
        </categories>
        
        
        <tags>
            
            <tag> wave文件头 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C程序判断你主机的数据存储方式(大端和小端)]]></title>
      <url>http://answerywj.com/2016/12/07/big-endian-and-little-endian/</url>
      <content type="html"><![CDATA[<p>本文将使用C语言编写一个可以判断你主机数据存储方式(大端和小端)的程序.</p>
<hr>
<a id="more"></a>
<h2 id="C程序判断你主机的数据存储方式-大端和小端"><a href="#C程序判断你主机的数据存储方式-大端和小端" class="headerlink" title="C程序判断你主机的数据存储方式(大端和小端)"></a>C程序判断你主机的数据存储方式(大端和小端)</h2><h3 id="大端和小端字节序"><a href="#大端和小端字节序" class="headerlink" title="大端和小端字节序"></a>大端和小端字节序</h3><p>计算机硬件存储数据的方式有两种: 大端字节序(big endian) 和 小端字节序(little endian),两者的区别可以简单理解为:</p>
<ul>
<li>大端: 数据高位字节放在内存低地址(人类读写的习惯).</li>
<li>小端: 数据高位字节放在内存高地址.</li>
</ul>
<p>如现在有数 0x1234,则两者存储方式如下:<br><img src="http://o9zpdspb3.bkt.clouddn.com/%E5%A4%A7%E5%B0%8F%E7%AB%AF.png" alt="大小端"></p>
<blockquote>
<p> 既然大端字节序符合人类读写的习惯,那么为什么会有小端字节序呢？<br>因为大多数默认情况下计算机的电路先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，计算机的内部处理都是小端字节序。但是，人类还是习惯读写大端字节序。所以，除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存。</p>
</blockquote>
<p>当然并不是所有的计算机处理器都是小端模式的,目前IBM和Freescale的一些处理器以及一些常见的单片机芯片等都是采用大端字节序存储数据.而市面上大部分CPU则是采用小端字节序,如intel等.</p>
<h3 id="实现-完整代码"><a href="#实现-完整代码" class="headerlink" title="实现(完整代码)"></a>实现(<a href="https://github.com/AnSwErYWJ/DogFood/blob/master/C/host_byte_order.c" target="_blank" rel="noopener">完整代码</a>)</h3><p>本例都认为short占2个字节,不考虑可移植的情况.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> _byteorder</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">short</span> s;</span><br><span class="line">    <span class="keyword">char</span> c[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> _byteorder un;</span><br><span class="line"></span><br><span class="line">    un.s = <span class="number">0x0102</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">sizeof</span>(<span class="keyword">short</span>) == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(un.c[<span class="number">0</span>] == <span class="number">2</span> &amp;&amp; un.c[<span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"little-endian\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(un.c[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; un.c[<span class="number">1</span>] == <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"big-endian\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Error:can not judge host byte order.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"sizeof(short) = %ld\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">short</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里利用了<code>union</code> 中所有的数据成员共用一个空间，同一时间只能储存其中一个数据成员的特性.<br>首先分配了一个占2个字节的内存空间(<code>union</code>分配的空间需要容纳最大长度的数据成员),将<code>0x0102</code>赋予<code>short</code>型变量.<br>然后利用<code>char</code>数组,按一个字节的长度依次取出数据,然后利用上节介绍的大小端存储方式的不同进行判断.</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="http://www.ruanyifeng.com/blog/2016/11/byte-order.html" target="_blank" rel="noopener">理解字节序</a></li>
</ul>
<h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p>
<ul>
<li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li>
<li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li>
<li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li>
<li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li>
<li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li>
</ul>
<p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>
]]></content>
      
        <categories>
            
            <category> C </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 大小端字节序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[从文件流中读写整数--C语言]]></title>
      <url>http://answerywj.com/2016/12/06/getw-and-putw/</url>
      <content type="html"><![CDATA[<p>本文将介绍在文本流中,读写整数的两个接口– <code>int getw(FILE *fp)</code>和<code>int putw(int w, FILE *fp)</code>,并且与你分享改进后的更实用的接口– <code>unsigned int get_uint(FILE *fp)</code>和<code>unsigned int put_uint(unsigned int i,FILE *fp)</code>.</p>
<hr>
<a id="more"></a>
<h2 id="从文件流中读写整数–C语言"><a href="#从文件流中读写整数–C语言" class="headerlink" title="从文件流中读写整数–C语言"></a>从文件流中读写整数–C语言</h2><p>我们都知道,数据在计算机内存中都是以二进制的形式存储的,大多数PC的存储方式为小端存储,关于大小端字节序的讨论请参考<a href="http://www.ruanyifeng.com/blog/2016/11/byte-order.html" target="_blank" rel="noopener">阮一峰的理解字节序</a>. 如果想直接读写整数,并不是很方便,这里就为你介绍两个接口,需要注意的是这两个接口非ANSI标准函数.</p>
<h3 id="getw"><a href="#getw" class="headerlink" title="getw"></a>getw</h3><p>函数原型：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getw</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>函数功能：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从<span class="built_in">fp</span>所指向文件读取下一个整数.</span><br></pre></td></tr></table></figure></p>
<p>返回值：<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回输入的整数,如果文件结束或者出错返回-<span class="number">1</span>.</span><br></pre></td></tr></table></figure></p>
<h3 id="putw"><a href="#putw" class="headerlink" title="putw"></a>putw</h3><p>函数原型：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putw</span><span class="params">(<span class="keyword">int</span> w, FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>函数功能：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将整型w写进<span class="built_in">fp</span>指向的文件.</span><br></pre></td></tr></table></figure></p>
<p>返回值：<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回输出的整数,如果出错,则返回EOF.</span><br></pre></td></tr></table></figure></p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>代码:<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"></span><br><span class="line">int main(int argc,char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	FILE *<span class="built_in">fp</span> = NULL<span class="comment">;</span></span><br><span class="line">    int num[<span class="number">2</span>] = &#123;-<span class="number">2147483648</span>,<span class="number">2147483647</span>&#125;<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">fp</span> = fopen(<span class="string">"./log"</span>, <span class="string">"wb"</span>)<span class="comment">;</span></span><br><span class="line">    if (<span class="built_in">fp</span> == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,<span class="string">"open file failed"</span>)<span class="comment">;</span></span><br><span class="line">        exit(EXIT_FAILURE)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    putw(num[<span class="number">0</span>],<span class="built_in">fp</span>)<span class="comment">;</span></span><br><span class="line">    putw(num[<span class="number">1</span>],<span class="built_in">fp</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    fclose(<span class="built_in">fp</span>)<span class="comment">;</span></span><br><span class="line">    <span class="built_in">fp</span> = NULL<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">fp</span> = fopen(<span class="string">"./log"</span>, <span class="string">"rb"</span>)<span class="comment">;</span></span><br><span class="line">    if (<span class="built_in">fp</span> == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,<span class="string">"open file failed"</span>)<span class="comment">;</span></span><br><span class="line">        exit(EXIT_FAILURE)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(<span class="string">"%d %d\n"</span>,getw(<span class="built_in">fp</span>),getw(<span class="built_in">fp</span>))<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    fclose(<span class="built_in">fp</span>)<span class="comment">;</span></span><br><span class="line">	<span class="built_in">fp</span> = NULL<span class="comment">;</span></span><br><span class="line">	</span><br><span class="line">    return <span class="number">0</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果为:<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="number">2147483647</span> -<span class="number">2147483648</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意: 函数参数的压栈顺序是从左到右的,所以最后一个参数<code>getw(fp)</code>在栈顶,第一个出栈执行.</p>
</blockquote>
<h3 id="实现与改进-完整代码"><a href="#实现与改进-完整代码" class="headerlink" title="实现与改进(完整代码)"></a>实现与改进(<a href="https://github.com/AnSwErYWJ/DogFood/blob/master/C/file/io2stream.c" target="_blank" rel="noopener">完整代码</a>)</h3><p>由于上述两个接口支持的是int型,所以取值范围为<code>-2147483648～2147483647</code>.(此文认为int型都为4个字节).笔者需要使用这两个接口去读写文件的大小,负数无用处的,所以决定改装一下这两个函数,顺便探究一下这个函数的实现:<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">unsigned int get_uint(FILE *<span class="built_in">fp</span>)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char *s<span class="comment">;</span></span><br><span class="line">    unsigned int i<span class="comment">;</span></span><br><span class="line">    s = (unsigned char *)&amp;i<span class="comment">;</span></span><br><span class="line">    s[<span class="number">0</span>]=getc(<span class="built_in">fp</span>)<span class="comment">;</span></span><br><span class="line">    printf(<span class="string">"%x\n"</span>,s[<span class="number">0</span>])<span class="comment">;</span></span><br><span class="line">    s[<span class="number">1</span>]=getc(<span class="built_in">fp</span>)<span class="comment">;</span></span><br><span class="line">    printf(<span class="string">"%x\n"</span>,s[<span class="number">1</span>])<span class="comment">;</span></span><br><span class="line">    s[<span class="number">2</span>]=getc(<span class="built_in">fp</span>)<span class="comment">;</span></span><br><span class="line">    printf(<span class="string">"%x\n"</span>,s[<span class="number">2</span>])<span class="comment">;</span></span><br><span class="line">    s[<span class="number">3</span>]=getc(<span class="built_in">fp</span>)<span class="comment">;</span></span><br><span class="line">    printf(<span class="string">"%x\n"</span>,s[<span class="number">3</span>])<span class="comment">;</span></span><br><span class="line">    return i<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">put_uint</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> i,FILE *fp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *s;</span><br><span class="line">    s=(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)&amp;i;</span><br><span class="line">    putc(s[<span class="number">0</span>],fp);</span><br><span class="line">    <span class="comment">//printf("%x\n",s[0]);</span></span><br><span class="line">    putc(s[<span class="number">1</span>],fp);</span><br><span class="line">    <span class="comment">//printf("%x\n",s[1]);</span></span><br><span class="line">    putc(s[<span class="number">2</span>],fp);</span><br><span class="line">    <span class="comment">//printf("%x\n",s[2]);</span></span><br><span class="line">    putc(s[<span class="number">3</span>],fp);</span><br><span class="line">    <span class="comment">//printf("%x\n",s[3]);</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>改进后取值范围为<code>0~4294967295</code>.</p>
</blockquote>
<p>同理,你也可以将这两个接口改为支持 <code>long long</code>和<code>unsigned long int</code>等不同长度的整数类型.</p>
<h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p>
<ul>
<li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li>
<li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li>
<li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li>
<li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li>
<li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li>
</ul>
<p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>
]]></content>
      
        <categories>
            
            <category> C </category>
            
        </categories>
        
        
        <tags>
            
            <tag> getw </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux下处理json数据]]></title>
      <url>http://answerywj.com/2016/10/10/jq/</url>
      <content type="html"><![CDATA[<p>当我们在Linux下需要处理json数据时,第一反应是用脚本编写一个工具,这样即耗时又不通用. 本文将介绍专门的命令行json处理工具<strong>jq</strong>.<br><a id="more"></a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Ubuntu用户可以直接使用下列命令安装:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-<span class="builtin-name">get</span> install jq</span><br></pre></td></tr></table></figure></p>
<p>也可以选择<a href="https://github.com/stedolan/jq" target="_blank" rel="noopener">源码</a>安装,当然最简单的方法是直接下载<a href="https://stedolan.github.io/jq/" target="_blank" rel="noopener">可执行文件</a>,不过需要找到适配你系统的版本.</p>
<p>详细的安装方法可以参考<a href="https://stedolan.github.io/jq/download/" target="_blank" rel="noopener">这里</a>.</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>首先构建一个基本的字符串作为示例 test.json:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"中国"</span>,</span><br><span class="line">    <span class="attr">"province"</span>: [&#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"黑龙江"</span>,</span><br><span class="line">        <span class="attr">"cities"</span>: &#123;</span><br><span class="line">            <span class="attr">"city"</span>: [<span class="string">"哈尔滨"</span>, <span class="string">"大庆"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"广东"</span>,</span><br><span class="line">        <span class="attr">"cities"</span>: &#123;</span><br><span class="line">            <span class="attr">"city"</span>: [<span class="string">"广州"</span>, <span class="string">"深圳"</span>, <span class="string">"珠海"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"台湾"</span>,</span><br><span class="line">        <span class="attr">"cities"</span>: &#123;</span><br><span class="line">            <span class="attr">"city"</span>: [<span class="string">"台北"</span>, <span class="string">"高雄"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"新疆"</span>,</span><br><span class="line">        <span class="attr">"cities"</span>: &#123;</span><br><span class="line">            <span class="attr">"city"</span>: [<span class="string">"乌鲁木齐"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="解析json对象"><a href="#解析json对象" class="headerlink" title="解析json对象"></a>解析json对象</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>cat test.json | jq <span class="string">'.name'</span></span><br><span class="line"><span class="string">"中国"</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$ </span>cat test.json | jq <span class="string">'.province[0].name'</span></span><br><span class="line"><span class="string">"黑龙江"</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$ </span>cat test.json | jq <span class="string">'.province[].name'</span></span><br><span class="line"><span class="string">"黑龙江"</span></span><br><span class="line"><span class="string">"广东"</span></span><br><span class="line"><span class="string">"台湾"</span></span><br><span class="line"><span class="string">"新疆"</span></span><br></pre></td></tr></table></figure>
<h3 id="提取字段"><a href="#提取字段" class="headerlink" title="提取字段"></a>提取字段</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">$ cat test.json | jq <span class="string">'.province[0]'</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"cities"</span>: &#123;</span><br><span class="line">    <span class="string">"city"</span>: [</span><br><span class="line">      <span class="string">"哈尔滨"</span>,</span><br><span class="line">      <span class="string">"大庆"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"黑龙江"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ cat test.json | jq <span class="string">'.province[]'</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"cities"</span>: &#123;</span><br><span class="line">    <span class="string">"city"</span>: [</span><br><span class="line">      <span class="string">"哈尔滨"</span>,</span><br><span class="line">      <span class="string">"大庆"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"黑龙江"</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"cities"</span>: &#123;</span><br><span class="line">    <span class="string">"city"</span>: [</span><br><span class="line">      <span class="string">"广州"</span>,</span><br><span class="line">      <span class="string">"深圳"</span>,</span><br><span class="line">      <span class="string">"珠海"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"广东"</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"cities"</span>: &#123;</span><br><span class="line">    <span class="string">"city"</span>: [</span><br><span class="line">      <span class="string">"台北"</span>,</span><br><span class="line">      <span class="string">"高雄"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"台湾"</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"cities"</span>: &#123;</span><br><span class="line">    <span class="string">"city"</span>: [</span><br><span class="line">      <span class="string">"乌鲁木齐"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"新疆"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ cat test.json | jq <span class="string">'.province[0] | &#123;name ,cities&#125;'</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"cities"</span>: &#123;</span><br><span class="line">    <span class="string">"city"</span>: [</span><br><span class="line">      <span class="string">"哈尔滨"</span>,</span><br><span class="line">      <span class="string">"大庆"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"黑龙江"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ cat test.json | jq <span class="string">'.province[0] | &#123;name&#125;'</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"黑龙江"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h2><p>keys用来提取json中的key元素:<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">$ cat test.json | jq <span class="string">'keys'</span></span><br><span class="line">[<span class="meta"></span></span><br><span class="line"><span class="meta">  <span class="meta-string">"name"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"province"</span></span></span><br><span class="line"><span class="meta"></span>]</span><br><span class="line"></span><br><span class="line">$ cat test.json | jq <span class="string">'.|keys'</span></span><br><span class="line">[<span class="meta"></span></span><br><span class="line"><span class="meta">  <span class="meta-string">"name"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"province"</span></span></span><br><span class="line"><span class="meta"></span>]</span><br><span class="line"></span><br><span class="line">$ cat test.json | jq <span class="string">'.province[0]|keys'</span></span><br><span class="line">[<span class="meta"></span></span><br><span class="line"><span class="meta">  <span class="meta-string">"cities"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"name"</span></span></span><br><span class="line"><span class="meta"></span>]</span><br><span class="line"></span><br><span class="line">$ cat test.json | jq <span class="string">'.province[]|keys'</span></span><br><span class="line">[<span class="meta"></span></span><br><span class="line"><span class="meta">  <span class="meta-string">"cities"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"name"</span></span></span><br><span class="line"><span class="meta"></span>]</span><br><span class="line">[<span class="meta"></span></span><br><span class="line"><span class="meta">  <span class="meta-string">"cities"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"name"</span></span></span><br><span class="line"><span class="meta"></span>]</span><br><span class="line">[<span class="meta"></span></span><br><span class="line"><span class="meta">  <span class="meta-string">"cities"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"name"</span></span></span><br><span class="line"><span class="meta"></span>]</span><br><span class="line">[<span class="meta"></span></span><br><span class="line"><span class="meta">  <span class="meta-string">"cities"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"name"</span></span></span><br><span class="line"><span class="meta"></span>]</span><br></pre></td></tr></table></figure></p>
<p>has用来判断是否存在某个key:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat <span class="keyword">test</span>.json | jq 'has(<span class="string">"name"</span>)'</span><br><span class="line"><span class="keyword">true</span></span><br><span class="line">$ cat <span class="keyword">test</span>.json | jq '.province[<span class="number">0</span>] | has(<span class="string">"name"</span>)'</span><br><span class="line"><span class="keyword">true</span></span><br><span class="line">$ cat <span class="keyword">test</span>.json | jq 'has(<span class="string">"noname"</span>)'</span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure></p>
<h3 id="验证json"><a href="#验证json" class="headerlink" title="验证json"></a>验证json</h3><p>若json串格式错误的话,可以直接使用jq运行,会报出具体错误.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有了这个工具.你就可以直接在命令行或者shell脚本对json数据进行操作了.</p>
<h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p>
<ul>
<li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li>
<li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li>
<li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li>
<li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li>
<li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li>
</ul>
<p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> json </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux下C调用静态库和动态库]]></title>
      <url>http://answerywj.com/2016/10/10/use-dynamic-and-static-library/</url>
      <content type="html"><![CDATA[<p>本文主要介绍Linux下C调用静态库和动态库,使用的样例文件请点击<a href="https://github.com/AnSwErYWJ/DogFood/tree/master/C/aso" target="_blank" rel="noopener">这里</a>.<br><a id="more"></a></p>
<h2 id="样例文件"><a href="#样例文件" class="headerlink" title="样例文件"></a>样例文件</h2><p>welcome.c:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"welcome.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">welcome</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"welcome to my code world!\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>这是一个样例程序,打印一句话.</p>
</blockquote>
<p>welcome.h:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _WELCOME_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _WELCOME_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">welcome</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>为上一个文件的声明.</p>
</blockquote>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>动态库和静态库二者的不同点在于代码被载入的时刻不同。</p>
<p>静态库的代码在编译过程中已经被载入可执行程序,因此体积比较大。动态库(共享库)的代码在可执行程序运行时才载入内存，在编译过程中仅简单的引用，因此代码体积比较小。</p>
<p>静态情况下,把库直接加载到程序中,而动态库链接的时候,它只是保留接口,将动态库与程序代码独立,这样就可以提高代码的可复用度，和降低程序的耦合度。</p>
<p>静态库在程序编译时会被连接到目标代码中，程序运行时将不再需要该静态库。动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入，因此在程序运行时还需要动态库存在.</p>
<h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><p>生成静态库文件:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -Wall -O2 -fPIC -I./  -c -o welcome<span class="selector-class">.o</span> welcome.c</span><br><span class="line">$ ar crv libwelcome<span class="selector-class">.a</span> welcome.o</span><br></pre></td></tr></table></figure></p>
<p>ar命令的参数如下:<br><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">参数        意义</span><br><span class="line"><span class="deletion">-r      将objfile文件插入静态库尾或者替换静态库中同名文件</span></span><br><span class="line"><span class="deletion">-x      从静态库文件中抽取文件objfile</span></span><br><span class="line"><span class="deletion">-t      打印静态库的成员文件列表</span></span><br><span class="line"><span class="deletion">-d      从静态库中删除文件objfile</span></span><br><span class="line"><span class="deletion">-s      重置静态库文件索引</span></span><br><span class="line"><span class="deletion">-v      创建文件冗余信息</span></span><br><span class="line"><span class="deletion">-c      创建静态库文件</span></span><br></pre></td></tr></table></figure></p>
<p>test-sta.c:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    welcome();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc <span class="built_in">test</span>-sta.c -o <span class="built_in">test</span>-sta ./libwelcome.a</span></span><br></pre></td></tr></table></figure></p>
<p>运行:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./<span class="built_in">test</span>-sta </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> welcome to my code world!</span></span><br></pre></td></tr></table></figure></p>
<h2 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h2><p>生成动态库文件:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o2 -fPIC -shared welcome<span class="selector-class">.c</span> -o libwelcome.so</span><br><span class="line">or</span><br><span class="line">$ gcc -o2 -fPIC -c welcome<span class="selector-class">.c</span> </span><br><span class="line">$ gcc -shared -o libwelcome<span class="selector-class">.so</span> welcome.o</span><br></pre></td></tr></table></figure></p>
<p>其中:</p>
<ul>
<li>fPIC : 产生与位置无关代码,全部使用相对地址.</li>
<li>shared : 生成动态库.</li>
</ul>
<h3 id="编译时加载-隐式"><a href="#编译时加载-隐式" class="headerlink" title="编译时加载(隐式)"></a>编译时加载(隐式)</h3><p>test-implicit.c:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    welcome();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>和静态库一样,测试代码不需要包含导出函数的头文件.</p>
</blockquote>
<p>编译:<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o2 -Wall -L. -lwelcome test-<span class="keyword">implicit</span>.c -o test-<span class="keyword">implicit</span></span><br></pre></td></tr></table></figure></p>
<p>查看<code>test-implicit</code>动态段信息,发现已经依赖<code>libwelcome.so</code>:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ldd test-implicit </span><br><span class="line">	linux-vdso<span class="selector-class">.so</span>.<span class="number">1</span> =&gt;  (<span class="number">0</span>x00007f0902951000)</span><br><span class="line">	libwelcome<span class="selector-class">.so</span> =&gt; ./libwelcome<span class="selector-class">.so</span> (<span class="number">0</span>x00007f090274f000)</span><br><span class="line">	libstdc++<span class="selector-class">.so</span>.<span class="number">6</span> =&gt; /usr/lib64/libstdc++<span class="selector-class">.so</span>.<span class="number">6</span> (<span class="number">0</span>x0000003548600000)</span><br><span class="line">	libm<span class="selector-class">.so</span>.<span class="number">6</span> =&gt; /lib64/libm<span class="selector-class">.so</span>.<span class="number">6</span> (<span class="number">0</span>x000000353de00000)</span><br><span class="line">	libgcc_s<span class="selector-class">.so</span>.<span class="number">1</span> =&gt; /lib64/libgcc_s<span class="selector-class">.so</span>.<span class="number">1</span> (<span class="number">0</span>x0000003548200000)</span><br><span class="line">	libc<span class="selector-class">.so</span>.<span class="number">6</span> =&gt; /lib64/libc<span class="selector-class">.so</span>.<span class="number">6</span> (<span class="number">0</span>x000000353da00000)</span><br><span class="line">	/lib64/ld-linux-x86-<span class="number">64</span><span class="selector-class">.so</span>.<span class="number">2</span> (<span class="number">0</span>x000000353d600000)</span><br></pre></td></tr></table></figure></p>
<p>若此时直接运行,会提示找不到动态库:<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./test-<span class="keyword">implicit</span></span><br><span class="line">$ ./test-<span class="keyword">implicit</span>: error <span class="keyword">while</span> loading shared libraries: libwelcome.so: cannot open shared object <span class="keyword">file</span>: No such <span class="keyword">file</span> or directory</span><br></pre></td></tr></table></figure></p>
<p>可以通过下列三种方法解决:<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一 修改环境变量</span></span><br><span class="line">$ export LD_LIBRARY_PATH=$(pwd):$LD_LIBRARY_PATH</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二 将库文件链接到系统目录下</span></span><br><span class="line">$ ln -s ./libwelcome.so /usr/<span class="class"><span class="keyword">lib</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法三 修改/etc/ld.so.conf</span></span><br><span class="line">$ sudo echo $(pwd) &gt;&gt; <span class="regexp">/etc/ld</span>.so.conf</span><br><span class="line">$ sudo ldconfig</span><br></pre></td></tr></table></figure></p>
<p>再次运行:<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./test-<span class="keyword">implicit</span></span><br><span class="line">$ welcome to my code world<span class="comment">!</span></span><br></pre></td></tr></table></figure></p>
<h3 id="运行时链接-显式"><a href="#运行时链接-显式" class="headerlink" title="运行时链接(显式)"></a>运行时链接(显式)</h3><p>test-explicit.c:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIB <span class="meta-string">"./libwelcome.so"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * RTLD_NOW：将共享库中的所有函数加载到内存 </span></span><br><span class="line"><span class="comment">     * RTLD_LAZY：会推后共享库中的函数的加载操作，直到调用dlsym()时方加载某函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *dl = dlopen(LIB,RTLD_LAZY); <span class="comment">//打开动态库</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dl == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Error:failed to load libary.\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *error = dlerror(); <span class="comment">//检测错误</span></span><br><span class="line">    <span class="keyword">if</span> (error != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"%s\n"</span>,error);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*func)() = dlsym(dl,<span class="string">"welcome"</span>); <span class="comment">// 获取函数地址</span></span><br><span class="line">    error = dlerror(); <span class="comment">//检测错误</span></span><br><span class="line">    <span class="keyword">if</span> (error != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"%s\n"</span>,error);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func(); <span class="comment">//调用动态库中的函数</span></span><br><span class="line"></span><br><span class="line">    dlclose(dl); <span class="comment">//关闭动态库</span></span><br><span class="line">    error = dlerror(); <span class="comment">//检测错误</span></span><br><span class="line">    <span class="keyword">if</span> (error != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"%s\n"</span>,error);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc  -ldl <span class="built_in">test</span>-explicit.c -o <span class="built_in">test</span>-explicit</span></span><br></pre></td></tr></table></figure></p>
<p>查看<code>test-explicit</code>动态段信息,没有发现依赖<code>libwelcome.so</code>:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ldd test-explicit</span><br><span class="line">	linux-vdso<span class="selector-class">.so</span>.<span class="number">1</span> =&gt;  (<span class="number">0</span>x00007ffed89e5000)</span><br><span class="line">	libdl<span class="selector-class">.so</span>.<span class="number">2</span> =&gt; /lib64/libdl<span class="selector-class">.so</span>.<span class="number">2</span> (<span class="number">0</span>x000000353e600000)</span><br><span class="line">	libstdc++<span class="selector-class">.so</span>.<span class="number">6</span> =&gt; /usr/lib64/libstdc++<span class="selector-class">.so</span>.<span class="number">6</span> (<span class="number">0</span>x0000003548600000)</span><br><span class="line">	libm<span class="selector-class">.so</span>.<span class="number">6</span> =&gt; /lib64/libm<span class="selector-class">.so</span>.<span class="number">6</span> (<span class="number">0</span>x000000353de00000)</span><br><span class="line">	libgcc_s<span class="selector-class">.so</span>.<span class="number">1</span> =&gt; /lib64/libgcc_s<span class="selector-class">.so</span>.<span class="number">1</span> (<span class="number">0</span>x0000003548200000)</span><br><span class="line">	libc<span class="selector-class">.so</span>.<span class="number">6</span> =&gt; /lib64/libc<span class="selector-class">.so</span>.<span class="number">6</span> (<span class="number">0</span>x000000353da00000)</span><br><span class="line">	/lib64/ld-linux-x86-<span class="number">64</span><span class="selector-class">.so</span>.<span class="number">2</span> (<span class="number">0</span>x000000353d600000)</span><br></pre></td></tr></table></figure></p>
<p>运行:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./<span class="built_in">test</span>-explicit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> welcome to my code world!</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p> 区别: 隐式调用在编译可执行程序时需要指定库文件的搜索路径，而显式调用编译可执行程序时不用加上.</p>
</blockquote>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="http://blog.csdn.net/star_xiong/article/details/17301191" target="_blank" rel="noopener">Linux下静态、动态库（隐式、显式调用）的创建和使用及区别</a></li>
<li><a href="http://hbprotoss.github.io/posts/linuxxia-bian-yi-lian-jie-dong-tai-ku.html" target="_blank" rel="noopener">Linux下编译链接动态库</a></li>
<li><a href="http://blog.csdn.net/felixit0120/article/details/7652907" target="_blank" rel="noopener">Linux下动态库(.so)和静态库(.a)</a></li>
</ul>
<h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p>
<ul>
<li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li>
<li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li>
<li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li>
<li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li>
<li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li>
</ul>
<p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>
]]></content>
      
        <categories>
            
            <category> C </category>
            
        </categories>
        
        
        <tags>
            
            <tag> lib </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[科普|3.5mm耳机国标和美标]]></title>
      <url>http://answerywj.com/2016/09/20/standard-of-headphone/</url>
      <content type="html"><![CDATA[<p>现在3.5mm规格的耳机已经普遍使用，但是用户会发现一些国外厂家的耳机并不适用国产手机，下面就为大家科普一下，解开这个迷题。</p>
<a id="more"></a>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li><p>美标也称为国际标准(CTIA)，从头开始分别是左声道/右声道/地线/MIC。目前在市场上最流行</p>
</li>
<li><p>国标(OMTP)，从头开始分别是左声道/右声道/MIC/地线。</p>
</li>
</ul>
<p><img src="http://o9zpdspb3.bkt.clouddn.com/headset.png" alt="headset"></p>
<p>从上图可以发现美标和国标的差别就在于MIC和地线的位置不同，导致会出现在听音乐时只有伴奏没有人声，只有按住接听键才正常的现象。</p>
<p>另外一个区别是，美标的中间三节隔离绝缘圈，一般是都是白色的。而国标为了有所分别，一般是都是黑色的，大部分耳机可以通过此方法来区别。</p>
<h2 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h2><ul>
<li><p>美标耳机适用手机范围：苹果（全系列）、小米（全系列）、魅族（全系列）、索尼（全系列）、LG（全系列）、HTC官方产品、三星（咨询客服）、摩托罗拉部分机型（ME865）、联想W101、诺基亚Lumia和WP7系列、华为(C8812/U9200)、亿通T900等。</p>
</li>
<li><p>国标耳机适用手机范围：诺基亚、索尼爱立信（全系列）、中兴（全系列）、步步高（全系列）、酷派（全系列）、HTC 非官方产品（A3380、A3360、T9188、A9188、Z510D）、三星旧产品（i8910、M3510C、M7500、F278、F700、F408、F490、G810、G818、G818E、i550W、8510、i560、S8000C、i8000、M2710C、i7500U、i9000、i6500U、F809、i8000、F859）、摩托罗拉XT531、联想A520/A750/P700、OPPO（全系列）等国产系列手机。</p>
</li>
</ul>
<blockquote>
<p>若发现国标/美标不适配自己的手机，某宝上面有转接线可以买，可以通过转换国标/美标。</p>
</blockquote>
<h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p>
<ul>
<li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li>
<li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li>
<li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li>
<li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li>
<li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li>
</ul>
<p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>
]]></content>
      
        <categories>
            
            <category> Knowledge </category>
            
        </categories>
        
        
        <tags>
            
            <tag> headset </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Shell脚本浮点运算]]></title>
      <url>http://answerywj.com/2016/09/05/floating-point-operation-in-script/</url>
      <content type="html"><![CDATA[<p>本文将介绍几种Linux下通过Shell脚本进行浮点数计算的方法。</p>
<hr>
<a id="more"></a>
<h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p>Bash Shell本身不具备处理浮点计算的能力, 如<code>expr</code>命令只支持整数运算 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">a=59</span><br><span class="line">b=60</span><br><span class="line">expr <span class="variable">$a</span> / <span class="variable">$b</span></span><br></pre></td></tr></table></figure></p>
<p>运行结果 :<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./cal.sh</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Plan-A"><a href="#Plan-A" class="headerlink" title="Plan A"></a>Plan A</h2><p>使用<code>bc</code>进行处理。<br>代码 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">a=59</span><br><span class="line">b=60</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"scale=4; <span class="variable">$a</span> / <span class="variable">$b</span>"</span> | bc</span><br></pre></td></tr></table></figure></p>
<p>运行结果 :<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="string">./bc.sh</span></span><br><span class="line"><span class="string">.9833</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>scale</code>表示结果的小数精度。</p>
</blockquote>
<h2 id="Plan-B"><a href="#Plan-B" class="headerlink" title="Plan B"></a>Plan B</h2><p>使用<code>awk</code>进行处理。<br>代码 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">a=59</span><br><span class="line">b=60</span><br><span class="line">awk <span class="string">'BEGIN&#123;printf "%.2f\n",('</span><span class="variable">$a</span><span class="string">'/'</span><span class="variable">$b</span><span class="string">')&#125;'</span></span><br></pre></td></tr></table></figure></p>
<p>运行结果 :<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./awk.sh</span><br><span class="line"><span class="number">0.98</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Compare"><a href="#Compare" class="headerlink" title="Compare"></a>Compare</h2><p>使用bc :<br><img src="http://o9zpdspb3.bkt.clouddn.com/bc.png" alt="bc"></p>
<p>使用awk :<br><img src="http://o9zpdspb3.bkt.clouddn.com/awk.png" alt="awk"></p>
<blockquote>
<p>可以看出使用<code>awk</code>的效率更高,特别是运算次数比较大时。</p>
</blockquote>
<h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p>
<ul>
<li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li>
<li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li>
<li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li>
<li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li>
<li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li>
</ul>
<p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> script </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Shell脚本清空文件的几种方法]]></title>
      <url>http://answerywj.com/2016/09/05/empty-file-in-shell/</url>
      <content type="html"><![CDATA[<p>本文将介绍几种在Linux下清空文件的方法。</p>
<hr>
<a id="more"></a>
<h2 id="Plan-A"><a href="#Plan-A" class="headerlink" title="Plan A"></a>Plan A</h2><p>代码 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">""</span> &gt; <span class="variable">$1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$1</span> is cleaned up."</span></span><br></pre></td></tr></table></figure></p>
<p>运行结果 :<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cat test.txt</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">$ ./plana<span class="selector-class">.sh</span> test.txt</span><br><span class="line">test<span class="selector-class">.txt</span> cleaned up.</span><br><span class="line">$ cat test.txt</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>使用这个方法文件其实并没有真正被清空，而是有一个空行。</p>
</blockquote>
<h2 id="Plan-B"><a href="#Plan-B" class="headerlink" title="Plan B"></a>Plan B</h2><p>代码 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">: &gt; <span class="variable">$1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$1</span> is cleaned up."</span></span><br></pre></td></tr></table></figure></p>
<p>运行结果 :<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cat test.txt</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">$ ./planb<span class="selector-class">.sh</span> test.txt</span><br><span class="line">test<span class="selector-class">.txt</span> is cleaned up.</span><br><span class="line">$ cat test.txt</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>：</code>是一个空命令，起到占位符的作用。这里被清空的文件不再有空行，实现真正意义的清空。</p>
</blockquote>
<h2 id="Plan-C"><a href="#Plan-C" class="headerlink" title="Plan C"></a>Plan C</h2><p>代码 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">cat /dev/null &gt; <span class="variable">$1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$1</span> is cleaned up."</span></span><br></pre></td></tr></table></figure></p>
<p>运行结果 :<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cat test.txt</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">$ ./planc<span class="selector-class">.sh</span> test.txt</span><br><span class="line">test<span class="selector-class">.txt</span> is cleaned up.</span><br><span class="line">$ cat test.txt</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>/dev/null</code>可以看作一个”黑洞”。所有写入它的内容都会丢失。从它那儿读取也什么都读不到。这里被清空的文件同样不再有空行，实现真正意义的清空。</p>
</blockquote>
<h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p>
<ul>
<li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li>
<li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li>
<li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li>
<li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li>
<li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li>
</ul>
<p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> script </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git速查手册]]></title>
      <url>http://answerywj.com/2016/08/28/my-git-help-v1/</url>
      <content type="html"><![CDATA[<p>本手册旨在记录实际工程项目中使用的git命令，方便查找。</p>
<hr>
<a id="more"></a>
<h2 id="配置git"><a href="#配置git" class="headerlink" title="配置git"></a>配置git</h2><p>笔者使用的是v2.1.0，推荐大家使用v1.8以上的<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">版本</a>。 查看git版本：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="comment">--version</span></span><br></pre></td></tr></table></figure></p>
<p>配置命令<code>git config</code>分为三个级别：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--system : 系统级,位于 /etc/gitconfig .</span><br><span class="line">--global : 用户级,位于 ~/.gitconfig .</span><br><span class="line">--local : 仓库级,位于 repo/.git<span class="built_in">/config </span>,default并且优先级最高.</span><br></pre></td></tr></table></figure></p>
<p>首先需要删除global用户信息,防止不同git软件之间的冲突：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git<span class="built_in"> config </span>--global --unset user.name</span><br><span class="line">$ git<span class="built_in"> config </span>--global --unset user.email</span><br></pre></td></tr></table></figure></p>
<p>设置用户信息.若同时使用gitlab和github,推荐配置local用户信息：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git<span class="built_in"> config </span>--local user.name <span class="string">"username"</span></span><br><span class="line">$ git<span class="built_in"> config </span>--local user.email <span class="string">"email"</span></span><br></pre></td></tr></table></figure></p>
<p>git支持https和ssh等协议.https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，而ssh支持的原生git协议速度最快。<br>检查本机SSH公钥:<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">ls</span> ~<span class="string">/.ssh</span></span><br></pre></td></tr></table></figure></p>
<p>若存在,则将<code>id_rsa.pub</code>添加到github的SSH keys中。若不存在,则生成:<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>ssh-keygen -t rsa -C <span class="string">"your_email@youremail.com"</span></span><br></pre></td></tr></table></figure></p>
<p>当ssh配置完成后，再次检查ssh连接情况：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br><span class="line">Hi! You’ve successfully authenticated, <span class="keyword">but</span> GitHub <span class="keyword">does</span> <span class="keyword">not</span> provide shell access.</span><br></pre></td></tr></table></figure></p>
<p>若出现上述信息，则表示设置成功。<br>若使用https访问, 则进行如下配置,并且设置超时时间避免重复输入密码：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global http<span class="selector-class">.sslverify</span> false</span><br><span class="line">$ git config --global credential<span class="selector-class">.helper</span> <span class="string">'cache --timeout=3600'</span></span><br></pre></td></tr></table></figure></p>
<p>设置可视化diff和merge工具, linux系统上推荐使用meld或者diffuse：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git<span class="built_in"> config </span>--global diff.tool meld</span><br><span class="line">$ git<span class="built_in"> config </span>--global merge.tool meld</span><br></pre></td></tr></table></figure></p>
<p>设置颜色,利于使用：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git<span class="built_in"> config </span>--global color.ui.<span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>设置别名：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git<span class="built_in"> config </span>--global alias checkout co</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>上面的命令将<code>checkout</code>设置为别名<code>co</code>。</p>
</blockquote>
<p>最后,查看一下所有的设置：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git<span class="built_in"> config </span>--local --list</span><br><span class="line">$ git<span class="built_in"> config </span>--global --list</span><br><span class="line">$ git<span class="built_in"> config </span>--system --list</span><br></pre></td></tr></table></figure></p>
<h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><p><img src="http://o9zpdspb3.bkt.clouddn.com/git%E5%B7%A5%E4%BD%9C%E6%B5%81.jpg" alt="工作流"></p>
<p>工作区就是你的本地仓库文件夹,不过其中的<code>.git</code>目录不属于工作区,而是版本库。里面存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。<br>现在来解释一下前面的添加和提交操作：  </p>
<ol>
<li><code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</li>
<li><code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。<br>因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。</li>
</ol>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>获取远程仓库：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">clone</span> <span class="title">git</span>@github.com:USERNAME/repo.git</span><br></pre></td></tr></table></figure></p>
<p>将本地的仓库添加到远程：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>cd repo</span><br><span class="line"><span class="variable">$ </span>git init</span><br><span class="line"><span class="variable">$ </span>git remote add origin git<span class="variable">@github</span>.<span class="symbol">com:</span>USERNAME/repo.git</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>origin</code>为远程仓库。</p>
</blockquote>
<p>添加修改:<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">add</span><span class="bash"> &lt;filename&gt; </span></span><br><span class="line">$ git <span class="keyword">add</span><span class="bash"> .  <span class="comment"># 添加当前目录所有修改过的文件  </span></span></span><br><span class="line">$ git <span class="keyword">add</span><span class="bash"> *  <span class="comment"># 递归地添加执行命令时所在的目录中的所有文件</span></span></span><br></pre></td></tr></table></figure></p>
<p>提交修改:<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git commit -m <span class="string">"commit message"</span></span><br><span class="line"><span class="variable">$ </span>git commit -am <span class="string">"commit message"</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>commit message</code>的填写可以参考<a href="http://blog.jobbole.com/92713/" target="_blank" rel="noopener">写好 Git Commit 信息的 7 个建议</a>。<br><code>am</code>将添加和提交合并为一步,但只对本来就存在的文件有效。</p>
</blockquote>
<p>推送修改：<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">push</span> -u <span class="built_in">origin</span> &lt;<span class="built_in">feature</span>-branch-name&gt;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>-u</code>选项可以将本地分支与远程分支关联,下次<code>git pull</code>操作时可以不带参数.具体参见<a href="http://stackoverflow.com/questions/5697750/what-exactly-does-the-u-do-git-push-u-origin-master-vs-git-push-origin-ma" target="_blank" rel="noopener">这里</a>。</p>
</blockquote>
<p>查看远程仓库：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin git@github<span class="selector-class">.com</span>:USERNAME/repo<span class="selector-class">.git</span> (push)</span><br><span class="line">origin git@github<span class="selector-class">.com</span>:USERNAME/repo<span class="selector-class">.git</span> (fetch)</span><br></pre></td></tr></table></figure></p>
<p>fork后同步上游仓库的更新：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一次需要添加上游仓库</span></span><br><span class="line"><span class="variable">$ </span>git remote add upstream git<span class="variable">@github</span>.<span class="symbol">com:</span>USERNAME/repo.git</span><br><span class="line"> </span><br><span class="line"><span class="variable">$ </span>git remote -v</span><br><span class="line">origin  git<span class="variable">@github</span>.<span class="symbol">com:</span>USERNAME/repo.git (push)</span><br><span class="line">origin  git<span class="variable">@github</span>.<span class="symbol">com:</span>USERNAME/repo.git (fetch)</span><br><span class="line">upstream  git<span class="variable">@github</span>.<span class="symbol">com:</span>USERNAME/repo.git  (push)</span><br><span class="line">upstream  git<span class="variable">@github</span>.<span class="symbol">com:</span>USERNAME/repo.git (fetch)</span><br><span class="line"></span><br><span class="line"><span class="variable">$ </span>git fetch upstream </span><br><span class="line"><span class="variable">$ </span>git difftool &lt;branch-name&gt; upstream/master</span><br><span class="line"><span class="variable">$ </span>git merge upstream/master</span><br><span class="line"><span class="variable">$ </span>git mergetool</span><br></pre></td></tr></table></figure></p>
<p>引用公共代码：<br>代码引用在git上有两种方式：<code>submodule</code>和<code>subtree</code>，推荐使用<a href="http://aoxuis.me/post/2013-08-06-git-subtree" target="_blank" rel="noopener">subtree</a>方式。<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 第一次初始化</span><br><span class="line">$ git remote <span class="keyword">add </span>-f &lt;remote-<span class="keyword">subtree-repository-name&gt; </span>&lt;remote-<span class="keyword">subtree-repository-url&gt;</span></span><br><span class="line"><span class="keyword">$ </span>git <span class="keyword">subtree </span><span class="keyword">add </span>--prefix=&lt;local-<span class="keyword">subtree-directory&gt; </span>&lt;remote-<span class="keyword">subtree-repository&gt; </span>&lt;remote-<span class="keyword">subtree-branch-name&gt; </span>--squash</span><br><span class="line"></span><br><span class="line"># 同步<span class="keyword">subtree的更新</span></span><br><span class="line"><span class="keyword">$ </span>git <span class="keyword">subtree </span>pull --prefix=&lt;local-<span class="keyword">subtree-directory&gt; </span>&lt;remote-<span class="keyword">subtree-repository&gt; </span>&lt;remote-<span class="keyword">subtree-branch-name&gt; </span>--squash</span><br><span class="line"></span><br><span class="line"># 推送到远程<span class="keyword">subtree库</span></span><br><span class="line"><span class="keyword">$ </span>git <span class="keyword">subtree </span><span class="keyword">push </span>--prefix=&lt;local-<span class="keyword">subtree-directory&gt; </span>&lt;remote-<span class="keyword">subtree-repository&gt; </span>&lt;remote-<span class="keyword">subtree-branch-name&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="使用标签"><a href="#使用标签" class="headerlink" title="使用标签"></a>使用标签</h2><p>查看标签 ：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span></span><br></pre></td></tr></table></figure></p>
<p>创建标签 ：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span> <span class="title">-a</span> <span class="tag">&lt;tagname&gt;</span> -m <span class="string">"tag message"</span> <span class="comment"># 创建标签在当前最新提交的commit上</span></span><br><span class="line">$ git <span class="keyword">tag</span> <span class="title">-a</span> <span class="tag">&lt;tagname&gt;</span> -m <span class="string">"tag message"</span> <span class="tag">&lt;commit id&gt;</span> <span class="comment"># 创建标签在指定的commit上</span></span><br></pre></td></tr></table></figure></p>
<p>推送标签到远程：<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">push</span> origin &lt;tagname&gt; <span class="meta"># 推送一个本地标签</span></span><br><span class="line">$ git <span class="keyword">push</span> origin --tags <span class="meta"># 推送全部未推送过的本地标签</span></span><br></pre></td></tr></table></figure></p>
<p>删除标签：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git tag -d &lt;tagname&gt; <span class="comment"># 删除一个本地标签；</span></span><br><span class="line"><span class="variable">$ </span>git push origin <span class="symbol">:refs/tags/&lt;tagname&gt;</span> <span class="comment"># 删除一个远程标签。</span></span><br></pre></td></tr></table></figure></p>
<h2 id="撤销与回退"><a href="#撤销与回退" class="headerlink" title="撤销与回退"></a>撤销与回退</h2><p>查看当前仓库状态:<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git status</span><br></pre></td></tr></table></figure></p>
<p>查看文件更改：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git difftool <span class="tag">&lt;<span class="name">filename</span>&gt;</span></span><br><span class="line">$ git mergetool <span class="tag">&lt;<span class="name">filename</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>查看提交历史:<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> git <span class="built-in">log</span></span><br></pre></td></tr></table></figure></p>
<p>撤销工作区的修改：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout <span class="comment">-- &lt;filename&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>撤销所有已经提交到暂存区的修改：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">reset</span> <span class="keyword">HEAD</span> .</span><br></pre></td></tr></table></figure></p>
<p>撤销提交到暂存区的某个文件或文件夹：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">reset</span> <span class="keyword">HEAD</span> -filename</span><br></pre></td></tr></table></figure></p>
<p>回退版本，即回退暂存区的修改：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">reset</span> <span class="comment">--hard &lt;commit-id&gt;</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>上一个版本的<code>commit-id</code>可以用<code>HEAD^</code>表示，上上个版本为<code>HEAD^^</code>，以此类推。</p>
</blockquote>
<p>从版本库删除文件：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm <span class="tag">&lt;<span class="name">filename</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>查看所有分支，有<code>*</code>标记的是当前分支：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">branch </span>-a</span><br></pre></td></tr></table></figure></p>
<p>创建本地分支：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout &lt;<span class="keyword">new</span><span class="type">branch</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>创建并切换本地分支：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b &lt;<span class="keyword">new</span><span class="type">branch</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>推送新建本地分支到远程：<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> git push -u origin &lt;remote-branch-name&gt;</span><br><span class="line">  <span class="keyword">or</span></span><br><span class="line"><span class="symbol">$</span> git push --<span class="keyword">set</span>-upstream <span class="comment">origin &lt;remote-branch-name&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>删除本地分支：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">branch </span>-d &lt;<span class="keyword">branch&gt;</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>若当前分支因为有修改未提交或其它情况不能删除，请使用<code>-D</code>选项强制删除。</p>
</blockquote>
<p>删除远程分支：<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">push</span> <span class="built_in">origin</span> --<span class="built_in">delete</span> &lt;remote-branch-name&gt;</span><br></pre></td></tr></table></figure></p>
<p>清除无用的分支：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git remote prune origin</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>说明：remote上的一个分支被其他人删除后，需要更新本地的分支列表。</p>
</blockquote>
<p>获取远程分支到本地已有分支：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch --<span class="built_in">set</span>-upstream &lt;<span class="built_in">local</span>-branch&gt; origin/branch</span></span><br></pre></td></tr></table></figure></p>
<p>获取远程分支到本地并新建本地分支：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -<span class="keyword">b </span>&lt;local-<span class="keyword">branch&gt; </span>&lt;remote-<span class="keyword">branch&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>同步当前分支的更新，使用<code>git pull</code>并不保险：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载最新的代码到远程跟踪分支, 即origin/&lt;branch-name&gt;</span></span><br><span class="line">$ git fetch <span class="keyword">origin </span>&lt;<span class="keyword">branch-name&gt; </span></span><br><span class="line"><span class="comment"># 查看更新内容</span></span><br><span class="line">$ git <span class="keyword">difftool </span>&lt;<span class="keyword">branch-name&gt; </span><span class="keyword">origin/&lt;branch-name&gt;</span></span><br><span class="line"><span class="keyword"># </span>尝试合并远程跟踪分支的代码到本地分支 </span><br><span class="line">$ git merge <span class="keyword">origin/&lt;branch-name&gt;</span></span><br><span class="line"><span class="keyword"># </span>借助mergetool解决冲突              </span><br><span class="line">$ git mergetool</span><br></pre></td></tr></table></figure></p>
<p>同步其它分支的更新，本例拉取<code>master</code>分支更新：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin <span class="literal">master</span></span><br><span class="line">$ git difftool <span class="tag">&lt;branch-name&gt;</span> origin/<span class="literal">master</span></span><br><span class="line">$ git merge origin/<span class="literal">master</span></span><br><span class="line">$ git mergetool</span><br></pre></td></tr></table></figure></p>
<h2 id="暂存"><a href="#暂存" class="headerlink" title="暂存"></a>暂存</h2><p>当你需要切换分支时,若当前工作区还有些修改没有完成,又不适合提交的,操作切换分支是会提示出错的.这时就需要将这些修改暂存起来:<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git stash save <span class="string">"message"</span></span><br></pre></td></tr></table></figure></p>
<p>查看:<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash <span class="built_in">list</span></span><br></pre></td></tr></table></figure></p>
<p>恢复:<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git stash <span class="keyword">pop</span> [--<span class="keyword">index</span>] [stash@&#123;num&#125;]　</span><br><span class="line">  <span class="keyword">or</span></span><br><span class="line">$ git stash apply [--<span class="keyword">index</span>] [stash@&#123;num&#125;]　<span class="comment"># 不删除已恢复的进度.</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>--index</code>表示不仅恢复工作区,还会恢复暂存区;<code>num</code>是你要恢复的操作的序列号,默认恢复最新进度.</p>
</blockquote>
<p>删除进度:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash <span class="keyword">drop</span> [stash@&#123;<span class="keyword">num</span>&#125;] <span class="comment"># 删除指定进度</span></span><br><span class="line">$ git stash <span class="keyword">clear</span> <span class="comment"># 删除所有</span></span><br></pre></td></tr></table></figure></p>
<h2 id="清理本地仓库"><a href="#清理本地仓库" class="headerlink" title="清理本地仓库"></a>清理本地仓库</h2><ul>
<li><p>检查是否有无用的大文件。</p>
</li>
<li><p>清理无用的分支和标签：</p>
  <figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d <span class="tag">&lt;branch-name&gt;</span></span><br><span class="line">$ git <span class="keyword">tag</span> <span class="title">-d</span> <span class="tag">&lt;tag-name&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>清理<code>.git</code>目录，一般本地仓库过大都是由于存在过多的<code>loose object</code>:</p>
  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git gc <span class="attribute">--prune</span>=now</span><br></pre></td></tr></table></figure>
<blockquote>
<p>tips: 在执行<code>push</code>操作时，<code>git</code>会自动执行一次<code>gc</code>操作，不过只有<code>loose object</code>达到一定数量后才会真正调用，建议手动执行。</p>
</blockquote>
</li>
</ul>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>查看帮助：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git --<span class="built_in">help</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h3><p>当你的仓库中有一些文件，类似密码或者数据库文件不需要提交但又必须放在仓库目录下，每次<code>git status</code>都会提示<code>Untracked</code>，看着让人很不爽。解决这个问题只需要在仓库目录创建一个<code>.gitignore</code>文件即可，编写规则如下：<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tmp/  <span class="comment"># 忽略tmp文件夹下所有内容</span></span><br><span class="line">*<span class="string">.ini</span> <span class="comment"># 忽略所有ini文件</span></span><br><span class="line">!data/ <span class="comment">#忽略除了data文件夹的所有内容</span></span><br></pre></td></tr></table></figure></p>
<p>当然你不必从头编写<code>.gitignore</code>文件，已经有<a href="https://github.com/github/gitignore" target="_blank" rel="noopener">模版</a>提供使用了。  </p>
<p>本规则只忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改<code>.gitignore</code>是无效的。解决方法就是先把本地缓存删除,改变成未track状态：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm -r <span class="comment">--cached .</span></span><br></pre></td></tr></table></figure></p>
<h3 id="处理大型二进制文件"><a href="#处理大型二进制文件" class="headerlink" title="处理大型二进制文件"></a>处理大型二进制文件</h3><p>由于git在存储二进制文件时效率不高,所以需要借助<a href="http://www.oschina.net/news/71365/git-annex-lfs-bigfiles-fat-media-bigstore-sym" target="_blank" rel="noopener">第三方组件</a>。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰老师的git教程</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">常用Git命令清单</a></li>
<li><a href="https://git-scm.com/book/en/v2" target="_blank" rel="noopener">Git-Book</a></li>
<li><a href="https://git-scm.com/docs" target="_blank" rel="noopener">Git-Reference</a></li>
<li><a href="https://segmentfault.com/a/1190000002783245" target="_blank" rel="noopener">Git push与pull的默认行为</a></li>
<li><a href="http://www.tuicool.com/articles/rUBNBvI" target="_blank" rel="noopener">git stash 详解</a></li>
</ol>
<h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p>
<ul>
<li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li>
<li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li>
<li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li>
<li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li>
<li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li>
</ul>
<p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>
]]></content>
      
        <categories>
            
            <category> Git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo+Github博客备份方法]]></title>
      <url>http://answerywj.com/2016/08/10/backup-of-blog-with-hexo-and-github/</url>
      <content type="html"><![CDATA[<p>使用hexo+github搭建的博客,博客作为一个单独的github仓库存在,可是仓库中不包含你每篇博客的源文件。如果你换了一台机器想要更新博客或者想重新发布以前的博客,这就不好办了。我这里推荐一种云端备份的方法。</p>
<hr>
<a id="more"></a>
<h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><ul>
<li>首先,在你博客的仓库中新开一个分支,作为backup(master为博客的推送分支),并且设为默认分支。</li>
<li>将远程仓库获取到本地(两个仓库都需要获取)。</li>
<li><p>每次写完博客之前,需要先获取更新:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git pull</span><br></pre></td></tr></table></figure>
</li>
<li><p>写完后,对backup分支进行备份:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git add .</span><br><span class="line"><span class="variable">$ </span>git commit -m <span class="string">"message"</span></span><br><span class="line"><span class="variable">$ </span>git push</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后更新博客到master分支:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo n <span class="string">"postName"</span> <span class="comment"># hexo new 新建文章</span></span><br><span class="line"><span class="variable">$ </span>hexo g <span class="comment"># hexo generate 生成静态页面至public目录</span></span><br><span class="line"><span class="variable">$ </span>hexo s <span class="comment"># hexo server 开启预览访问端口（默认端口4000，'ctrl + c'关闭server）</span></span><br><span class="line"><span class="variable">$ </span>hexo d <span class="comment"># hexo deploy #将.deploy目录部署到GitHub</span></span><br><span class="line"><span class="variable">$ </span>hexo clean</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后将master分支的修改获取到本地:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git pull</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p>
<ul>
<li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li>
<li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li>
<li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li>
<li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li>
<li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li>
</ul>
<p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>
]]></content>
      
        <categories>
            
            <category> Git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux的硬链接和软链接]]></title>
      <url>http://answerywj.com/2016/08/02/link-in-linux/</url>
      <content type="html"><![CDATA[<p>Linux下链接的命令是<em>ln</em>,可以通过<code>man ln</code>查看.</p>
<hr>
<a id="more"></a>
<h2 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h2><ol>
<li>链接的是索引节点(<em>inode</em>),硬链接文件<em>inode</em>值相同(在Linux的文件系统的文件不管是什么类型都给它分配一个<em>indoe</em>号),所以硬链接文件不占用磁盘空间.相当于创建一个别名;dentry是改变的(dentry包含文件名和inode等信息).</li>
<li>有两个限制:目录不能创建硬链接;只能在同一个文件系统中进行硬链接.</li>
<li>命令:<br> <code>ln srouce dest</code></li>
<li>对源文件进行修改或删除,硬链接文件会同步修改.但删除硬链接的源文件,硬链接文件仍然存在.</li>
</ol>
<h2 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h2><ol>
<li>软链接又称为符号链接,链接的是路径(<em>path</em>),链接文件中包含的是另一个文件的位置信息.</li>
<li>可以是任意文件或者目录,可以链接不同文件系统的文件.</li>
<li>可以链接不存在的文件,这种现象称为”断链”;也可以链接自己</li>
<li>命令:<br> <code>ln -s srouce dest</code><br> <em>source</em>最好用绝对路径表示,这样可以在任何目录下进行链接.若使用相对路径，如果当前的工作路径与要创建的符号链接文件所在路径不同，就不能进行链接.</li>
<li>对源文件进行修改或删除,软链接文件会同步修改.</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h3><ol>
<li>因为链接文件中包含的是另一个文件的位置信息，所以当源文件从一个目录移到其它目录中,再访问链接文件,系统就找不到了.</li>
<li>需要系统分配额外的空间用于建立新的索引节点和保存源文件的路径.</li>
</ol>
<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><ul>
<li>与windows类比</li>
</ul>
<ol>
<li>硬链接类似复制,但与复制不同的是存在同步机制,一处的更改会同步到另一处,删除一处不会影响另一出.</li>
<li>软链接相当于windows中的快捷方式.</li>
</ol>
<ul>
<li><p>硬链接可以防止误删<br>硬连接的作用是允许一个文件拥有多个有效路径名，因为多个硬链接文件指向同一个索引节点.这样用户就可以建立硬连接到重要文件,以防止“误删”的功能.只删除一个链接并不影响索引节点本身和其它的链接，只有当最后一个链接被删除后，文件的数据块及目录的链接才会被释放。也就是说，文件才会被真正删除。</p>
</li>
<li><p>硬链接的两个限制<br>虽然系统有目录不能创建硬链接的限制,但是命令<code>ln -d</code>可以让超级用户对目录作硬连接，这说明系统限制对目录进行硬连接只是一个硬性规定，并不是逻辑上不允许或技术上的不可行。那么为什么要做出这个硬性规定呢?<br>第一,如果引入了对目录的硬连接就有可能在目录中引入循环，那么在目录遍历的时候系统就会陷入无限循环当中。可是符号连接不也可以引入循环吗？因为在linux系统中，每个文件(目录也是文件)都对应着一个inode结构，其中inode数据结构中包含了文件类型(目录，普通文件，符号连接文件等等)的信息，也就是说操作系统在遍历目录时可以判断出符号连接，既然可以判断出符号连接当然就可以采取一些措施来防范进入过大的循环了，系统在连续遇到8个符号连接后就停止遍历，这就是为什么对目录符号连接不会进入死循环的原因了。但是对于硬连接，由于操作系统中采用的数据结构和算法限制，目前是不能防范这种死循环的。<br>第二,文件的dentry结构主要包含了文件名,文件的inode号,指向父目录dentry结构的指针和其他一些指针,这里关键是那个指向父目录的指针;系统中所有的dentry结构都是按杂凑值存放在杂凑表中的，这里的杂凑算法很重要，它是取文件名和文件的父目录dentry结构的地址一起杂凑运算出杂凑值的。现在我们假设有两个目录 /a和/b，其中/b是我们通过<code>ln -d</code>命令建立起来的对/a的硬连接。这个时候内核空间中就会存在一个/a的dentry结构和一个/b的dentry结构，由上面的知识可知，/a和/b目录下面的每一个文件或目录都各自有对应的dentry结构(因为虽然/a目录下面的文件名没有改变，但是因为dentry结构有指向父目录dentry 的指针和计算杂凑值时考虑了父目录dentry结构的地址，这个时候dentry结构就分身乏术了),而且这种继承还会影响到所有子目录下面的文件，这样下来就会浪费很多系统空间了,特别是如果被硬连接的目录中存在大量文件和子目录的时候就更加明显了.</p>
</li>
</ul>
<h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p>
<ul>
<li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li>
<li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li>
<li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li>
<li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li>
<li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li>
</ul>
<p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> link </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux socket编程的心跳机制总结]]></title>
      <url>http://answerywj.com/2016/07/14/keepalive-of-socket/</url>
      <content type="html"><![CDATA[<p><strong>心跳机制</strong>用于保持客户端和服务端的连接.</p>
<hr>
<a id="more"></a>
<h2 id="什么是心跳机制"><a href="#什么是心跳机制" class="headerlink" title="什么是心跳机制"></a>什么是心跳机制</h2><p><strong>心跳机制</strong>就是当客户端与服务端建立连接后，每隔几分钟发送一个固定消息给服务端，服务端收到后回复一个固定消息给客户端，如果服务端几分钟内没有收到客户端消息，则视客户端断开。发送方可以是客户端和服务端，看具体需求。</p>
<h2 id="为什么要使用"><a href="#为什么要使用" class="headerlink" title="为什么要使用"></a>为什么要使用</h2><p>我们都知道在TCP这种长连接情况下下，有可能有一大段时间是没有数据往来的，即处于空闲状态。理论上说，这个连接是一直保持连接的，但是在实际应用中，如果中间节点出现什么故障是难以预测的。更可怕的是，有的节点会自动把一定时间之内没有数据交互的连接切断。所以，需要我们利用心跳机制，来维持长连接，保活通信。</p>
<h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><ul>
<li><strong>应用层：</strong> 由应用程序自己每隔一定时间向客户/服务端发送一个短小的数据包，然后启动一个线程，在线程中不断检测客户端的回应， 如果在一定时间内没有收到客户/服务端的回应，即认为客户/服务端已经掉线，连接不可用。</li>
<li><strong>设置SO_KEEPALIVE套接字选项：</strong>在TCP通信中，存在heartbeat机制。其实就是TCP的选项。当服务/客户端，一方开启KeepAlive功能后，就会自动在规定时间内向对方发送心跳包， 而另一方在收到心跳包后就会自动回复，以告诉对方我仍然在线。<blockquote>
<p><strong>注意：</strong>因为开启KeepAlive功能需要消耗额外的宽带和流量，所以TCP协议层默认并不默认开启KeepAlive。KeepAlive超时需要7,200，000 MilliSeconds， 即2小时，探测次数为5次。对于很多应用程序来说，空闲时间太长。因此，我们可以手工开启KeepAlive功能并设置合理的KeepAlive参数。</p>
</blockquote>
</li>
</ul>
<h3 id="我的实现"><a href="#我的实现" class="headerlink" title="我的实现"></a>我的实现</h3><p>这里具体介绍设置SO_KEEPALIVE套接字选项这个方法。</p>
<h4 id="SO-KEEPALIVE的三个参数"><a href="#SO-KEEPALIVE的三个参数" class="headerlink" title="SO_KEEPALIVE的三个参数:"></a>SO_KEEPALIVE的三个参数:</h4><ol>
<li>tcp_keepalive_intvl：探测发包间隔为intvl。</li>
<li>tcp_keepalive_idle：连接在idle时间内没有任何数据往来,则进行此TCP层的探测。</li>
<li>tcp_keepalive_cnt：尝试探测的次数。</li>
</ol>
<h4 id="setsockopt-函数介绍"><a href="#setsockopt-函数介绍" class="headerlink" title="setsockopt()函数介绍"></a>setsockopt()函数介绍</h4><ol>
<li>用法：设置与某个套接字关联的选 项。选项可能存在于多层协议中，它们总会出现在最上面的套接字层。</li>
<li>函数原型：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sock, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">const</span> <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> optlen)</span></span>;</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">sock：将要被设置或者获取选项的套接字。</span><br><span class="line">level：选项所在的协议层。</span><br><span class="line">optname：需要访问的选项名。</span><br><span class="line">optval：对于getsockopt()，指向返回选项值的缓冲。对于setsockopt()，指向包含新选项值的缓冲。</span><br><span class="line">optlen：对于getsockopt()，作为入口参数时，选项值的最大长度。作为出口参数时，选项值的实际长度。对于setsockopt()，现选项的长度。</span><br><span class="line"></span><br><span class="line">返回说明：</span><br><span class="line">成功执行时，返回<span class="number">0</span>。失败返回<span class="number">-1</span>，errno被设为以下的某个值</span><br><span class="line">EBADF：sock不是有效的文件描述词</span><br><span class="line">EFAULT：optval指向的内存并非有效的进程空间</span><br><span class="line">EINVAL：在调用setsockopt()时，optlen无效</span><br><span class="line">ENOPROTOOPT：指定的协议层不能识别选项</span><br><span class="line">ENOTSOCK：sock描述的不是套接字</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">heartbeat</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> alive,error,idle,cnt,intv;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * open keepalive on fd</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Restart:</span><br><span class="line">    alive = <span class="number">1</span>;<span class="comment">//set keepalive open</span></span><br><span class="line">    ret=setsockopt(fd,SOL_SOCKET,SO_KEEPALIVE,&amp;alive,<span class="keyword">sizeof</span>(alive));</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DEBUG(<span class="string">"set socket option error.\n"</span>);</span><br><span class="line">        <span class="keyword">goto</span> Restart;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 60S without data,send heartbeat package</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    idle = <span class="number">60</span>;</span><br><span class="line">    ret = setsockopt(fd,SOL_TCP,TCP_KEEPIDLE,&amp;idle,<span class="keyword">sizeof</span>(idle));</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DEBUG(<span class="string">"set keepalive idle error.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * without any respond,3m later resend package</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    intv = <span class="number">180</span>;</span><br><span class="line">    ret = setsockopt(fd,SOL_TCP,TCP_KEEPINTVL,&amp;intv,<span class="keyword">sizeof</span>(intv));</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DEBUG(<span class="string">"set keepalive intv error.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * send 5 times,without any response,mean connect lose</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    cnt = <span class="number">5</span>;</span><br><span class="line">    ret = setsockopt(fd,SOL_TCP,TCP_KEEPCNT,&amp;cnt,<span class="keyword">sizeof</span>(cnt));</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DEBUG(<span class="string">"set keepalive cnt error.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当然，还是有很多方法去实现心跳机制的，比如利用select实现的超时控制，或者利用守护进程或线程的单独检测。不过我个人认为设置SO_KEEPALIVE实现起来最简单，最方便。如果大家发现有什么问题，也欢迎大家交流。</p>
<h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p>
<ul>
<li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li>
<li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li>
<li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li>
<li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li>
<li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li>
</ul>
<p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>
]]></content>
      
        <categories>
            
            <category> C </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tcp </tag>
            
            <tag> keepalive </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[UNIX网络编程-connect函数及其包裹函数介绍]]></title>
      <url>http://answerywj.com/2016/07/14/connect-in-unix/</url>
      <content type="html"><![CDATA[<p>本文将介绍UNIX网络编程中<code>connect</code>函数及其包裹函数。</p>
<hr>
<a id="more"></a>
<h2 id="函数简介"><a href="#函数简介" class="headerlink" title="函数简介"></a>函数简介</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr* server_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">									返回值：若成功返回<span class="number">0</span>;若失败则返回<span class="number">-1.</span></span><br></pre></td></tr></table></figure>
<p><code>connect</code>函数用于客户端建立tcp连接，发起三次握手过程。其中<code>sockfd</code>标识了主动套接字，<code>server_addr</code>是该套接字要连接的主机地址和端口号，<code>addrlen</code>为<code>server_addr</code>缓冲区的长度。</p>
<p>连接失败时，可以根据以下<code>errno</code>值判断失败的原因：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EBADF：参数sockfd 非合法socket处理代码<span class="comment">;</span></span><br><span class="line">EFAULT：参数serv_addr指针指向无法存取的内存空间<span class="comment">;</span></span><br><span class="line">ENOTSOCK：参数sockfd为一文件描述词，非socket<span class="comment">;</span></span><br><span class="line">EISCONN：参数sockfd的socket已是连线状态<span class="comment">;</span></span><br><span class="line">ECONNREFUSED：连线要求被server端拒绝<span class="comment">;</span></span><br><span class="line">ETIMEDOUT：企图连线的操作超过限定时间仍未有响应<span class="comment">;</span></span><br><span class="line">ENETUNREACH：无法传送数据包至指定的主机<span class="comment">;</span></span><br><span class="line">EAFNOSUPPORT：sockaddr结构的sa_family不正确<span class="comment">;</span></span><br><span class="line">EALREADY：socket为不可阻塞且先前的连线操作还未完成<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="包裹函数-下载"><a href="#包裹函数-下载" class="headerlink" title="包裹函数(下载)"></a>包裹函数(<a href="https://github.com/AnSwErYWJ/UNP/blob/master/TCP/Connect.c" target="_blank" rel="noopener">下载</a>)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSLEEP 128</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_connect</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">const</span> struct sockaddr *servaddr,<span class="keyword">socklen_t</span> addrlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nsec;</span><br><span class="line">    <span class="keyword">for</span>(nsec = <span class="number">1</span>;nsec &lt;= MAXSLEEP;nsec &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(connect(sockfd,servaddr,addrlen) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//connection accepted</span></span><br><span class="line">        <span class="keyword">if</span>(nsec &lt;= MAXSLEEP/<span class="number">2</span>)<span class="comment">//sleep nesc,then connect retry</span></span><br><span class="line">            sleep(nsec);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>包裹函数为<code>connect</code>函数设置了超时重连的机制，如果连接成功，则成功返回。如果连接失败，则每次等待1、2、4、8。。。秒后继续尝试重新连接，直到<code>MAXSLEEP</code>为止。</p>
<h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p>
<ul>
<li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li>
<li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li>
<li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li>
<li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li>
<li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li>
</ul>
<p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>
]]></content>
      
        <categories>
            
            <category> C </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tcp </tag>
            
            <tag> connect </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux C编程的DEBUG宏]]></title>
      <url>http://answerywj.com/2016/07/14/debug-macro/</url>
      <content type="html"><![CDATA[<p>DEBUG宏用于Linux下C编程时调试使用.</p>
<hr>
<a id="more"></a>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="emphasis">***</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">	&gt; File Name: debug.c</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">	&gt; Author: AnSwEr</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">	&gt; Mail: 1045837697@qq.com</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">	&gt; Created Time: 2015年07月23日 星期四 18时19分48秒</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"> <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**/</span></span></span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#define DEBUG_PRINT <span class="keyword">do</span>&#123;&#125;<span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> defined(DEBUG_PRINT)</span><br><span class="line">#define DEBUG(...)\</span><br><span class="line">        <span class="keyword">do</span>&#123;\</span><br><span class="line">            fprintf(stderr,<span class="string">"-----DEBUG-----\n"</span>);\</span><br><span class="line">            fprintf(stderr,<span class="string">"%s %s\n"</span>,__TIME__,__DATE__);\</span><br><span class="line">            fprintf(stderr,<span class="string">"%s:%d:%s():"</span>,__FILE__,__LINE__,__func__);\</span><br><span class="line">            fprintf(stderr,__VA_ARGS__);\</span><br><span class="line">        &#125;<span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    DEBUG(<span class="string">"Debug successfully!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ol>
<li><em>do{}while(0)</em>：使用<em>do{…}while(0)</em>构造后的宏定义不会受到大括号、分号等的影响，而且可以定义空宏而不受警告。</li>
<li>参数介绍：<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">__LINE__</span>：在源代码中插入当前源代码行号；</span><br><span class="line"><span class="variable">__FILE__</span>：在源文件中插入当前源文件名；</span><br><span class="line"><span class="variable">__DATE__</span>：在源文件中插入当前的编译日期</span><br><span class="line"><span class="variable">__TIME__</span>：在源文件中插入当前编译时间；</span><br><span class="line"><span class="variable">__func__</span>：输出函数名称,功能与<span class="variable">_Function_</span>相同；</span><br><span class="line"><span class="variable">__VA_ARGS__</span>：可变参数类型。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>代码<a href="https://github.com/AnSwErYWJ/DogFood/blob/master/C/debug.c" target="_blank" rel="noopener">下载</a>。</p>
</blockquote>
<h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p>
<ul>
<li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li>
<li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li>
<li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li>
<li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li>
<li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li>
</ul>
<p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>
]]></content>
      
        <categories>
            
            <category> C </category>
            
        </categories>
        
        
        <tags>
            
            <tag> debug </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[UNIX编程安全读写函数]]></title>
      <url>http://answerywj.com/2016/07/14/safe-read-and-write/</url>
      <content type="html"><![CDATA[<p>字节流套接字（TCP套接字）上的read和write函数所表现的行为不同于通常的文件I/O。字节流套接字调用read或write输入或输出的字节数可能比请求的数量少，然而这并不是出错的状态。<strong>这是因为内核中用于套接字的缓冲区可能达到了极限。</strong>通常这种情况出现在一次读多于4096个字节或write在非阻塞情况下返回不足字节数。为了不多次调用read或防止write返回不足字节数，我们用下面的两个函数来替代read和write。</p>
<hr>
<a id="more"></a>
<h2 id="readn"><a href="#readn" class="headerlink" title="readn"></a>readn</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> safe_read(<span class="keyword">int</span> fd,<span class="keyword">void</span> *vptr,<span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> nleft;</span><br><span class="line">    <span class="keyword">ssize_t</span> nread;</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line"></span><br><span class="line">    ptr=vptr;</span><br><span class="line">    nleft=n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(nleft &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((nread = read(fd,ptr,nleft)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR) <span class="comment">//被信号中断，重读</span></span><br><span class="line">                nread = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//出错</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nread == <span class="number">0</span>) <span class="comment">//EOF</span></span><br><span class="line">	        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        nleft -= nread;</span><br><span class="line">        ptr += nread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (n-nleft);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="writen"><a href="#writen" class="headerlink" title="writen"></a>writen</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span>	safe_write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span>  nleft;</span><br><span class="line">    <span class="keyword">ssize_t</span> nwritten;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *ptr;</span><br><span class="line"></span><br><span class="line">    ptr = vptr;</span><br><span class="line">    nleft = n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(nleft &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">if</span>((nwritten = write(fd, ptr, nleft)) &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nwritten &lt; <span class="number">0</span> &amp;&amp; errno == EINTR) <span class="comment">//被信号中断，重写</span></span><br><span class="line">                nwritten = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//error</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		nleft -= nwritten;</span><br><span class="line">		ptr   += nwritten;</span><br><span class="line">     &#125;</span><br><span class="line">	<span class="keyword">return</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面介绍了两个安全读写函数，但是并不意味着这两个函数在任何地方都完全适用，所以不要强迫自己使用。需要注意阻塞、效率等问题，当你只是读写少量字节时，就没必要使用了。</p>
<h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p>
<ul>
<li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li>
<li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li>
<li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li>
<li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li>
<li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li>
</ul>
<p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>
]]></content>
      
        <categories>
            
            <category> C </category>
            
        </categories>
        
        
        <tags>
            
            <tag> read </tag>
            
            <tag> write </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C语言生成随机数]]></title>
      <url>http://answerywj.com/2016/07/14/generate-random-numbers/</url>
      <content type="html"><![CDATA[<p>本文将介绍C语言生成随机数的方法,主要使用 <em>rand()</em> 函数和 <em>srand()</em> 函数.</p>
<hr>
<a id="more"></a>
<h2 id="rand函数"><a href="#rand函数" class="headerlink" title="rand函数"></a>rand函数</h2><h3 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h3><p><em>rand()</em>函数是产生随机数的一个随机函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>返回值：<br><em>rand()</em>返回值为一随机数值，范围在0至RAND_MAX 间（RAND_MAX定义在stdlib.h，其值为2147483647）。</p>
<blockquote>
<p><strong>注：</strong>在调用此函数前，必须先利用srand()设好随机数种子。如果未设随机数种子，rand()在调用时会自动设随机数种子为1。</p>
</blockquote>
<h3 id="示例一："><a href="#示例一：" class="headerlink" title="示例一："></a>示例一：</h3><p>代码：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="emphasis">***</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">	&gt; File Name: rand.c</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">	&gt; Author: AnSwEr</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">	&gt; Mail: 1045837697@qq.com</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">	&gt; Created Time: 2015年10月24日 星期六 20时50分59秒</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"> <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 产生1到6的随机数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">"%d "</span>,rand()%<span class="number">6</span>+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><img src="http://img.blog.csdn.net/20151024205732527" alt="这里写图片描述"></p>
<p><strong>说明：</strong>这里两次运行的结果相同，是因为未利用<em>srand()</em>设置随机数种子，所以rand()在调用时会自动设随机数种子为1。</p>
<h2 id="srand函数"><a href="#srand函数" class="headerlink" title="srand函数"></a>srand函数</h2><h3 id="函数介绍-1"><a href="#函数介绍-1" class="headerlink" title="函数介绍"></a>函数介绍</h3><p><em>srand()</em>函数是随机数发生器的初始化函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">srand</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seed)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>参数：<br>seed必须是个整数，通常可以利用<em>geypid()</em>或<em>time(0)</em>的返回值来当做seed。如果每次seed都设相同值，那么<em>rand()</em>所产生的随机数值会像上面的示例一每次就会一样。</p>
<h3 id="示例二："><a href="#示例二：" class="headerlink" title="示例二："></a>示例二：</h3><p>代码：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="emphasis">***</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">	&gt; File Name: srand.c</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">	&gt; Author: AnSwEr</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">	&gt; Mail: 1045837697@qq.com</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">	&gt; Created Time: 2015年10月24日 星期六 21时01分58秒</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"> <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 产生1-6的随机数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;time.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    srand((unsigned <span class="built_in">int</span>)time(NULL));</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">"%d "</span>,rand()%<span class="number">6</span>+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><img src="http://img.blog.csdn.net/20151024210616461" alt="这里写图片描述"></p>
<p>哈哈，这下两次结果就不同了吧。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于随机数的知识就先总结这么多，以后碰到更复杂的再继续。</p>
<h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p>
<ul>
<li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li>
<li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li>
<li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li>
<li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li>
<li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li>
</ul>
<p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>
]]></content>
      
        <categories>
            
            <category> C </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 随机数 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux Shell 脚本调试总结]]></title>
      <url>http://answerywj.com/2016/07/14/debug-for-shell-script/</url>
      <content type="html"><![CDATA[<p>Shell脚本是用户与Linux操作系统交互的一种方式,在脚本编程过程中自然少不了进行调试工作,本文将介绍三种常用的调试方法.(默认使用bash shell)</p>
<hr>
<a id="more"></a>
<h2 id="追踪脚本的执行"><a href="#追踪脚本的执行" class="headerlink" title="追踪脚本的执行"></a>追踪脚本的执行</h2><p>使用<strong>-x</strong>选项可以打印出脚本执行的每一行命令以及当前状态.<br>有如下脚本,打印数字1到10:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..10&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<p>我们使用<strong>-x</strong>选项进行调试如下:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#在每一行前加上行号</span><br><span class="line">export PS4=<span class="string">'+$&#123;BASH_SOURCE&#125;:$&#123;LINENO&#125;:$&#123;FUNCNAME[0]&#125;: '</span></span><br><span class="line">#进行调试</span><br><span class="line">sh -x test.sh</span><br><span class="line">#调试结果</span><br><span class="line">+test<span class="selector-class">.sh</span>:<span class="number">3</span>:: <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> <span class="string">'&#123;1..10&#125;'</span></span><br><span class="line">+test<span class="selector-class">.sh</span>:<span class="number">5</span>:: echo <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">+test<span class="selector-class">.sh</span>:<span class="number">3</span>:: <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> <span class="string">'&#123;1..10&#125;'</span></span><br><span class="line">+test<span class="selector-class">.sh</span>:<span class="number">5</span>:: echo <span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">+test<span class="selector-class">.sh</span>:<span class="number">3</span>:: <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> <span class="string">'&#123;1..10&#125;'</span></span><br><span class="line">+test<span class="selector-class">.sh</span>:<span class="number">5</span>:: echo <span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">+test<span class="selector-class">.sh</span>:<span class="number">3</span>:: <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> <span class="string">'&#123;1..10&#125;'</span></span><br><span class="line">+test<span class="selector-class">.sh</span>:<span class="number">5</span>:: echo <span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">+test<span class="selector-class">.sh</span>:<span class="number">3</span>:: <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> <span class="string">'&#123;1..10&#125;'</span></span><br><span class="line">+test<span class="selector-class">.sh</span>:<span class="number">5</span>:: echo <span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">+test<span class="selector-class">.sh</span>:<span class="number">3</span>:: <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> <span class="string">'&#123;1..10&#125;'</span></span><br><span class="line">+test<span class="selector-class">.sh</span>:<span class="number">5</span>:: echo <span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line">+test<span class="selector-class">.sh</span>:<span class="number">3</span>:: <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> <span class="string">'&#123;1..10&#125;'</span></span><br><span class="line">+test<span class="selector-class">.sh</span>:<span class="number">5</span>:: echo <span class="number">7</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line">+test<span class="selector-class">.sh</span>:<span class="number">3</span>:: <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> <span class="string">'&#123;1..10&#125;'</span></span><br><span class="line">+test<span class="selector-class">.sh</span>:<span class="number">5</span>:: echo <span class="number">8</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line">+test<span class="selector-class">.sh</span>:<span class="number">3</span>:: <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> <span class="string">'&#123;1..10&#125;'</span></span><br><span class="line">+test<span class="selector-class">.sh</span>:<span class="number">5</span>:: echo <span class="number">9</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line">+test<span class="selector-class">.sh</span>:<span class="number">3</span>:: <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> <span class="string">'&#123;1..10&#125;'</span></span><br><span class="line">+test<span class="selector-class">.sh</span>:<span class="number">5</span>:: echo <span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure></p>
<p>有时候,你只需要对脚本的一部分进行调试,那么可以使用如下命令:<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> -x <span class="comment">#在执行时显示参数和命令</span></span><br><span class="line"><span class="keyword">set</span> +x <span class="comment">#禁止调试</span></span><br><span class="line"><span class="keyword">set</span> -v <span class="comment">#当命令行读取时显示输入</span></span><br><span class="line"><span class="keyword">set</span> +v <span class="comment">#禁止打印输入</span></span><br></pre></td></tr></table></figure></p>
<p>可以使用<strong>set builtin</strong>来启用或者禁止调试打印.<br>对上文脚本做如下修改:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..10&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">set</span> -x</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">    <span class="built_in">set</span> +x</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<p>结果如下:<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">+<span class="keyword">test</span>.<span class="keyword">sh</span>:6:: echo 1</span><br><span class="line">1</span><br><span class="line">+<span class="keyword">test</span>.<span class="keyword">sh</span>:7:: <span class="keyword">set</span> +x</span><br><span class="line">+<span class="keyword">test</span>.<span class="keyword">sh</span>:6:: echo 2</span><br><span class="line">2</span><br><span class="line">+<span class="keyword">test</span>.<span class="keyword">sh</span>:7:: <span class="keyword">set</span> +x</span><br><span class="line">+<span class="keyword">test</span>.<span class="keyword">sh</span>:6:: echo 3</span><br><span class="line">3</span><br><span class="line">+<span class="keyword">test</span>.<span class="keyword">sh</span>:7:: <span class="keyword">set</span> +x</span><br><span class="line">+<span class="keyword">test</span>.<span class="keyword">sh</span>:6:: echo 4</span><br><span class="line">4</span><br><span class="line">+<span class="keyword">test</span>.<span class="keyword">sh</span>:7:: <span class="keyword">set</span> +x</span><br><span class="line">+<span class="keyword">test</span>.<span class="keyword">sh</span>:6:: echo 5</span><br><span class="line">5</span><br><span class="line">+<span class="keyword">test</span>.<span class="keyword">sh</span>:7:: <span class="keyword">set</span> +x</span><br><span class="line">+<span class="keyword">test</span>.<span class="keyword">sh</span>:6:: echo 6</span><br><span class="line">6</span><br><span class="line">+<span class="keyword">test</span>.<span class="keyword">sh</span>:7:: <span class="keyword">set</span> +x</span><br><span class="line">+<span class="keyword">test</span>.<span class="keyword">sh</span>:6:: echo 7</span><br><span class="line">7</span><br><span class="line">+<span class="keyword">test</span>.<span class="keyword">sh</span>:7:: <span class="keyword">set</span> +x</span><br><span class="line">+<span class="keyword">test</span>.<span class="keyword">sh</span>:6:: echo 8</span><br><span class="line">8</span><br><span class="line">+<span class="keyword">test</span>.<span class="keyword">sh</span>:7:: <span class="keyword">set</span> +x</span><br><span class="line">+<span class="keyword">test</span>.<span class="keyword">sh</span>:6:: echo 9</span><br><span class="line">9</span><br><span class="line">+<span class="keyword">test</span>.<span class="keyword">sh</span>:7:: <span class="keyword">set</span> +x</span><br><span class="line">+<span class="keyword">test</span>.<span class="keyword">sh</span>:6:: echo 10</span><br><span class="line">10</span><br><span class="line">+<span class="keyword">test</span>.<span class="keyword">sh</span>:7:: <span class="keyword">set</span> +x</span><br></pre></td></tr></table></figure></p>
<h2 id="自定义日志"><a href="#自定义日志" class="headerlink" title="自定义日志"></a>自定义日志</h2><p>上面这种调试手段是bash内建的,而且输出格式固定而且繁琐.所以我们需要根据需要的信息,自定义格式来显示调试信息,通过设定_DEBUG环境变量来完成:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># run:_DEBUG=on sh debug.sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> DEBUG()</span><br><span class="line">&#123;</span><br><span class="line">    [ <span class="string">"<span class="variable">$_DEBUG</span>"</span> == <span class="string">"on"</span> ] &amp;&amp; <span class="variable">$@</span> || :</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    DEBUG <span class="built_in">echo</span> -e <span class="string">"This is debug line!"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<p>我们将_DEBUG环境变量设定为一个开关,只有打开时才会输出调试日志.<br>使用如上脚本结果如下:<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[aidu1602@ResU10 tools]$ _DEBUG=<span class="keyword">on</span> <span class="keyword">sh</span> <span class="keyword">debug</span>.<span class="keyword">sh</span></span><br><span class="line">This <span class="keyword">is</span> <span class="keyword">debug</span> line!</span><br><span class="line"><span class="number">1</span></span><br><span class="line">This <span class="keyword">is</span> <span class="keyword">debug</span> line!</span><br><span class="line"><span class="number">2</span></span><br><span class="line">This <span class="keyword">is</span> <span class="keyword">debug</span> line!</span><br><span class="line"><span class="number">3</span></span><br><span class="line">This <span class="keyword">is</span> <span class="keyword">debug</span> line!</span><br><span class="line"><span class="number">4</span></span><br><span class="line">This <span class="keyword">is</span> <span class="keyword">debug</span> line!</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<p>这样我们就可以自定义调试信息,并且可以控制调试开关啦.</p>
<h2 id="使用专用调试器"><a href="#使用专用调试器" class="headerlink" title="使用专用调试器"></a>使用专用调试器</h2><p>如果你需要调试一个非常复杂的脚本,并且需要一个及其专业的调试器,像GDB那样,那么我推荐这款开源的脚本调试器<a href="http://bashdb.sourceforge.net/" target="_blank" rel="noopener">bashdb</a>,具体使用可以参考它的<a href="http://bashdb.sourceforge.net/bashdb.html" target="_blank" rel="noopener">文档</a>.</p>
<h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p>
<ul>
<li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li>
<li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li>
<li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li>
<li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li>
<li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li>
</ul>
<p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> debug </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux下adb devices no permissions解决方案]]></title>
      <url>http://answerywj.com/2016/07/14/solution-of-adb-devices-no-permissions/</url>
      <content type="html"><![CDATA[<p>Linux下adb工具<a href="http://pan.baidu.com/s/1qYhBG2w" target="_blank" rel="noopener">下载</a>，下载解压到<em>/usr/bin</em>目录。</p>
<hr>
<a id="more"></a>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>当我们在Linux下连接安卓手机，进行adb调试时，执行<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>adb devices</span><br></pre></td></tr></table></figure></p>
<p>会出现如下错误提示：<br><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span> <span class="keyword">of</span> devices attached</span><br><span class="line">???????????? no permissions</span><br></pre></td></tr></table></figure></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>首先创建一个规则配置文件：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vi <span class="regexp">/etc/u</span>dev<span class="regexp">/rules.d/</span><span class="number">70</span>-android.rules</span><br></pre></td></tr></table></figure></p>
<p>保存并退出。</p>
<p>查看USB设备信息，拔掉设备再查看一次，就可以比较出安卓设备是哪一个了，我的设备信息如下：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ lsusb</span><br><span class="line"><span class="keyword">Bus </span><span class="number">003</span> Device <span class="number">011</span>: ID <span class="number">1</span>f3a:<span class="number">1002</span> Onda (unverified)</span><br></pre></td></tr></table></figure></p>
<p>打开刚才的规则配置文件，写入如下内容：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">SUBSYSTEM</span>==<span class="string">"usb"</span>,ATTRS&#123;idVendor&#125;==<span class="string">"1f3a"</span>,ATTRS&#123;idProduct&#125;==<span class="string">"1002"</span>, MODE=<span class="string">"0666"</span></span><br></pre></td></tr></table></figure></p>
<p>其中idvendor和idProduct指的是usb的id号，ID 1f3a是idVendor ，1002就是 idProduct。</p>
<p>然后赋予文件权限<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chmod a+x <span class="regexp">/etc/u</span>dev<span class="regexp">/rules.d/</span><span class="number">70</span>-android.rules</span><br></pre></td></tr></table></figure></p>
<p>重启udev：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo <span class="regexp">/etc/i</span>nit.d<span class="regexp">/udev restart</span></span><br></pre></td></tr></table></figure></p>
<p> 注意，这里一定要拔掉设备再重连！然后执行如下命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo adb <span class="built_in">kill</span>-server</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> adb devices</span></span><br></pre></td></tr></table></figure></p>
<p>显示信息如下：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* daemon <span class="keyword">not</span> running. starting it now on<span class="built_in"> port </span>5037 *</span><br><span class="line">* daemon started successfully *</span><br><span class="line">List of devices attached</span><br><span class="line">20080411	device</span><br></pre></td></tr></table></figure></p>
<p>那么说明连接成功，可以正常进行调试了。</p>
<h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p>
<ul>
<li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li>
<li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li>
<li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li>
<li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li>
<li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li>
</ul>
<p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>
]]></content>
      
        <categories>
            
            <category> Working </category>
            
        </categories>
        
        
        <tags>
            
            <tag> adb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux下脚本录制工具——script和scriptreplay]]></title>
      <url>http://answerywj.com/2016/07/14/script-and-scriptreplay/</url>
      <content type="html"><![CDATA[<p>在Linux开发环境下，想要录制一段屏幕视屏不是特别方便。这里分享给大家一种方便而且快捷的方法。</p>
<hr>
<a id="more"></a>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>Linux下有script和scriptreplay这两个工具组合用于录制命令行。在新版本系统中，已经集成了这两个工具，所以直接使用即可：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ script -t <span class="number">2</span>&gt;timing.log -a &gt;output.session</span><br><span class="line">$ &lt;command&gt;</span><br><span class="line">$ &lt;command&gt;</span><br><span class="line">$ <span class="keyword">exit</span></span><br><span class="line">$ scriptreplay timing.log output.session</span><br></pre></td></tr></table></figure></p>
<p>说明：</p>
<ul>
<li>选项-t用于存储时序文件，这里导入到stderr，再重定向到timing.log。</li>
<li>选项-a用于将命令输出信息，重定向到output.session文件。</li>
<li>这两个文件很小，可以拷贝到需要播放的机器上进行播放。</li>
</ul>
<h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p>
<ul>
<li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li>
<li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li>
<li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li>
<li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li>
<li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li>
</ul>
<p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> script </tag>
            
            <tag> scriptreplay </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux fork炸弹解析]]></title>
      <url>http://answerywj.com/2016/07/14/fork-bomb/</url>
      <content type="html"><![CDATA[<p><strong>:(){ :|: &amp; };:</strong>是一个bash函数，以Fork Bomb闻名，是一个拒绝服务攻击 的Linux 系统。如果你好奇地去执行了这个命令，那么赶快重启系统吧~！</p>
<hr>
<a id="more"></a>
<h2 id="命令解析"><a href="#命令解析" class="headerlink" title="命令解析"></a>命令解析</h2><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:()</span><br><span class="line">&#123;</span><br><span class="line">	: <span class="string">| : &amp;</span></span><br><span class="line">&#125;;:</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>：</strong>在这里是一个函数名，我们定义之，并在后面执行它。</li>
<li><strong>：|：&amp;</strong>，：函数的输出通过管道传给另一个冒号函数作为输入，并且在后台执行。</li>
<li><strong>{ };</strong>标识着里面的内容是一个函数主体。</li>
<li>最后一个<strong>：</strong>为定义完成后的一次函数执行。</li>
</ol>
<h2 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h2><ol>
<li>首先需要说明的是<strong>:</strong>是一个shell内置命令，所以上面这段代码只有在bash中才可能产生fork炸弹，因为在其他一些shell中，内置命令的优先级高于函数，所以执行<em>:</em>，总是执行内置命令。（<strong>：</strong>是一个空命令，while true等同于 while <strong>：</strong>，常用作占位符）</li>
<li>先来看看函数的主体<strong>：|：&amp;</strong>，使用管道的时候是两个进程同时开始执行。</li>
<li>所以当执行一个<strong>：</strong>函数时，产生两个新进程，然后一个原来的进程退出，这样不停地递归下去，就产生了一个无限递归。按照这个增长模式的化，其增长趋势约为$2^n$。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Linux中还有很多这样存在这陷阱的命令，这也正是我喜欢Linux系统的原因，充满着探索性。</p>
<h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p>
<ul>
<li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li>
<li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li>
<li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li>
<li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li>
<li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li>
</ul>
<p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> fork bomb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Github徽章整理]]></title>
      <url>http://answerywj.com/2016/07/08/badges-of-github/</url>
      <content type="html"><![CDATA[<p> 相信很多在Github上玩耍过的同学们都会发现，在很多项目的README里会有各式各样的徽章，是不是顿时感觉到很高上大？没关系，读完这篇文章你就也可以拥有这些徽章了，甚至可以定制自己的徽章。</p>
<hr>
<a id="more"></a>
<h2 id="NodeJs"><a href="#NodeJs" class="headerlink" title="NodeJs"></a>NodeJs</h2><p>如果这是一个用npm管理的一个包,请添加：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">版本图片</span>](<span class="link">https://www.npmjs.com/package/项目名</span>)</span><br></pre></td></tr></table></figure></p>
<p>如果你使用了第三方的组件,那可以<a href="https://david-dm.org/" target="_blank" rel="noopener">标识</a>是否为最新版本。</p>
<h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><p>如果你是TypeScript开发者,那么请把下面的这些徽章用起来吧：  </p>
<p><a href="https://github.com/ellerbrock/typescript-badges/" target="_blank" rel="noopener"><img src="https://badges.frapsoft.com/typescript/love/typescript.svg?v=101" alt="TypeScript"></a><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">![TypeScript</span>](<span class="link">https://badges.frapsoft.com/typescript/love/typescript.svg?v=101</span>)](<span class="link">https://github.com/ellerbrock/typescript-badges/</span>)</span><br></pre></td></tr></table></figure></p>
<p><a href="https://github.com/ellerbrock/typescript-badges/" target="_blank" rel="noopener"><img src="https://badges.frapsoft.com/typescript/code/typescript.svg?v=101" alt="TypeScript"></a><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">![TypeScript</span>](<span class="link">https://badges.frapsoft.com/typescript/code/typescript.svg?v=101</span>)](<span class="link">https://github.com/ellerbrock/typescript-badges/</span>)</span><br></pre></td></tr></table></figure></p>
<p><a href="https://github.com/ellerbrock/typescript-badges/" target="_blank" rel="noopener"><img src="https://badges.frapsoft.com/typescript/awesome/typescript.png?v=101" alt="TypeScript"></a><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">![TypeScript</span>](<span class="link">https://badges.frapsoft.com/typescript/awesome/typescript.png?v=101</span>)](<span class="link">https://github.com/ellerbrock/typescript-badges/</span>)</span><br></pre></td></tr></table></figure></p>
<p><a href="https://github.com/ellerbrock/typescript-badges/" target="_blank" rel="noopener"><img src="https://badges.frapsoft.com/typescript/version/typescript-v18.svg?v=101" alt="TypeScript"></a><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">![TypeScript</span>](<span class="link">https://badges.frapsoft.com/typescript/version/typescript-v18.svg?v=101</span>)](<span class="link">https://github.com/ellerbrock/typescript-badges/</span>)</span><br></pre></td></tr></table></figure></p>
<p>还有更多的格式与尺寸详见<a href="https://github.com/ellerbrock/typescript-badges/" target="_blank" rel="noopener">这里</a>。</p>
<h2 id="awesome"><a href="#awesome" class="headerlink" title="awesome"></a>awesome</h2><p>如果你是<a href="https://github.com/sindresorhus/awesome" target="_blank" rel="noopener">awesome</a>系列的项目,那可以添加awesome徽章：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">图片</span>](<span class="link">https://github.com/sindresorhus/awesome</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="Google-Analytics"><a href="#Google-Analytics" class="headerlink" title="Google Analytics"></a>Google Analytics</h2><p>Google Analytics是通过嵌入图像追踪项目访问量的一种方法。<br>如<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">我</a>的<a href="https://github.com/AnSwErYWJ/DogFood" target="_blank" rel="noopener">DogFood</a>项目就内嵌了一个追踪图像：<br><a href="https://github.com/AnSwErYWJ/DogFood" target="_blank" rel="noopener"><img src="https://ga-beacon.appspot.com/UA-79885141-1/welcome-page" alt="Analytics"></a></p>
<p>具体制作过程可以<a href="https://github.com/igrigorik/ga-beacon" target="_blank" rel="noopener">参考</a>。</p>
<h2 id="Gitter"><a href="#Gitter" class="headerlink" title="Gitter"></a>Gitter</h2><p>这是对issue功能的一个补充。正常情况下，当你给某个项目提出问题时，需要新建一个issue提出，并且需要等待开发者的回复（短则一两天，长则大半年），效率不是很高。而<a href="https://gitter.im" target="_blank" rel="noopener">Gitter</a>就提供了一个实时的聊天室，项目的开发者可以用github账号登陆之，为某个项目创建一个聊天室，然后再项目的Readme中加入如下代码：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">![Gitter</span>](<span class="link">https://badges.gitter.im/Join Chat.svg</span>)](<span class="link">聊天室 URL</span>)</span><br></pre></td></tr></table></figure></p>
<p>就可以显示聊天室的徽章啦：<br><a href="https://gitter.im/AnSwErYWJ/DogFood" target="_blank" rel="noopener"><img src="https://badges.gitter.im/Join Chat.svg" alt="Gitter"></a>  </p>
<p>单击即可进入聊天室，与开发者进行实时沟通。</p>
<h2 id="Code-Related"><a href="#Code-Related" class="headerlink" title="Code Related"></a>Code Related</h2><p>有很多的在线测试平台都提供测试状态标识,你可以把他们放到相应项目中的README中：</p>
<ul>
<li><a href="https://travis-ci.org/getting_started" target="_blank" rel="noopener">Travis Ci</a></li>
<li><a href="https://codecov.io/gh" target="_blank" rel="noopener">Codecov</a></li>
<li><a href="https://codeclimate.com" target="_blank" rel="noopener">Code Climate</a></li>
<li><a href="https://www.bithound.io/" target="_blank" rel="noopener">bithound</a></li>
</ul>
<h2 id="Version-Stability"><a href="#Version-Stability" class="headerlink" title="Version Stability"></a>Version Stability</h2><p><a href="http://github.com/badges/stability-badges" target="_blank" rel="noopener"><img src="http://badges.github.io/stability-badges/dist/deprecated.svg" alt="deprecated"></a><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">![deprecated</span>](<span class="link">http://badges.github.io/stability-badges/dist/deprecated.svg</span>)](<span class="link">http://github.com/badges/stability-badges</span>)</span><br></pre></td></tr></table></figure></p>
<p><a href="http://github.com/badges/stability-badges" target="_blank" rel="noopener"><img src="http://badges.github.io/stability-badges/dist/experimental.svg" alt="experimental"></a><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">![experimental</span>](<span class="link">http://badges.github.io/stability-badges/dist/experimental.svg</span>)](<span class="link">http://github.com/badges/stability-badges</span>)</span><br></pre></td></tr></table></figure></p>
<p><a href="http://github.com/badges/stability-badges" target="_blank" rel="noopener"><img src="http://badges.github.io/stability-badges/dist/unstable.svg" alt="unstable"></a><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">![unstable</span>](<span class="link">http://badges.github.io/stability-badges/dist/unstable.svg</span>)](<span class="link">http://github.com/badges/stability-badges</span>)</span><br></pre></td></tr></table></figure></p>
<p><a href="http://github.com/badges/stability-badges" target="_blank" rel="noopener"><img src="http://badges.github.io/stability-badges/dist/stable.svg" alt="stable"></a><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">![stable</span>](<span class="link">http://badges.github.io/stability-badges/dist/stable.svg</span>)](<span class="link">http://github.com/badges/stability-badges</span>)</span><br></pre></td></tr></table></figure></p>
<p><a href="http://github.com/badges/stability-badges" target="_blank" rel="noopener"><img src="http://badges.github.io/stability-badges/dist/frozen.svg" alt="frozen"></a><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">![frozen</span>](<span class="link">http://badges.github.io/stability-badges/dist/frozen.svg</span>)](<span class="link">http://github.com/badges/stability-badges</span>)</span><br></pre></td></tr></table></figure></p>
<p><a href="http://github.com/badges/stability-badges" target="_blank" rel="noopener"><img src="http://badges.github.io/stability-badges/dist/locked.svg" alt="locked"></a><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">![locked</span>](<span class="link">http://badges.github.io/stability-badges/dist/locked.svg</span>)](<span class="link">http://github.com/badges/stability-badges</span>)</span><br></pre></td></tr></table></figure></p>
<p>更多请看<a href="https://github.com/badges/stability-badges" target="_blank" rel="noopener">这里</a>。</p>
<h2 id="Open-Source"><a href="#Open-Source" class="headerlink" title="Open Source"></a>Open Source</h2><p><a href="https://github.com/ellerbrock/open-source-badge/" target="_blank" rel="noopener"><img src="https://badges.frapsoft.com/os/v1/open-source.svg?v=103" alt="Open Source Love"></a><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">![Open Source Love</span>](<span class="link">https://badges.frapsoft.com/os/v1/open-source.svg?v=103</span>)](<span class="link">https://github.com/ellerbrock/open-source-badge/</span>)</span><br></pre></td></tr></table></figure></p>
<p><a href="https://github.com/ellerbrock/open-source-badge/" target="_blank" rel="noopener"><img src="https://badges.frapsoft.com/os/v2/open-source.svg?v=103" alt="Open Source Love"></a><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">![Open Source Love</span>](<span class="link">https://badges.frapsoft.com/os/v2/open-source.svg?v=103</span>)](<span class="link">https://github.com/ellerbrock/open-source-badge/</span>)</span><br></pre></td></tr></table></figure></p>
<p><a href="https://github.com/ellerbrock/open-source-badge/" target="_blank" rel="noopener"><img src="https://badges.frapsoft.com/os/v3/open-source.svg?v=103" alt="Open Source Love"></a><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">![Open Source Love</span>](<span class="link">https://badges.frapsoft.com/os/v3/open-source.svg?v=103</span>)](<span class="link">https://github.com/ellerbrock/open-source-badge/</span>)</span><br></pre></td></tr></table></figure></p>
<p>还有更多的徽章格式与尺寸详见<a href="https://github.com/ellerbrock/open-source-badges" target="_blank" rel="noopener">这里</a>。</p>
<h2 id="Licences"><a href="#Licences" class="headerlink" title="Licences"></a>Licences</h2><h3 id="Software"><a href="#Software" class="headerlink" title="Software"></a>Software</h3><p>开源软件协议的种类非常多,具体可以参考<a href="https://github.com/ruanyf" target="_blank" rel="noopener">阮一峰</a>的<a href="http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html" target="_blank" rel="noopener">如何选择开源许可证？</a>,本文列举了<a href="https://opensource.org/licenses/mit-license.php" target="_blank" rel="noopener">MIT</a>和<a href="https://opensource.org/licenses/GPL-3.0/" target="_blank" rel="noopener">GPL</a>：</p>
<p><a href="https://opensource.org/licenses/mit-license.php" target="_blank" rel="noopener"><img src="https://badges.frapsoft.com/os/mit/mit.svg?v=103" alt="MIT Licence"></a><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">![MIT Licence</span>](<span class="link">https://badges.frapsoft.com/os/mit/mit.svg?v=103</span>)](<span class="link">https://opensource.org/licenses/mit-license.php</span>)</span><br></pre></td></tr></table></figure></p>
<p><a href="https://opensource.org/licenses/GPL-3.0/" target="_blank" rel="noopener"><img src="https://badges.frapsoft.com/os/gpl/gpl.svg?v=103" alt="GPL Licence"></a><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">![GPL Licence</span>](<span class="link">https://badges.frapsoft.com/os/gpl/gpl.svg?v=103</span>)](<span class="link">https://opensource.org/licenses/GPL-3.0/</span>)</span><br></pre></td></tr></table></figure></p>
<p>还有更多的徽章格式与尺寸详见<a href="https://github.com/ellerbrock/open-source-badges" target="_blank" rel="noopener">这里</a>。</p>
<h3 id="Creative-Commons"><a href="#Creative-Commons" class="headerlink" title="Creative Commons"></a>Creative Commons</h3><p><a href="https://zh.wikipedia.org/wiki/%E5%88%9B%E4%BD%9C%E5%85%B1%E7%94%A8" target="_blank" rel="noopener">知识共享</a>是一系列著作权许可方式，我们可以在<a href="https://creativecommons.org/choose/#metadata" target="_blank" rel="noopener">官网</a>选择自己的许可协议。如我采用了知识共享署名-相同方式共享：  </p>
<p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><p>Github上有一个<a href="https://github.com/boennemann/badges" target="_blank" rel="noopener">badges</a>的仓库,里面收集了一些常用的,大家可以参考一下。</p>
<h2 id="Your-Badges"><a href="#Your-Badges" class="headerlink" title="Your Badges"></a>Your Badges</h2><p>如果你需要自己定制一个徽章的话,可以参考<a href="http://shields.io/" target="_blank" rel="noopener">这里</a>。</p>
<h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p>
<ul>
<li>WebSite：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li>
<li>Email：<a href>yuanweijie1993@gmail.com</a></li>
<li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li>
<li>Blog：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li>
<li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li>
</ul>
<p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>
]]></content>
      
        <categories>
            
            <category> Git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
