<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AnSwEr&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://answerywj.com/"/>
  <updated>2019-03-16T07:13:16.621Z</updated>
  <id>http://answerywj.com/</id>
  
  <author>
    <name>AnSwEr(Weijie Yuan)</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git速查手册（第二版）</title>
    <link href="http://answerywj.com/2019/02/12/my-git-help-v2/"/>
    <id>http://answerywj.com/2019/02/12/my-git-help-v2/</id>
    <published>2019-02-12T04:02:40.000Z</published>
    <updated>2019-03-16T07:13:16.621Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对之前<a href="http://answerywj.com/2016/08/28/Git%E9%80%9F%E6%9F%A5%E6%89%8B%E5%86%8C/">Git速查手册</a>的更新，增加了一些这段时间使用到的命令。</p><hr><a id="more"></a><h2 id="配置git"><a href="#配置git" class="headerlink" title="配置git"></a>配置git</h2><p>笔者使用的是v2.1.0，推荐大家使用v1.8以上的<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">版本</a>。 查看git版本：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="comment">--version</span></span><br></pre></td></tr></table></figure></p><p>配置命令<code>git config</code>分为三个级别：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--system : 系统级,位于 /etc/gitconfig .</span><br><span class="line">--global : 用户级,位于 ~/.gitconfig .</span><br><span class="line">--local : 仓库级,位于 repo/.git<span class="built_in">/config </span>,default并且优先级最高.</span><br></pre></td></tr></table></figure></p><p>首先需要删除global用户信息,防止不同git软件之间的冲突：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git<span class="built_in"> config </span>--global --unset user.name</span><br><span class="line">$ git<span class="built_in"> config </span>--global --unset user.email</span><br></pre></td></tr></table></figure></p><p>设置用户信息.若同时使用gitlab和github,推荐配置local用户信息：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git<span class="built_in"> config </span>--local user.name <span class="string">"username"</span></span><br><span class="line">$ git<span class="built_in"> config </span>--local user.email <span class="string">"email"</span></span><br></pre></td></tr></table></figure></p><p>git支持https和ssh等协议.https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，而ssh支持的原生git协议速度最快。<br>检查本机SSH公钥:<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">ls</span> ~<span class="string">/.ssh</span></span><br></pre></td></tr></table></figure></p><p>若存在,则将<code>id_rsa.pub</code>添加到github的SSH keys中。若不存在,则生成:<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>ssh-keygen -t rsa -C <span class="string">"your_email@youremail.com"</span></span><br></pre></td></tr></table></figure></p><p>当ssh配置完成后，再次检查ssh连接情况：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br><span class="line">Hi! You’ve successfully authenticated, <span class="keyword">but</span> GitHub <span class="keyword">does</span> <span class="keyword">not</span> provide shell access.</span><br></pre></td></tr></table></figure></p><p>若出现上述信息，则表示设置成功。<br>若使用https访问, 则进行如下配置,并且设置超时时间避免重复输入密码：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global http<span class="selector-class">.sslverify</span> false</span><br><span class="line">$ git config --global credential<span class="selector-class">.helper</span> <span class="string">'cache --timeout=3600'</span></span><br></pre></td></tr></table></figure></p><p>设置可视化diff和merge工具, linux系统上推荐使用meld或者diffuse：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git<span class="built_in"> config </span>--global diff.tool meld</span><br><span class="line">$ git<span class="built_in"> config </span>--global merge.tool meld</span><br></pre></td></tr></table></figure></p><p>保存用户名,密码, 避免每次<code>pull/push</code>操作都需要手动输入：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git<span class="built_in"> config </span>--global credential.helper store</span><br><span class="line"><span class="comment"># 执行上免的命令后, 下次操作输入的密码会被保存</span></span><br></pre></td></tr></table></figure></p><p>设置颜色,利于使用：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git<span class="built_in"> config </span>--global color.ui.<span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>设置别名：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git<span class="built_in"> config </span>--global alias checkout co</span><br></pre></td></tr></table></figure></p><blockquote><p>上面的命令将<code>checkout</code>设置为别名<code>co</code>。</p></blockquote><p>最后,查看一下所有的设置：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git<span class="built_in"> config </span>--local --list</span><br><span class="line">$ git<span class="built_in"> config </span>--global --list</span><br><span class="line">$ git<span class="built_in"> config </span>--system --list</span><br></pre></td></tr></table></figure></p><h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><p><img src="http://o9zpdspb3.bkt.clouddn.com/git%E5%B7%A5%E4%BD%9C%E6%B5%81.jpg" alt="工作流"></p><p>工作区就是你的本地仓库文件夹,不过其中的<code>.git</code>目录不属于工作区,而是版本库。里面存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。<br>现在来解释一下前面的添加和提交操作：  </p><ol><li><code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</li><li><code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。<br>因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。</li></ol><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>获取远程仓库：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">clone</span> <span class="title">git</span>@github.com:USERNAME/repo.git</span><br></pre></td></tr></table></figure></p><p>将本地的仓库添加到远程：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>cd repo</span><br><span class="line"><span class="variable">$ </span>git init</span><br><span class="line"><span class="variable">$ </span>git remote add origin git<span class="variable">@github</span>.<span class="symbol">com:</span>USERNAME/repo.git</span><br></pre></td></tr></table></figure></p><blockquote><p><code>origin</code>就是一个名字，是<code>git</code>为你默认创建的指向这个远程代码库的标签。</p></blockquote><p>添加修改:<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">add</span><span class="bash"> &lt;filename&gt; </span></span><br><span class="line">$ git <span class="keyword">add</span><span class="bash"> .  <span class="comment"># 添加当前目录所有修改过的文件  </span></span></span><br><span class="line">$ git <span class="keyword">add</span><span class="bash"> *  <span class="comment"># 递归地添加执行命令时所在的目录中的所有文件</span></span></span><br></pre></td></tr></table></figure></p><p>提交修改:<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git commit -m <span class="string">"commit message"</span></span><br><span class="line"><span class="variable">$ </span>git commit -am <span class="string">"commit message"</span></span><br></pre></td></tr></table></figure></p><blockquote><p><code>commit message</code>的填写可以参考<a href="http://blog.jobbole.com/92713/" target="_blank" rel="noopener">写好 Git Commit 信息的 7 个建议</a>。<br><code>am</code>将添加和提交合并为一步,但只对本来就存在的文件有效。</p></blockquote><p>推送修改：<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">push</span> -u <span class="built_in">origin</span> &lt;<span class="built_in">feature</span>-branch-name&gt;</span><br></pre></td></tr></table></figure></p><blockquote><p><code>-u</code>选项可以将本地分支与远程分支关联,下次<code>git pull</code>操作时可以不带参数.具体参见<a href="http://stackoverflow.com/questions/5697750/what-exactly-does-the-u-do-git-push-u-origin-master-vs-git-push-origin-ma" target="_blank" rel="noopener">这里</a>。</p></blockquote><p>查看远程仓库：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin git@github<span class="selector-class">.com</span>:USERNAME/repo<span class="selector-class">.git</span> (push)</span><br><span class="line">origin git@github<span class="selector-class">.com</span>:USERNAME/repo<span class="selector-class">.git</span> (fetch)</span><br></pre></td></tr></table></figure></p><p>fork后同步上游仓库的更新：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一次需要添加上游仓库</span></span><br><span class="line"><span class="variable">$ </span>git remote add upstream git<span class="variable">@github</span>.<span class="symbol">com:</span>USERNAME/repo.git</span><br><span class="line"> </span><br><span class="line"><span class="variable">$ </span>git remote -v</span><br><span class="line">origin  git<span class="variable">@github</span>.<span class="symbol">com:</span>USERNAME/repo.git (push)</span><br><span class="line">origin  git<span class="variable">@github</span>.<span class="symbol">com:</span>USERNAME/repo.git (fetch)</span><br><span class="line">upstream  git<span class="variable">@github</span>.<span class="symbol">com:</span>USERNAME/repo.git  (push)</span><br><span class="line">upstream  git<span class="variable">@github</span>.<span class="symbol">com:</span>USERNAME/repo.git (fetch)</span><br><span class="line"></span><br><span class="line"><span class="variable">$ </span>git fetch upstream </span><br><span class="line"><span class="variable">$ </span>git difftool &lt;branch-name&gt; upstream/master</span><br><span class="line"><span class="variable">$ </span>git merge upstream/master</span><br><span class="line"><span class="variable">$ </span>git mergetool</span><br></pre></td></tr></table></figure></p><p>引用公共代码：<br>代码引用在git上有两种方式：<code>submodule</code>和<code>subtree</code>，推荐使用<a href="http://aoxuis.me/post/2013-08-06-git-subtree" target="_blank" rel="noopener">subtree</a>方式。<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 第一次初始化</span><br><span class="line">$ git remote <span class="keyword">add </span>-f &lt;remote-<span class="keyword">subtree-repository-name&gt; </span>&lt;remote-<span class="keyword">subtree-repository-url&gt;</span></span><br><span class="line"><span class="keyword">$ </span>git <span class="keyword">subtree </span><span class="keyword">add </span>--prefix=&lt;local-<span class="keyword">subtree-directory&gt; </span>&lt;remote-<span class="keyword">subtree-repository&gt; </span>&lt;remote-<span class="keyword">subtree-branch-name&gt; </span>--squash</span><br><span class="line"></span><br><span class="line"># 同步<span class="keyword">subtree的更新</span></span><br><span class="line"><span class="keyword">$ </span>git <span class="keyword">subtree </span>pull --prefix=&lt;local-<span class="keyword">subtree-directory&gt; </span>&lt;remote-<span class="keyword">subtree-repository&gt; </span>&lt;remote-<span class="keyword">subtree-branch-name&gt; </span>--squash</span><br><span class="line"></span><br><span class="line"># 推送到远程<span class="keyword">subtree库</span></span><br><span class="line"><span class="keyword">$ </span>git <span class="keyword">subtree </span><span class="keyword">push </span>--prefix=&lt;local-<span class="keyword">subtree-directory&gt; </span>&lt;remote-<span class="keyword">subtree-repository&gt; </span>&lt;remote-<span class="keyword">subtree-branch-name&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="使用标签"><a href="#使用标签" class="headerlink" title="使用标签"></a>使用标签</h2><p>查看标签 ：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span></span><br></pre></td></tr></table></figure></p><p>创建标签 ：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span> <span class="title">-a</span> <span class="tag">&lt;tagname&gt;</span> -m <span class="string">"tag message"</span> <span class="comment"># 创建标签在当前最新提交的commit上</span></span><br><span class="line">$ git <span class="keyword">tag</span> <span class="title">-a</span> <span class="tag">&lt;tagname&gt;</span> -m <span class="string">"tag message"</span> <span class="tag">&lt;commit id&gt;</span> <span class="comment"># 创建标签在指定的commit上</span></span><br></pre></td></tr></table></figure></p><p>推送标签到远程：<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">push</span> origin &lt;tagname&gt; <span class="meta"># 推送一个本地标签</span></span><br><span class="line">$ git <span class="keyword">push</span> origin --tags <span class="meta"># 推送全部未推送过的本地标签</span></span><br></pre></td></tr></table></figure></p><p>删除标签：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git tag -d &lt;tagname&gt; <span class="comment"># 删除一个本地标签；</span></span><br><span class="line"><span class="variable">$ </span>git push origin <span class="symbol">:refs/tags/&lt;tagname&gt;</span> <span class="comment"># 删除一个远程标签。</span></span><br></pre></td></tr></table></figure></p><h2 id="撤销与回退"><a href="#撤销与回退" class="headerlink" title="撤销与回退"></a>撤销与回退</h2><p>查看当前仓库状态:<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git status</span><br></pre></td></tr></table></figure></p><p>查看文件更改：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git difftool <span class="tag">&lt;<span class="name">filename</span>&gt;</span></span><br><span class="line">$ git mergetool <span class="tag">&lt;<span class="name">filename</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>查看提交历史:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --pretty=oneline <span class="comment">#只保留commit id 和 commit message</span></span></span><br></pre></td></tr></table></figure></p><p>撤销工作区<code>Tracked files</code>的修改：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout <span class="comment">-- &lt;filename&gt;</span></span><br></pre></td></tr></table></figure></p><p>撤销工作区<code>Untracked files</code>的修改：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#####</span><br><span class="line"># n:查看将会删除的文件，防止误删</span><br><span class="line"># f:Untracked的文件</span><br><span class="line"># d:Untracked的目录</span><br><span class="line"># x:包含gitignore的Untracked文件和目录一并删掉，慎用！</span><br><span class="line">#####</span><br><span class="line"></span><br><span class="line">git clean -nfd</span><br><span class="line">git clean -fd</span><br></pre></td></tr></table></figure></p><p>撤销所有已经提交到暂存区的修改：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">reset</span> <span class="keyword">HEAD</span> .</span><br></pre></td></tr></table></figure></p><p>撤销提交到暂存区的某个文件或文件夹：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">reset</span> <span class="keyword">HEAD</span> -filename</span><br></pre></td></tr></table></figure></p><p>回退版本，即回退暂存区的修改：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">reset</span> <span class="comment">--hard &lt;commit-id&gt;</span></span><br></pre></td></tr></table></figure></p><blockquote><p>上一个版本的<code>commit-id</code>可以用<code>HEAD^</code>表示，上上个版本为<code>HEAD^^</code>，上100个版本可以表示为<code>HEAD~100</code>以此类推。</p></blockquote><p>回退版本后，若需要返回原来的版本，会发现找不到未来的<code>commit id</code>，则需要查看操作命令历史进行查找：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git reflog</span><br></pre></td></tr></table></figure></p><p>从版本库删除文件：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm <span class="tag">&lt;<span class="name">filename</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>若你的代码已经<code>push</code>到线上，则推荐使用下面这个命令回滚：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git revert &lt;commit-<span class="built_in">id</span>&gt;</span><br></pre></td></tr></table></figure></p><blockquote><p><code>revert</code>是用一次新的<code>commit</code>来回滚之前的<code>commit</code>，更安全;<code>reset</code>则是直接删除指定的<code>commit</code>，若直接<code>push</code>会导致冲突。</p></blockquote><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>查看所有分支，有<code>*</code>标记的是当前分支：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">branch </span>-a</span><br></pre></td></tr></table></figure></p><p>创建本地分支：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout &lt;<span class="keyword">new</span><span class="type">branch</span>&gt;</span><br></pre></td></tr></table></figure></p><p>创建并切换本地分支：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b &lt;<span class="keyword">new</span><span class="type">branch</span>&gt;</span><br></pre></td></tr></table></figure></p><p>从标签创建分支：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch <span class="params">&lt;branch&gt;</span> <span class="params">&lt;tagname&gt;</span></span><br><span class="line">$ git checkout <span class="params">&lt;branch&gt;</span> <span class="meta"># 切换到新建分支</span></span><br></pre></td></tr></table></figure></p><p>推送新建本地分支到远程：<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> git push -u origin &lt;remote-branch-name&gt;</span><br><span class="line">  <span class="keyword">or</span></span><br><span class="line"><span class="symbol">$</span> git push --<span class="keyword">set</span>-upstream <span class="comment">origin &lt;remote-branch-name&gt;</span></span><br></pre></td></tr></table></figure></p><p>删除本地分支：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">branch </span>-d &lt;<span class="keyword">branch&gt;</span></span><br></pre></td></tr></table></figure></p><blockquote><p>若当前分支因为有修改未提交或其它情况不能删除，请使用<code>-D</code>选项强制删除。</p></blockquote><p>删除远程分支(三种方法)：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git push origin --delete &lt;remote-branch-name&gt;</span><br><span class="line"><span class="variable">$ </span>git push origin -d &lt;remote-branch-name&gt;</span><br><span class="line"><span class="variable">$ </span>git push origin <span class="symbol">:&lt;remote-branch-name&gt;</span></span><br></pre></td></tr></table></figure></p><p>清除无用的分支：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git remote prune origin</span><br></pre></td></tr></table></figure></p><blockquote><p>说明：remote上的一个分支被其他人删除后，需要更新本地的分支列表。</p></blockquote><p>获取远程分支到本地已有分支：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch --<span class="built_in">set</span>-upstream &lt;<span class="built_in">local</span>-branch&gt; origin/branch</span></span><br></pre></td></tr></table></figure></p><p>获取远程分支到本地并新建本地分支：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -<span class="keyword">b </span>&lt;local-<span class="keyword">branch&gt; </span>&lt;remote-<span class="keyword">branch&gt;</span></span><br></pre></td></tr></table></figure></p><p>同步当前分支的更新，使用<code>git pull</code>并不保险：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载最新的代码到远程跟踪分支, 即origin/&lt;branch-name&gt;</span></span><br><span class="line">$ git fetch <span class="keyword">origin </span>&lt;<span class="keyword">branch-name&gt; </span></span><br><span class="line"><span class="comment"># 查看更新内容</span></span><br><span class="line">$ git <span class="keyword">difftool </span>&lt;<span class="keyword">branch-name&gt; </span><span class="keyword">origin/&lt;branch-name&gt;</span></span><br><span class="line"><span class="keyword"># </span>尝试合并远程跟踪分支的代码到本地分支 </span><br><span class="line">$ git merge <span class="keyword">origin/&lt;branch-name&gt;</span></span><br><span class="line"><span class="keyword"># </span>借助mergetool解决冲突              </span><br><span class="line">$ git mergetool</span><br></pre></td></tr></table></figure></p><p>同步其它分支的更新，本例拉取<code>master</code>分支更新：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin <span class="literal">master</span></span><br><span class="line">$ git difftool <span class="tag">&lt;branch-name&gt;</span> origin/<span class="literal">master</span></span><br><span class="line">$ git merge origin/<span class="literal">master</span></span><br><span class="line">$ git mergetool</span><br></pre></td></tr></table></figure></p><h2 id="暂存"><a href="#暂存" class="headerlink" title="暂存"></a>暂存</h2><p>当你需要切换分支时,若当前工作区还有些修改没有完成,又不适合提交的,操作切换分支是会提示出错的.这时就需要将这些修改暂存起来:<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git stash save <span class="string">"message"</span></span><br></pre></td></tr></table></figure></p><p>查看:<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash <span class="built_in">list</span></span><br></pre></td></tr></table></figure></p><p>恢复:<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git stash <span class="keyword">pop</span> [--<span class="keyword">index</span>] [stash@&#123;num&#125;]　</span><br><span class="line">  <span class="keyword">or</span></span><br><span class="line">$ git stash apply [--<span class="keyword">index</span>] [stash@&#123;num&#125;]　<span class="comment"># 不删除已恢复的进度.</span></span><br></pre></td></tr></table></figure></p><blockquote><p><code>--index</code>表示不仅恢复工作区,还会恢复暂存区;<code>num</code>是你要恢复的操作的序列号,默认恢复最新进度.</p></blockquote><p>删除进度:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash <span class="keyword">drop</span> [stash@&#123;<span class="keyword">num</span>&#125;] <span class="comment"># 删除指定进度</span></span><br><span class="line">$ git stash <span class="keyword">clear</span> <span class="comment"># 删除所有</span></span><br></pre></td></tr></table></figure></p><h2 id="清理本地仓库"><a href="#清理本地仓库" class="headerlink" title="清理本地仓库"></a>清理本地仓库</h2><ul><li><p>检查是否有无用的大文件。</p></li><li><p>清理无用的分支和标签：</p>  <figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d <span class="tag">&lt;branch-name&gt;</span></span><br><span class="line">$ git <span class="keyword">tag</span> <span class="title">-d</span> <span class="tag">&lt;tag-name&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>清理<code>.git</code>目录，一般本地仓库过大都是由于存在过多的<code>loose object</code>:</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git gc <span class="attribute">--prune</span>=now</span><br></pre></td></tr></table></figure><blockquote><p>tips: 在执行<code>push</code>操作时，<code>git</code>会自动执行一次<code>gc</code>操作，不过只有<code>loose object</code>达到一定数量后才会真正调用，建议手动执行。</p></blockquote></li></ul><h2 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h2><p>当你的仓库中有一些文件，类似密码或者数据库文件不需要提交但又必须放在仓库目录下，每次<code>git status</code>都会提示<code>Untracked</code>，看着让人很不爽，提供两种方法解决这个问题</p><h3 id="本地"><a href="#本地" class="headerlink" title="本地"></a>本地</h3><p>在代码仓库目录创建一个<code>.gitignore</code>文件，编写规则如下：<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tmp/  <span class="comment"># 忽略tmp文件夹下所有内容</span></span><br><span class="line">*<span class="string">.ini</span> <span class="comment"># 忽略所有ini文件</span></span><br><span class="line">!data/ <span class="comment">#忽略除了data文件夹的所有内容</span></span><br></pre></td></tr></table></figure></p><h3 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h3><p>在用户目录创建一个<code>.gitignore_global</code>文件，编写规则同<code>.gitignore</code>，并修改<code>~/.gitconfig</code><br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[core]</span></span><br><span class="line">excludesfile = ~/.gitignore_global</span><br></pre></td></tr></table></figure></p><p>如果添加的忽略对象已经<code>Tracked</code>，纳入了版本管理中，则需要在代码仓库中先把本地缓存删除,改变成<code>Untracked</code>状态<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm -r <span class="comment">--cached .</span></span><br></pre></td></tr></table></figure></p><blockquote><p><a href="https://github.com/github/gitignore" target="_blank" rel="noopener"><code>.gitignore</code>模版</a></p></blockquote><h2 id="处理大型二进制文件"><a href="#处理大型二进制文件" class="headerlink" title="处理大型二进制文件"></a>处理大型二进制文件</h2><p>由于git在存储二进制文件时效率不高,所以需要借助<a href="http://www.oschina.net/news/71365/git-annex-lfs-bigfiles-fat-media-bigstore-sym" target="_blank" rel="noopener">第三方组件</a>。</p><h2 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h2><p>查看帮助：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git --<span class="built_in">help</span></span></span><br></pre></td></tr></table></figure></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰老师的git教程</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">常用Git命令清单</a></li><li><a href="https://git-scm.com/book/en/v2" target="_blank" rel="noopener">Git-Book</a></li><li><a href="https://git-scm.com/docs" target="_blank" rel="noopener">Git-Reference</a></li><li><a href="https://segmentfault.com/a/1190000002783245" target="_blank" rel="noopener">Git push与pull的默认行为</a></li><li><a href="http://www.tuicool.com/articles/rUBNBvI" target="_blank" rel="noopener">git stash 详解</a></li></ol><h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p><ul><li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li><li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li><li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li><li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li><li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li></ul><p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是对之前&lt;a href=&quot;http://answerywj.com/2016/08/28/Git%E9%80%9F%E6%9F%A5%E6%89%8B%E5%86%8C/&quot;&gt;Git速查手册&lt;/a&gt;的更新，增加了一些这段时间使用到的命令。&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Git" scheme="http://answerywj.com/categories/Git/"/>
    
    
      <category term="git" scheme="http://answerywj.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Daily Record</title>
    <link href="http://answerywj.com/2018/10/16/daily-record/"/>
    <id>http://answerywj.com/2018/10/16/daily-record/</id>
    <published>2018-10-16T02:39:14.000Z</published>
    <updated>2019-03-16T07:13:16.577Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要整理日常遇到的问题</p><hr><a id="more"></a><h2 id="2018-03-27"><a href="#2018-03-27" class="headerlink" title="2018.03.27"></a>2018.03.27</h2><ol><li>结构体初始化后需要进行清空<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mg_send_mqtt_handshake_opts</span> <span class="title">opts</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;opts, <span class="number">0</span>, <span class="keyword">sizeof</span>(opts));</span><br></pre></td></tr></table></figure></li></ol><h2 id="2018-03-28"><a href="#2018-03-28" class="headerlink" title="2018.03.28"></a>2018.03.28</h2><ol><li>宏定义与函数名冲突，若宏定义在函数名的声明或定义之前，则会进行字符串替换，导致编译会报错</li><li>MQTT QOS 学习<figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">qos 0</span>: 最多分发一次，消息可能送达一次也可能根本没送达，取决于底层的网络能力，接收者不会响应，发送者不会重发</span><br><span class="line"></span><br><span class="line"><span class="attribute">qos 1</span>: 至少分发一次，服务质量确保消息至少送达一次，需要PUBACK报文确认</span><br><span class="line"></span><br><span class="line"><span class="attribute">qos 2</span>: 仅分发一次，最高等级的服务质量，消息丢失和重复都是不可接受的</span><br></pre></td></tr></table></figure></li></ol><h2 id="2018-05-29"><a href="#2018-05-29" class="headerlink" title="2018.05.29"></a>2018.05.29</h2><ol><li>布尔值变量的命名尽量使用如下规则：<code>is_xxx</code></li><li><code>lua</code>字符串拼接操作：若存在大量的字符串拼接操作，如循环等，不要使用<code>..</code>，因为每次都会申请临时内存，新建一个新的字符串，会导致内存来不及回收，可以使用<code>table.insert + table.contact</code></li><li><code>sscanf</code>可以进行字符串分割和字符串数字转数字等，很强大！！！</li></ol><h2 id="2018-07-19"><a href="#2018-07-19" class="headerlink" title="2018.07.19"></a>2018.07.19</h2><ol><li>两个库有相同的符号，同时链接的话，运行时可能串库调用</li></ol><h2 id="2018-08-17"><a href="#2018-08-17" class="headerlink" title="2018.08.17"></a>2018.08.17</h2><ol><li>越界访问内存导致<code>free</code>失败的原因</li></ol><p><code>molloc</code>一块内存，在<code>free</code>的时候只需要传递指针首地址操作系统(或者说C语言)就可以对内存进行释放，那么它是怎么知道应该释放多大的内存呢?<br>其实C语言是维护了一个数据结构类似如下的结构，这个结构中主要有两个数据：一个是当前内存块的大小，另外一个是指向下一个空闲内存块：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="class"><span class="keyword">struct</span> <span class="title">Header</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> <span class="title">header</span> *<span class="title">ptr</span>;</span> /*<span class="keyword">next</span> block <span class="keyword">if</span> on free list*<span class="regexp">/</span></span><br><span class="line"><span class="regexp">        unsigned size; /</span>*size <span class="keyword">of</span> this block*<span class="regexp">/</span></span><br><span class="line"><span class="regexp">    &#125; header;</span></span><br></pre></td></tr></table></figure></p><p>其实我们在<code>molloc(10)</code>一块内存的时候，真正申请的不止是<code>10</code>个字节大小的内存，而是要加上一个<code>struct Header</code>结构体的大小，<code>molloc</code>返回给我们的内存想当于是p+sizeof(Header)的指针，而在free的时候，则C语言只需要将<code>p-sizeof(Header)</code>就能找到<code>header</code>结构，从而知道内存块大小。</p><h2 id="2018-10-16"><a href="#2018-10-16" class="headerlink" title="2018.10.16"></a>2018.10.16</h2><ol><li>使用<code>valgrind</code>对可执行程序做内存检查，发现会存在<code>still reachable</code>的问题，可排除编码的问题。<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valgrind <span class="attribute">--tool</span>=memcheck <span class="attribute">--leak-check</span>=<span class="literal">yes</span> <span class="attribute">--show-reachable</span>=<span class="literal">yes</span> <span class="attribute">--track-origins</span>=<span class="literal">yes</span> a.out</span><br></pre></td></tr></table></figure></li></ol><p>查阅资料发现，许多<code>C++</code>库都实现了自己的内存分配管理器，在内存释放时不是将其直接还给系统，而是留在内存池中供下次使用，这导致程序退出时会被检测到<code>still reachable</code>。将使用<code>C++</code>库的地方去除再次验证，无该错误。<br>参考：<a href="https://stackoverflow.com/questions/30376601/valgrind-memory-still-reachable-with-trivial-program-using-iostream" target="_blank" rel="noopener">https://stackoverflow.com/questions/30376601/valgrind-memory-still-reachable-with-trivial-program-using-iostream</a></p><h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p><ul><li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li><li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li><li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li><li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li><li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li></ul><p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要整理日常遇到的问题&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Working" scheme="http://answerywj.com/categories/Working/"/>
    
    
      <category term="record" scheme="http://answerywj.com/tags/record/"/>
    
  </entry>
  
  <entry>
    <title>C代码覆盖率测试工具Gcov</title>
    <link href="http://answerywj.com/2018/09/25/coverage-of-c/"/>
    <id>http://answerywj.com/2018/09/25/coverage-of-c/</id>
    <published>2018-09-25T10:48:49.000Z</published>
    <updated>2019-03-16T07:13:16.573Z</updated>
    
    <content type="html"><![CDATA[<p>代码覆盖率测试反映了测试的广度与深度，量化了测试和开发质量，是十分有必要的，业界目前有针对各种语言的覆盖率测试工具，本文主要介绍<code>C/C++</code>相关的覆盖率测试工具<code>Gcov</code><br><a id="more"></a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>Gcov</code>是一个测试覆盖程序，是集成在<code>GCC</code>中的，随<code>GCC</code>一起发布</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="基本块BB"><a href="#基本块BB" class="headerlink" title="基本块BB"></a>基本块BB</h4><p>基本块指一段程序的第一条语句被执行过一次后，这段程序中的每一跳语句都需要执行一次，称为基本块，因此基本块中的所有语句的执行次数是相同的，一般由多个顺序执行语句后边跟一个跳转语句组成</p><h4 id="跳转ARC"><a href="#跳转ARC" class="headerlink" title="跳转ARC"></a>跳转ARC</h4><p>从一个<code>BB</code>到另外一个<code>BB</code>的跳转叫做一个<code>ARC</code>,要想知道程序中的每个语句和分支的执行次数，就必须知道每个<code>BB</code>和<code>ARC</code>的执行次数</p><h4 id="程序流图"><a href="#程序流图" class="headerlink" title="程序流图"></a>程序流图</h4><p>如果把<code>BB</code>作为一个节点，这样一个函数中的所有<code>BB</code>就构成了一个有向图，要想知道程序中的每个语句和分支的执行次数，就必须知道每个<code>BB</code>和<code>ARC</code>的执行次数，根据图论可以知道有向图中<code>BB</code>的入度和出度是相同的，所以只要知道了部分的<code>BB</code>或者<code>ARC</code>大小，就可以推断所有的大小，这里选择由<code>ARC</code>的执行次数来推断<code>BB</code>的执行次数，所以对部分<code>ARC</code>插桩，只要满足可以统计出来所有的<code>BB</code>和<code>ARC</code>的执行次数即可</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>测试程序首先进行编译预处理，生成汇编文件，并完成插桩，插桩的过程中会向源文件的末尾插入一个静态数组，数组的大小就是这个源文件中桩点的个数，数组的值就是桩点的执行次数，每个桩点插入3~4条汇编语句，直接插入生成的<code>*.s</code>文件中，最后汇编文件经过汇编生成目标文件，在程序运行过程中桩点负责收集程序的执行信息</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>测试代码如下：<br><code>say.c</code>:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">say</span><span class="params">(<span class="keyword">char</span> *what)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"------ %s\n"</span>, what);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>main.c</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">say</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">1</span>]) &#123;</span><br><span class="line">        say(<span class="string">"hello"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        say(<span class="string">"bye"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>添加<code>-fprofile-arcs -ftest-coverage -fPIC</code>编译参数编译程序，生成可执行程序和<code>*.gcno</code>文件，里面记录了行信息和程序流图信息：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -fprofile-arcs -ftest-coverage -fPIC -O0 say<span class="selector-class">.c</span> main.c</span><br><span class="line"></span><br><span class="line">$ ls</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-class">.out</span>  main<span class="selector-class">.c</span>  main<span class="selector-class">.gcno</span>  say<span class="selector-class">.c</span>  say.gcno</span><br></pre></td></tr></table></figure></p><h3 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h3><p>运行可执行文件，生成<code>*.gcda</code>在默认生成在相应<code>*.o</code>文件目录，里面记录了<code>*.c</code>文件中程序的执行情况，包括跳变次数等:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./<span class="selector-tag">a</span>.out</span><br><span class="line">------ bye</span><br><span class="line"></span><br><span class="line">$ ls</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-class">.out</span>  main<span class="selector-class">.c</span>  main<span class="selector-class">.gcda</span>  main<span class="selector-class">.gcno</span>  say<span class="selector-class">.c</span>  say<span class="selector-class">.gcda</span>  say.gcno</span><br></pre></td></tr></table></figure></p><p>可以通过设置环境变量<code>GCOV_PREFIX=/xxx/xxx</code>和<code>GCOV_PREFIX_STRIP=x</code>来改变路径，其中<code>GCOV_PREFIX_STRIP</code>表示去掉源代码路径中的前几级，默认为<code>0</code>，比如源代码路径为<code>/a/b/c/d.c</code>，<code>GCOV_PREFIX_STRIP=2</code>，则实际使用的路径是<code>c/d.c</code>，如果<code>GCOV_PREFIX=/e/f</code>，则<code>.gcda</code>实际存放的路径是<code>/e/f/c/d.gcda</code></p><h3 id="报告生成"><a href="#报告生成" class="headerlink" title="报告生成"></a>报告生成</h3><p>针对某一个文件的执行情况，可以通过如下命令生成报告，并创建<code>*.gcov</code>文件：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gcov -<span class="selector-tag">a</span> main.c</span><br><span class="line">File <span class="string">'main.c'</span></span><br><span class="line">Lines executed:<span class="number">80.00%</span> of <span class="number">5</span></span><br><span class="line">Creating <span class="string">'main.c.gcov'</span></span><br></pre></td></tr></table></figure></p><p>常用选项，更多可参考<a href="https://gcc.gnu.org/onlinedocs/gcc/Invoking-Gcov.html#Invoking-Gcov" target="_blank" rel="noopener">Invoking gcov</a>：<br><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-b：分支覆盖</span></span><br><span class="line"><span class="deletion">-a：所有基本块覆盖</span></span><br><span class="line"><span class="deletion">-f：函数覆盖</span></span><br></pre></td></tr></table></figure></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>在编译时不要加优化选项，否则代码会发生变化，无法准确定位</li><li>代码中复杂的宏，比如宏展开后是循环或者其他控制结构，可以用内联函数来代替，因为<code>gcov</code>只统计宏调用出现的那一行</li><li>代码每一行最好只有一条语句</li><li><code>*.gcno</code>与<code>*.gcda</code>需要匹配，两个文件是有时间戳来记录是不是匹配的</li><li>若是编译动态库，需要在链接时<code>-lgcov</code></li></ol><h3 id="图形化展示"><a href="#图形化展示" class="headerlink" title="图形化展示"></a>图形化展示</h3><p><code>gcov</code>生成的报告分散在各个源码文件所对应的<code>*.gcov</code>文件中，难以汇总分析，并且可视化效果较差，所以需要转化成可视图形化报告，有<code>lcov</code>或<code>gcovr</code>两个工具可以完成，两者功能基本相同，本文主要介绍<code>gcovr</code>，是一个用<code>Python</code>编写的开源软件，大小只有几十KB，安装参见<a href="https://gcovr.com/installation.html" target="_blank" rel="noopener">官网</a></p><h4 id="列表形式"><a href="#列表形式" class="headerlink" title="列表形式"></a>列表形式</h4><ol><li>代码覆盖率<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ gcovr -r .</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line"><span class="code">                           GCC Code Coverage Report</span></span><br><span class="line">Directory: .</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">File                                       Lines    Exec  Cover   Missing</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">main.c                                         5       4    80%   15</span><br><span class="line">say.c                                          3       3   100%   </span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">TOTAL                                          8       7    87%</span><br><span class="line">------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure></li></ol><p>报告展示程序运行后覆盖了<code>80%</code>的代码</p><ol start="2"><li>分支覆盖率<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ gcovr -b -r .</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line"><span class="code">                           GCC Code Coverage Report</span></span><br><span class="line">Directory: .</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">File                                    Branches   Taken  Cover   Missing</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">main.c                                         2       1    50%   14</span><br><span class="line">say.c                                          0       0    --%   </span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">TOTAL                                          2       1    50%</span><br><span class="line">------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure></li></ol><p>报告展示了在<code>main.c</code>中有一个分支没有执行到</p><h4 id="XML文件形式"><a href="#XML文件形式" class="headerlink" title="XML文件形式"></a>XML文件形式</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">$ gcovr --xml-pretty -r .</span><br><span class="line"><span class="meta">&lt;?xml version="1.0" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE coverage</span></span><br><span class="line"><span class="meta">  SYSTEM 'http://cobertura.sourceforge.net/xml/coverage-04.dtd'&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">coverage</span> <span class="attr">branch-rate</span>=<span class="string">"0.5"</span> <span class="attr">branches-covered</span>=<span class="string">"1"</span> <span class="attr">branches-valid</span>=<span class="string">"2"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">complexity</span>=<span class="string">"0.0"</span> <span class="attr">line-rate</span>=<span class="string">"0.875"</span> <span class="attr">lines-covered</span>=<span class="string">"7"</span> <span class="attr">lines-valid</span>=<span class="string">"8"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">timestamp</span>=<span class="string">"1537930892"</span> <span class="attr">version</span>=<span class="string">"gcovr 3.4"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">sources</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span>&gt;</span>.<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">sources</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">packages</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">package</span> <span class="attr">branch-rate</span>=<span class="string">"0.5"</span> <span class="attr">complexity</span>=<span class="string">"0.0"</span> <span class="attr">line-rate</span>=<span class="string">"0.875"</span> <span class="attr">name</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">classes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">branch-rate</span>=<span class="string">"0.5"</span> <span class="attr">complexity</span>=<span class="string">"0.0"</span> <span class="attr">filename</span>=<span class="string">"main.c"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">line-rate</span>=<span class="string">"0.8"</span> <span class="attr">name</span>=<span class="string">"main_c"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">methods</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">lines</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">line</span> <span class="attr">branch</span>=<span class="string">"false"</span> <span class="attr">hits</span>=<span class="string">"1"</span> <span class="attr">number</span>=<span class="string">"12"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">line</span> <span class="attr">branch</span>=<span class="string">"true"</span> <span class="attr">condition-coverage</span>=<span class="string">"50% (1/2)"</span> <span class="attr">hits</span>=<span class="string">"1"</span> <span class="attr">number</span>=<span class="string">"14"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">conditions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">condition</span> <span class="attr">coverage</span>=<span class="string">"50%"</span> <span class="attr">number</span>=<span class="string">"0"</span> <span class="attr">type</span>=<span class="string">"jump"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">conditions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">line</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">line</span> <span class="attr">branch</span>=<span class="string">"false"</span> <span class="attr">hits</span>=<span class="string">"0"</span> <span class="attr">number</span>=<span class="string">"15"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">line</span> <span class="attr">branch</span>=<span class="string">"false"</span> <span class="attr">hits</span>=<span class="string">"1"</span> <span class="attr">number</span>=<span class="string">"17"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">line</span> <span class="attr">branch</span>=<span class="string">"false"</span> <span class="attr">hits</span>=<span class="string">"1"</span> <span class="attr">number</span>=<span class="string">"19"</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">lines</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">branch-rate</span>=<span class="string">"0.0"</span> <span class="attr">complexity</span>=<span class="string">"0.0"</span> <span class="attr">filename</span>=<span class="string">"say.c"</span> <span class="attr">line-rate</span>=<span class="string">"1.0"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">name</span>=<span class="string">"say_c"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">methods</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">lines</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">line</span> <span class="attr">branch</span>=<span class="string">"false"</span> <span class="attr">hits</span>=<span class="string">"1"</span> <span class="attr">number</span>=<span class="string">"10"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">line</span> <span class="attr">branch</span>=<span class="string">"false"</span> <span class="attr">hits</span>=<span class="string">"1"</span> <span class="attr">number</span>=<span class="string">"11"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">line</span> <span class="attr">branch</span>=<span class="string">"false"</span> <span class="attr">hits</span>=<span class="string">"1"</span> <span class="attr">number</span>=<span class="string">"12"</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">lines</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">classes</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">packages</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">coverage</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="HTML文件形式"><a href="#HTML文件形式" class="headerlink" title="HTML文件形式"></a>HTML文件形式</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcovr -r . --<span class="selector-tag">html</span> -o xxx.html</span><br><span class="line">$ ls</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-class">.out</span>  main<span class="selector-class">.c</span>  main<span class="selector-class">.gcda</span>  main<span class="selector-class">.gcno</span>  say<span class="selector-class">.c</span>  say<span class="selector-class">.gcda</span>  say<span class="selector-class">.gcno</span>  xxx.html</span><br></pre></td></tr></table></figure><p>可以发现添加<code>--html</code>参数后，可以生成<code>html</code>文件，用浏览器打开，如下图：<br><img src="http://o9zpdspb3.bkt.clouddn.com/gcovr_xxx.png" alt="gcovr_xxx.png"></p><p>还可以添加<code>--html-details</code>选项，为每个代码文件单独生成<code>html</code><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcovr -r . --<span class="selector-tag">html</span> --html-<span class="selector-tag">details</span> -o xxx.html</span><br><span class="line">$ ls</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-class">.out</span>  main<span class="selector-class">.c</span>  main<span class="selector-class">.gcda</span>  main<span class="selector-class">.gcno</span>  say<span class="selector-class">.c</span>  say<span class="selector-class">.gcda</span>  say<span class="selector-class">.gcno</span>  xxx<span class="selector-class">.html</span>  xxx<span class="selector-class">.main</span><span class="selector-class">.c</span><span class="selector-class">.html</span>  xxx<span class="selector-class">.say</span><span class="selector-class">.c</span><span class="selector-class">.html</span></span><br></pre></td></tr></table></figure></p><p>可以发现多了<code>xxx.main.c.html</code>和<code>xxx.say.c.html</code>，用浏览器打开<code>xxx.html</code>，如下图：<br><img src="http://o9zpdspb3.bkt.clouddn.com/gcovr_xxx_detail.png" alt="gcovr_xxx_detail.png"><br>文件名较之前带上了下划线，单击文件名，可以看到具体的代码覆盖情况，如下图：<br><img src="http://o9zpdspb3.bkt.clouddn.com/gcovr_xxx_main.png" alt="gcovr_xxx_main.png"></p><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>其它功能，如<code>Filters</code>等，可以参考<a href="https://gcovr.com/guide.html" target="_blank" rel="noopener">官方文档</a></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://gcc.gnu.org/onlinedocs/gcc/Gcov.html#Gcov" target="_blank" rel="noopener">gcov—a Test Coverage Program</a></li><li><a href="https://blog.csdn.net/bryanlai0720/article/details/38729535" target="_blank" rel="noopener">关于C++ code coverage tool 的研究 —GCOV 实现原理</a></li><li><a href="https://gcovr.com/installation.html" target="_blank" rel="noopener">gcovr官网</a></li></ul><h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p><ul><li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li><li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li><li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li><li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li><li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li></ul><p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代码覆盖率测试反映了测试的广度与深度，量化了测试和开发质量，是十分有必要的，业界目前有针对各种语言的覆盖率测试工具，本文主要介绍&lt;code&gt;C/C++&lt;/code&gt;相关的覆盖率测试工具&lt;code&gt;Gcov&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="C" scheme="http://answerywj.com/categories/C/"/>
    
    
      <category term="代码覆盖率" scheme="http://answerywj.com/tags/%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>cJSON的秘密</title>
    <link href="http://answerywj.com/2018/05/03/introduction-of-cjson/"/>
    <id>http://answerywj.com/2018/05/03/introduction-of-cjson/</id>
    <published>2018-05-03T08:58:02.000Z</published>
    <updated>2019-03-16T07:13:16.601Z</updated>
    
    <content type="html"><![CDATA[<p>学习使用cJSON过程的一些发现和总结，不涉及具体的函数<br><a id="more"></a></p><h2 id="cJSON简介"><a href="#cJSON简介" class="headerlink" title="cJSON简介"></a>cJSON简介</h2><p><code>cJSON</code>是一个快速，高性能的<code>json</code>解析器，由<code>C</code>语言编写，仅包含<code>cJSON.c</code>和<code>cJSON.h</code>两个文件，不支持跨平台；跨平台推荐纯<code>lua</code>写的<a href="http://dkolf.de/src/dkjson-lua.fsl/home" target="_blank" rel="noopener"><code>dkjson</code></a></p><h2 id="cJSON结构体"><a href="#cJSON结构体" class="headerlink" title="cJSON结构体"></a>cJSON结构体</h2><p><code>cJSON</code>结构体的组成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cJSON</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cJSON</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cJSON</span> *<span class="title">child</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *valuestring;</span><br><span class="line"><span class="keyword">int</span> valueint;</span><br><span class="line"><span class="keyword">double</span> valuedouble;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *<span class="built_in">string</span>;</span><br><span class="line">&#125; cJSON;</span><br></pre></td></tr></table></figure><p>其中</p><ul><li><code>next</code>指向链表中下一个兄弟节点，<code>prev</code>指向本节点前一个节点</li><li><code>child</code>节点只有对象和数组有，并且<code>child</code>节点是双向链表的头节点，<code>child</code>的<code>prev</code>一般为<code>NULL</code>，不指向任何节点，双向链表的最后一个兄弟节点的<code>next</code>是无指向的</li><li><code>type</code>取值有<code>Null/True/False/Number/String/Array/Object</code>，这些值类型都在<code>cJSON.h</code>中通过宏定义了</li><li><code>String</code>类型节点有<code>valuestring</code>，<code>Number</code>类型节点有<code>valueint</code>和<code>valuedouble</code></li><li><code>string</code>表示节点的名称，所有的节点都是一个链表，都具有<code>string</code>值</li></ul><blockquote><p><code>cJSON</code>默认所有值都为<code>0</code>，除非额外为其赋有意义的值</p></blockquote><h3 id="cJSON树结构"><a href="#cJSON树结构" class="headerlink" title="cJSON树结构"></a>cJSON树结构</h3><p><code>cJSON</code>使用树结构存储<code>JSON</code>的各个节点，而这个树结构是使用双向链表实现的(实线表示节点间有真实的引用关系，而虚线表示逻辑上的引用关系)：<br><img src="http://o9zpdspb3.bkt.clouddn.com/cJSON%E6%A0%91%E7%8A%B6%E7%BB%93%E6%9E%84.png" alt="cJSON树结构"></p><ul><li>树结构的每一层都是一个双向链表，表示一堆兄弟节点</li><li>当前层的所有节点都是当前链表头节点的父节点的子节点</li></ul><p>下面举例说明：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"Jack (\"Bee\") Nimble"</span>, </span><br><span class="line">    <span class="attr">"format"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>:       <span class="string">"rect"</span>, </span><br><span class="line">        <span class="attr">"width"</span>:      <span class="number">1920</span>, </span><br><span class="line">        <span class="attr">"height"</span>:     <span class="number">1080</span>, </span><br><span class="line">        <span class="attr">"interlace"</span>:  <span class="literal">false</span>, </span><br><span class="line">        <span class="attr">"frame rate"</span>: <span class="number">24</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>name</code>和<code>format</code>节点组成一个链表，<code>type</code>、<code>width</code>、<code>height</code>、<code>interlace</code>和<code>frame rate</code>节点组成一个链表</li><li>根节点包含节点类型<code>Object</code>和子节点<code>name</code></li><li>子节点包含节点名称<code>name</code>、节点值<code>Jack (&quot;Bee&quot;) Nimble</code>和兄弟节点<code>format</code></li><li><code>format</code>节点包含节点类型<code>Object</code>、节点名称<code>format</code>和子节点<code>type</code></li><li><code>type</code>节点包含节点类型<code>String</code>、节点名称<code>type</code>、节点值<code>rect</code>和兄弟节点<code>width</code></li><li><code>width</code>节点包含节点类型<code>Number</code>、节点名称<code>width</code>、节点值<code>1920</code>和兄弟节点<code>height</code></li><li><code>height</code>节点包含节点类型<code>Number</code>、节点名称<code>height</code>、节点值<code>1080</code>和兄弟节点<code>interlace</code> </li><li><code>interlace</code>节点包含节点类型<code>False</code>、节点名称<code>interlace</code>和兄弟节点<code>frame rate</code></li><li><code>frame rate</code>节点包含节点类型<code>Number</code>、节点名称<code>frame tate</code>和节点值<code>25</code></li></ul><h2 id="cJSON内存管理"><a href="#cJSON内存管理" class="headerlink" title="cJSON内存管理"></a>cJSON内存管理</h2><p><code>cJson</code>分为自动和手动两种使用方式：</p><ul><li>在自动模式下，<code>cJSON</code>使用默认的<code>malloc</code>和<code>free</code>函数管理内存，在<code>cJSON</code>中，每个节点都是<code>malloc</code>而来，每个节点的<code>string</code>和<code>valuestring</code>也是<code>malloc</code>而来，使用<code>cJSON_Delete</code>函数可以递归释放<code>JSON</code>树中<code>malloc</code>的节点内存和字符内存，使用<code>cJSON_Print</code>函数后，则需要手动释放<code>cJSON_Print</code>函数分配的内存，避免内存泄露</li><li>在手动模式下，<code>cJSON</code>提供了钩子函数来帮助用户自定义内存管理函数，如果不设置，这默认为<code>malloc</code>和<code>free</code></li></ul><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cJSON_Hooks</span> js_hook = </span>&#123;xxx_malloc, xxx_free&#125;;</span><br><span class="line">cJSON_InitHooks(&amp;js_hook);</span><br></pre></td></tr></table></figure><h2 id="cJSON序列化"><a href="#cJSON序列化" class="headerlink" title="cJSON序列化"></a>cJSON序列化</h2><p><code>cJSON</code>序列化就是把<code>cJSON</code>输出，有两种形式：</p><ul><li>格式化输出<code>char  *cJSON_Print(cJSON *item);</code></li><li>压缩输出<code>char  *cJSON_PrintUnformatted(cJSON *item);</code></li></ul><p>需要注意的是<code>cJSON</code>采用了预先将要输的内容全部以字符串形式存储在内存中，最后输出整个字符串的方法，而不是边分析<code>json</code>数据边输出，所以对于比较大的<code>json</code>数据来说，内存就是个问题了</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://github.com/faycheng/cJSON" target="_blank" rel="noopener">cJson源码和源码分析</a></li></ul><h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p><ul><li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li><li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li><li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li><li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li><li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li></ul><p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习使用cJSON过程的一些发现和总结，不涉及具体的函数&lt;br&gt;
    
    </summary>
    
      <category term="C" scheme="http://answerywj.com/categories/C/"/>
    
    
      <category term="cJSON" scheme="http://answerywj.com/tags/cJSON/"/>
    
  </entry>
  
  <entry>
    <title>Linux下core文件使用</title>
    <link href="http://answerywj.com/2018/03/07/usage-of-core-in-linux/"/>
    <id>http://answerywj.com/2018/03/07/usage-of-core-in-linux/</id>
    <published>2018-03-07T08:16:15.000Z</published>
    <updated>2019-03-16T07:13:16.649Z</updated>
    
    <content type="html"><![CDATA[<p>有时候程序会异常退出而不带任何日志，此时就可以使用<code>code</code>文件进行分析，它会记录程序运行的内存，寄存器，堆栈指针等信息</p><hr><a id="more"></a><h2 id="什么是core文件"><a href="#什么是core文件" class="headerlink" title="什么是core文件"></a>什么是core文件</h2><p>通常在<code>Linux</code>下遇到程序异常退出或者中止，我们都会使用<code>core</code>文件进行分析，其中包含了程序运行时的内存，寄存器，堆栈指针等信息，格式为<code>ELF</code>，可以理解是程序工作当前状态转储成一个文件，通过工具分析这个文件，我们可以定位到程序异常退出或者终止时相应的堆栈调用等信息，为解决问题提供帮助。</p><h2 id="使用core文件调试"><a href="#使用core文件调试" class="headerlink" title="使用core文件调试"></a>使用core文件调试</h2><h3 id="生成方法"><a href="#生成方法" class="headerlink" title="生成方法"></a>生成方法</h3><ol><li><p>查看当前<code>core</code>文件的状态</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ulimit -a</span><br><span class="line">...</span><br><span class="line">-c: core file size <span class="params">(blocks)</span>         0  # 关闭状态</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>打开生成开关</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ulimit -c unlimited</span><br><span class="line">ulimit -a</span><br><span class="line">...</span><br><span class="line">-c: core file size <span class="params">(blocks)</span>         unlimited</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>对<code>core</code>文件的大小进行限制，单位为<code>blocks</code>，一般<code>1 block=512 bytes</code>，设置太小可能导致不会生成文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">ulimit</span> -c 1024</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">ulimit</span> -a</span></span><br><span class="line">...</span><br><span class="line">-c: core file size (blocks)         1024</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>关闭生成开关</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ulimit -c <span class="number">0</span></span><br><span class="line">ulimit -a</span><br><span class="line">...</span><br><span class="line">-c: core file size <span class="params">(blocks)</span>         0</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>上面对<code>core</code>文件的操作仅对当前生效，若需要永久生效，则要将相应操作写入<code>/etc/profile</code></p></blockquote><h3 id="生成路径"><a href="#生成路径" class="headerlink" title="生成路径"></a>生成路径</h3><p><code>core</code>文件默认生成在程序的工作目录，可以对生成路径进行设置，需要保证对对应目录有足够空间并具有写权限<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="regexp">/MyCoreDumpDir/</span>core.%e.%p &gt; <span class="regexp">/proc/</span>sys<span class="regexp">/kernel/</span>core_pattern</span><br></pre></td></tr></table></figure></p><p>其中命名使用的参数列表<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%p - <span class="keyword">insert</span> pid <span class="keyword">into</span> filename  <span class="comment"># 添加 pid </span></span><br><span class="line">%u - <span class="keyword">insert</span> <span class="keyword">current</span> uid <span class="keyword">into</span> filename  <span class="comment"># 添加当前 uid </span></span><br><span class="line">%g - <span class="keyword">insert</span> <span class="keyword">current</span> gid <span class="keyword">into</span> filename  <span class="comment"># 添加当前 gid </span></span><br><span class="line">%s - <span class="keyword">insert</span> signal that caused the coredump <span class="keyword">into</span> the filename  <span class="comment"># 添加导致产生 core 的信号 </span></span><br><span class="line">%t - <span class="keyword">insert</span> UNIX <span class="built_in">time</span> that the coredump occurred <span class="keyword">into</span> filename  <span class="comment"># 添加 core 文件生成时的 unix 时间 </span></span><br><span class="line">%h - <span class="keyword">insert</span> hostname <span class="keyword">where</span> the coredump happened <span class="keyword">into</span> filename  <span class="comment"># 添加主机名 </span></span><br><span class="line">%e - <span class="keyword">insert</span> coredumping executable <span class="keyword">name</span> <span class="keyword">into</span> filename  <span class="comment"># 添加命令名</span></span><br></pre></td></tr></table></figure></p><blockquote><p><code>/proc/sys/kernel/core_uses_pid</code>这个文件的值若为１，则无论时候配置<code>%p</code>,最后生成的<code>core</code>文件都会添加<code>pid</code></p></blockquote><h3 id="调试方法"><a href="#调试方法" class="headerlink" title="调试方法"></a>调试方法</h3><p>可以使用<code>gdb</code>对<code>core</code>文件进行调试，编译是需要带上<code>-g</code>选项<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gdb <span class="selector-tag">a</span>.out</span><br><span class="line">...</span><br><span class="line">(gdb) core-file core</span><br><span class="line">...</span><br><span class="line">(gdb) bt </span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>如需要在<code>PC</code>上调试嵌入式设备产生的<code>core</code>文件，则需要选取相应平台的<code>gdb</code>工具，并在进入<code>gdb</code>后设置符号文件的位置<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ xxx-xxx-gdb <span class="selector-tag">a</span>.out</span><br><span class="line">...</span><br><span class="line">(gdb) solib-search-path xxx<span class="selector-class">.so</span>:xxx.so</span><br><span class="line">...</span><br><span class="line">(gdb) core-file core</span><br><span class="line">...</span><br><span class="line">(gdb) bt</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p><ul><li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li><li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li><li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li><li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li><li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li></ul><p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时候程序会异常退出而不带任何日志，此时就可以使用&lt;code&gt;code&lt;/code&gt;文件进行分析，它会记录程序运行的内存，寄存器，堆栈指针等信息&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://answerywj.com/categories/Linux/"/>
    
    
      <category term="core dump" scheme="http://answerywj.com/tags/core-dump/"/>
    
  </entry>
  
  <entry>
    <title>Speex介绍</title>
    <link href="http://answerywj.com/2017/12/29/Introduction-of-speex/"/>
    <id>http://answerywj.com/2017/12/29/Introduction-of-speex/</id>
    <published>2017-12-29T07:49:34.000Z</published>
    <updated>2019-03-16T07:13:16.537Z</updated>
    
    <content type="html"><![CDATA[<p>本文将对<em>Speex</em>相关的概念进行介绍</p><hr><a id="more"></a><p>[TOC]</p><p><em>Speex</em>编解码器是一款开源且免费的语音编解码器，遵循<em>BSD</em>协议，为分封网络（<em>packet network</em>）和网络电话（<em>VoIP</em>）而设计，支持文件的压缩</p><blockquote><p>为网络电话而不是移动电话而设计，意味着<em>Speex</em>对数据丢失具有鲁棒性，但是对数据包损坏不鲁棒，在<em>VoIP</em>中的数据包要么完整到达，要么不能到达</p></blockquote><p><em>Speex</em>选用CELP（码激励线性预测编码）编码技术，在高比特率和低比特率都稳定可靠，复杂性适度并且占用内存较少</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="采样率"><a href="#采样率" class="headerlink" title="采样率"></a>采样率</h3><p>采样率是每秒钟采集到的信号样本数，单位是<em>Hertz</em>（<em>Hz</em>），<em>Speex</em>为三种不同的采样率而设计：<em>8kHz</em>（窄带），<em>16kHz</em>（宽带）和<em>32kHz</em>（超宽带）</p><h3 id="比特率"><a href="#比特率" class="headerlink" title="比特率"></a>比特率</h3><p>在对语音信号编码时，比特率定义为单位时间内的比特数，单位是比特每秒（<em>bps</em>）或通常的千比特每秒（<em>kbps</em>）</p><blockquote><p>注意千比特每秒（<em>kbps</em>）和千字节每秒（<em>kBps</em>）的区别。</p></blockquote><h3 id="质量（可变）"><a href="#质量（可变）" class="headerlink" title="质量（可变）"></a>质量（可变）</h3><p><em>Speex</em>是有损的编解码器，意味着压缩率以输入语音信号的保真度为代价，质量越高，压缩后的比特率越大，音质也越好<br><em>Speex</em>可以控制质量和比特率之间的折中，大多数时间由一个范围在<em>0</em>到<em>10</em>之间的质量参数控制</p><blockquote><p>在不变比特率（<em>CBR</em>）中，质量参数是一个整数； 在可变比特率（<em>VBR</em>）中，质量参数是一个浮点数。</p></blockquote><h3 id="复杂度（可变）"><a href="#复杂度（可变）" class="headerlink" title="复杂度（可变）"></a>复杂度（可变）</h3><p><em>Speex</em>允许编码器拥有可变的复杂度，通过一个范围在<em>1</em>到<em>10</em>之间的整数控制搜索的执行来实现，复杂度越高，压缩率越高，CPU使用率越高，音质越好，类似于<em>gzip</em>和<em>bzip2</em>压缩工具的-1到<em>-9</em>选项<br>正常使用情况下，复杂度为<em>1</em>的噪声等级比复杂度为<em>10</em>的噪声等级高<em>1</em>到<em>2</em>个<em>dB</em>，但复杂度为<em>10</em>的<em>CPU</em>要求比复杂度为1的高<em>5</em>倍。</p><blockquote><p>实际应用中，最好的折中是复杂度<em>2</em>到<em>4</em>，但在编码非语音声音如<em>DTMF</em>声调时更高的复杂度经常被用到</p></blockquote><h3 id="可变比特率（VBR）"><a href="#可变比特率（VBR）" class="headerlink" title="可变比特率（VBR）"></a>可变比特率（<em>VBR</em>）</h3><p>可变比特率（<em>VBR</em>）允许编解码器自适应的根据待编码音频的“难度”动态地改变比特率，如元音和高能瞬态变化的声音需要高比特率以获得好的质量； 但是摩擦音（如<em>s，f</em>）用低比特率就能充分编码</p><ul><li>优点：<em>VBR</em>在相同的质量下能获得更低的比特率，或在不变比特率下获得更好的质量</li><li>缺点：在指定质量情况下，无法保证最终的平均比特率；在一些如网络电话（<em>VoIP</em>）这样的实时应用中，依赖于最大比特率，这在通信信道中必须足够低。</li></ul><h3 id="平均比特率（ABR）"><a href="#平均比特率（ABR）" class="headerlink" title="平均比特率（ABR）"></a>平均比特率（<em>ABR</em>）</h3><p>平均比特率解决了<em>VBR</em>中的一个问题，它动态地调整<em>VBR</em>质量以获得指定的比特率，因为质量和比特率是实时调整的，<em>ABR</em>的全局质量比正好达到目标平均比特率的<em>VBR</em>编码质量稍微差些。</p><h3 id="声音活动检测（VAD）"><a href="#声音活动检测（VAD）" class="headerlink" title="声音活动检测（VAD）"></a>声音活动检测（<em>VAD</em>）</h3><p><em>VAD</em>检测待编码的音频是语音还是无声/背景噪声，<em>VBR</em>编码中默认激活</p><blockquote><p><em>Speex</em>检测出非语言段并仅使用足够复现背景噪声的比特率进行编码，这叫“柔化噪音生成”（<em>CNG</em>）。</p></blockquote><h3 id="断续传输（DTX）"><a href="#断续传输（DTX）" class="headerlink" title="断续传输（DTX）"></a>断续传输（DTX）</h3><p>断续传输是<em>VAD/VBR</em>的附加操作，当背景噪声平稳时会完全停止传输</p><h3 id="知觉增强"><a href="#知觉增强" class="headerlink" title="知觉增强"></a>知觉增强</h3><p>知觉增强是解码器的一部分，当被启用时，能减少编解码过程中产生的噪声或失真的知觉</p><blockquote><p>在大多数情况下，知觉增强会带来声音客观上的偏离（如仅考虑<em>SNR</em>），但最后仍听起来更好（主管增强）</p></blockquote><h3 id="等待时间和算法延时"><a href="#等待时间和算法延时" class="headerlink" title="等待时间和算法延时"></a>等待时间和算法延时</h3><p>每一个语音编解码器在传输中都会引入延时，对于<em>Speex</em>，延时等于帧长加上处理每一帧需要前几帧的数量</p><blockquote><p>在窄带操作中延时为<em>30ms</em>，在宽带操作中延时为<em>34ms</em>，这不包括编解码帧时的<em>CPU</em>时间</p></blockquote><h2 id="相关组件"><a href="#相关组件" class="headerlink" title="相关组件"></a>相关组件</h2><h3 id="编解码器"><a href="#编解码器" class="headerlink" title="编解码器"></a>编解码器</h3><p><em>Speex</em>编解码器有以下特性</p><ol><li>免费软件/开源，免专利费和版税</li><li>利用嵌入比特流集成了窄带和宽带</li><li>大范围可用比特率（从<em>2.15kbps</em>到<em>44kbps</em>）</li><li>动态比特率转换（<em>AMR</em>）和可变比特率操作（<em>VBR</em>）</li><li>声音活动检测（<em>VAD</em>，与<em>VBR</em>集成）和断续传输（<em>DTX</em>）</li><li>可变复杂度</li><li>嵌入宽带结构（可伸缩采样率）</li><li><em>32kHz</em>超宽带采样率</li><li>强度立体声编码选项</li><li>定点实现</li></ol><h3 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h3><p>预处理器在对音频编码前对音频进行预处理，有三个主要功能</p><ol><li>噪声抑制<br>先降噪再进行编解码是有好处的，因为<em>Speex</em>编解码器通常会对噪声输入同样进行编解码，这将会扩大噪声，而降噪能大大减少这一影响</li><li>自动增益控制（<em>AGC</em>）<br>自动增益控制（<em>AGC</em>）是为了处理录音音量在不同设置里有很大差别这一问题，<em>AGC</em>将会调整信号音量到参考音量大小</li><li>声音活动检测（<em>VAD</em>）<br>预处理器提供的声音活动检测（<em>VAD</em>）比编解码器中直接提供的<em>VAD</em>更先进</li></ol><h3 id="自适应抖动缓冲器"><a href="#自适应抖动缓冲器" class="headerlink" title="自适应抖动缓冲器"></a>自适应抖动缓冲器</h3><p>当通过<em>UDP</em>（<em>User Datagram Protocal</em>，用户数据报协议）或<em>RTP</em>（<em>Real Time Protocal</em>，实时传输协议）传输声音（或其他任何内容）时，数据包可能丢失，不同延时到达，甚至乱序，抖动缓冲器的作用是对数据包进行重排序并保存在足够长的buffer（但有一定限度）里，然后将数据包发送去解码</p><h3 id="声学回声消除器"><a href="#声学回声消除器" class="headerlink" title="声学回声消除器"></a>声学回声消除器</h3><p>在任何免提式通信系统中（下图），远端的语音在本地扬声器播放时，经过在房间里传播后又会被麦克风录音，如果将麦克风录音直接又发送到远端，则远端的用户将会听到他自己的回声<br><img src="http://o9zpdspb3.bkt.clouddn.com/aec.png" alt="aec"><br>声学回声消除器就是为了在将录音发送到远端前消除声学回声，提高了远端接收的语音质量</p><h3 id="重采样器"><a href="#重采样器" class="headerlink" title="重采样器"></a>重采样器</h3><p>重采样指转换音频的采样率，在任意采样率间进行转换（采样率必须是有理数），能控制质量和复杂度的折中，可用于能混合不同采样率流，支持声卡不支持的采样率，能转码等</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="http://blog.csdn.net/YJJat1989/article/category/1879965" target="_blank" rel="noopener">http://blog.csdn.net/YJJat1989/article/category/1879965</a></li></ul><h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p><ul><li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li><li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li><li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li><li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li><li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li></ul><p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将对&lt;em&gt;Speex&lt;/em&gt;相关的概念进行介绍&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Knowledge" scheme="http://answerywj.com/categories/Knowledge/"/>
    
    
      <category term="Speex" scheme="http://answerywj.com/tags/Speex/"/>
    
  </entry>
  
  <entry>
    <title>线程同步机制条件变量的使用与思考</title>
    <link href="http://answerywj.com/2017/12/15/condition-variables-of-thread-synchronization/"/>
    <id>http://answerywj.com/2017/12/15/condition-variables-of-thread-synchronization/</id>
    <published>2017-12-15T14:23:08.000Z</published>
    <updated>2019-03-16T07:13:16.537Z</updated>
    
    <content type="html"><![CDATA[<p>条件变量是<em>Linux</em>线程同步的一种机制，与互斥量一起使用时，允许线程以无竞争的方式等待特定条件的发生</p><hr><a id="more"></a><p>[TOC]</p><h2 id="关键函数"><a href="#关键函数" class="headerlink" title="关键函数"></a>关键函数</h2><h3 id="初始化与注销"><a href="#初始化与注销" class="headerlink" title="初始化与注销"></a>初始化与注销</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态初始化</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">thread_cond_t</span> *cond, </span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反初始化，即注销</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"></span><br><span class="line">返回值: 若成功，返回<span class="number">0</span>；否则，返回错误编码</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>只有在没有线程在该条件变量上等待时，才可以注销条件变量，否则会返回<code>EBUSY</code></li><li><code>Linux</code>在实现条件变量时，并没有为条件变量分配资源，所以在注销一个条件变量时，只需要注意该变量是否仍有等待线程即可</li></ul><h3 id="线程等待"><a href="#线程等待" class="headerlink" title="线程等待"></a>线程等待</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond, </span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond, </span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">pthread_mutex_t</span> *mutex, </span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">const</span> struct timespec *abstime)</span></span>;</span><br><span class="line"></span><br><span class="line">返回值: 若成功，返回<span class="number">0</span>；否则，返回错误编码</span><br></pre></td></tr></table></figure><p>执行过程如下：</p><ol><li>调用者把锁住的互斥量传给函数，然后函数自动把调用线程放到等待条件的线程列表上</li><li>对互斥量进行解锁，线程挂起进入等待(不占用<code>CPU</code>时间)　</li><li>函数被唤醒返回时，会自动对互斥量进行加锁</li></ol><blockquote><p><code>pthread_cond_timedwait</code>只是多了一个等待超时时间，通过<code>timespec</code>指定，超时返回错误<code>ETIMEDOUT</code></p></blockquote><h3 id="线程唤醒"><a href="#线程唤醒" class="headerlink" title="线程唤醒"></a>线程唤醒</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"></span><br><span class="line">返回值: 若成功，返回<span class="number">0</span>；否则，返回错误编码</span><br></pre></td></tr></table></figure><ul><li><code>pthread_cond_signal</code>至少能唤醒一个等待该条件的线程</li><li><code>pthread_cond_broadcast</code>则能唤醒等待该条件的所有线程<blockquote><p>需要注意的是，一定要在改变条件状态以后再给线程发信号</p></blockquote></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例代码可参考我的<a href="https://github.com/AnSwErYWJ/DogFood/blob/24acbfdd45e80032c988ccd05e3b12f9cfe01849/C/thread/t_cond.c" target="_blank" rel="noopener">github</a>，由于篇幅原因，不在此贴出</p><h2 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h2><h3 id="条件变量实质是什么"><a href="#条件变量实质是什么" class="headerlink" title="条件变量实质是什么"></a>条件变量实质是什么</h3><p>条件变量实质是利用线程间共享的全局变量进行同步的一种机制</p><h3 id="互斥量保护的是什么"><a href="#互斥量保护的是什么" class="headerlink" title="互斥量保护的是什么"></a>互斥量保护的是什么</h3><p>示例中的相关代码<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">pthread_mutex_lock</span>(&amp;(test-&gt;</span>mut));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">while</span> (test-&gt;</span>condition == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="title">pthread_cond_wait</span>(&amp;(test-&gt;</span><span class="function"><span class="title">cond</span>), &amp;(test-&gt;</span>mut));</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="title">pthread_mutex_unlock</span>(&amp;(test-&gt;</span>mut));</span><br></pre></td></tr></table></figure></p><p>互斥量是用来保护条件<code>test-&gt;condition</code>在读取时，它的值不被其它线程修改，如果条件成立，则此线程进入等待条件的线程队列，对互斥量进行解锁并开始等待</p><h3 id="为什么用while来判断条件"><a href="#为什么用while来判断条件" class="headerlink" title="为什么用while来判断条件"></a>为什么用while来判断条件</h3><p>如上面的代码所示，使用<code>while</code>对条件进行判断的原因如下：</p><ol><li>若先解锁互斥量，再唤醒等待线程，则条件可能被其它线程更改，使得等待条件再次成立，需要继续等待</li><li><code>pthread_cond_wait</code>可能存在意外返回的情况，则此时条件并没有被更改，需要继续等待。<blockquote><p>造成意外返回的原因是<code>Linux</code>中带阻塞功能的系统调用都会在进程收到<code>signal</code>后返回</p></blockquote></li></ol><h3 id="先唤醒线程还是先解锁"><a href="#先唤醒线程还是先解锁" class="headerlink" title="先唤醒线程还是先解锁"></a>先唤醒线程还是先解锁</h3><p>示例代码：</p><ol><li><p>情况一：先唤醒</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(<span class="name">&amp;</span>(<span class="name">test-&gt;mut</span>))<span class="comment">;</span></span><br><span class="line">test-&gt;condition = <span class="number">1</span></span><br><span class="line">pthread_cond_signal(<span class="name">&amp;</span>(<span class="name">test-&gt;cond</span>))<span class="comment">;</span></span><br><span class="line">pthread_mutex_unlock(<span class="name">&amp;</span>(<span class="name">test-&gt;mut</span>))<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li><p>情况二：先解锁</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(<span class="name">&amp;</span>(<span class="name">test-&gt;mut</span>))<span class="comment">;</span></span><br><span class="line">test-&gt;condition = <span class="number">1</span></span><br><span class="line">pthread_mutex_unlock(<span class="name">&amp;</span>(<span class="name">test-&gt;mut</span>))<span class="comment">;</span></span><br><span class="line">pthread_cond_signal(<span class="name">&amp;</span>(<span class="name">test-&gt;cond</span>))<span class="comment">;</span></span><br></pre></td></tr></table></figure></li></ol><p>两种情况各有缺点：</p><ul><li>情况一在唤醒等待线程后，再解锁，使得等待线程在被唤醒后试图对互斥量进行加锁时，互斥量还未解锁，则线程又进入睡眠，待互斥量解锁成功后，再次被唤醒并对互斥量加锁，这样就会发生两次上下文切换，影响性能</li><li>情况二在唤醒等待线程前先解锁，使得其它线程可能先于等待线程获取互斥量，并对条件进行更改，使得条件变量失去作用</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.cnblogs.com/leijiangtao/p/4028338.html" target="_blank" rel="noopener">关于pthread_cond_wait使用while循环判断的理解</a></li><li><a href="https://www.cnblogs.com/zhx831/p/3543633.html" target="_blank" rel="noopener">Linux线程同步之条件变量pthread_cond_t</a></li><li><a href>APUE</a></li></ul><h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p><ul><li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li><li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li><li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li><li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li><li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li></ul><p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;条件变量是&lt;em&gt;Linux&lt;/em&gt;线程同步的一种机制，与互斥量一起使用时，允许线程以无竞争的方式等待特定条件的发生&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="C" scheme="http://answerywj.com/categories/C/"/>
    
    
      <category term="pthread" scheme="http://answerywj.com/tags/pthread/"/>
    
  </entry>
  
  <entry>
    <title>GCC编译ARM篇</title>
    <link href="http://answerywj.com/2017/08/04/gcc-compilation-of-arm-articles/"/>
    <id>http://answerywj.com/2017/08/04/gcc-compilation-of-arm-articles/</id>
    <published>2017-08-04T08:30:40.000Z</published>
    <updated>2019-03-16T07:13:16.585Z</updated>
    
    <content type="html"><![CDATA[<p><code>ARM</code> 平台下<code>GCC</code>编译相关介绍，待补充<br><a id="more"></a></p><h2 id="ARM处理器架构"><a href="#ARM处理器架构" class="headerlink" title="ARM处理器架构"></a>ARM处理器架构</h2><p><code>ARM</code>处理器架构，通过选项<code>-march</code>指定，如<code>-march=armv7-a</code>，常见的有</p><ol><li><code>armv5te</code><br><code>arm9</code>系列使用该架构</li><li><code>armv6</code><br><code>arm11</code>系列使用该架构</li><li><code>armv7-a</code><br><code>cortex-a</code>系列使用该架构，如<code>cortex-a5、a7、a8、a9、a12、a15</code></li><li><code>armv8</code><br><code>cortex-a</code>系列使用该架构，如<code>cortex-a53、a57、a72</code></li></ol><h2 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h2><p>指令集，通过选项<code>-m</code>指定，如<code>-mthumb</code>，常见的有</p><ol><li><code>thumb</code><br>16位指令集，它将32位arm指令的压缩成16位的指令编码方式，节省代码存储空间，实现低功耗</li><li><code>thumb-2</code><br>16位/32位指令集，对<code>thumb</code>指令集进行了扩充，增加了一些32位指令，改善<code>thumb</code>指令集的性能</li><li><code>arm</code><br>32位指令集, 兼容所有<code>arm</code>架构，性能高</li></ol><h2 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h2><p>浮点运算的类型，通过选项<code>-mfloat-abi</code>指定，如<code>-mfloat-abi=hard</code>，有三种类型</p><ol><li><code>soft</code><br>使用软浮点库进行浮点运算，不使用硬浮点单元，适用于不含<code>FPU</code>的<code>CPU</code></li><li><code>softfp</code><br>使用硬浮点单元进行浮点运算，生成硬浮点指令，调用接口的规则和<code>soft</code>兼容</li><li><code>hard</code><br>使用硬浮点单元进行浮点运算，生成硬浮点指令，与<code>softfp</code>的区别在于调用接口的规则不同</li></ol><p>硬浮点指令的类型，通过选项<code>-mfpu</code>指定，如<code>-mfpu=neon</code>，常用的有两种</p><ol><li><code>vfp</code><br>其中<code>vfpv2</code>应用于<code>armv5te, armv6</code>架构中的浮点计算指令集，<code>vfpv3</code>和<code>vfpv4</code>应用于部分<code>armv7a</code>架构中的浮点计算指令集</li><li><code>neon</code><br>应用于<code>cortex-a</code>系列处理器，性能好</li></ol><h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p><ul><li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li><li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li><li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li><li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li><li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li></ul><p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;ARM&lt;/code&gt; 平台下&lt;code&gt;GCC&lt;/code&gt;编译相关介绍，待补充&lt;br&gt;
    
    </summary>
    
      <category term="Compile" scheme="http://answerywj.com/categories/Compile/"/>
    
    
      <category term="gcc" scheme="http://answerywj.com/tags/gcc/"/>
    
  </entry>
  
  <entry>
    <title>UNIX下IO模型分析</title>
    <link href="http://answerywj.com/2017/06/27/unix-io-model-analysis/"/>
    <id>http://answerywj.com/2017/06/27/unix-io-model-analysis/</id>
    <published>2017-06-27T08:30:40.000Z</published>
    <updated>2019-03-16T07:13:16.625Z</updated>
    
    <content type="html"><![CDATA[<p>对<em>UNIX</em>下的五种常见<em>IO</em>模型分析，帮助理解<br><a id="more"></a></p><h2 id="IO操作的两个阶段"><a href="#IO操作的两个阶段" class="headerlink" title="IO操作的两个阶段"></a>IO操作的两个阶段</h2><p>以读数据操作为例：</p><ol><li>等待内核数据准备（数据拷贝到内核缓冲区）</li><li>将数据从内核拷贝到用户空间</li></ol><h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><p><em>UNIX</em>下共有五种常见的<em>IO</em>模型：<br><img src="http://o9zpdspb3.bkt.clouddn.com/5IO.png" alt="UNIX下共有五种常见的IO模型"></p><p>下面以<code>recvfrom</code>接口举例</p><h3 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h3><p>默认情况下，所有的套接字都是阻塞的<br><img src="http://o9zpdspb3.bkt.clouddn.com/blockingIO.png" alt="阻塞IO"><br>调用<code>recvfrom</code>接口，进程在<em>IO</em>操作的两个阶段都会阻塞，直到最终数据拷贝到用户空间或者过程中出现错误才会返回，进程在阻塞状态下是不占用<em>CPU</em>资源的</p><blockquote><p>最常见的错误是发生系统中断，此时需要重读，可参考<a href="https://github.com/AnSwErYWJ/DogFood/blob/master/C/RD.c" target="_blank" rel="noopener">这里</a></p></blockquote><h3 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h3><p>可以通过<code>fcntl(sockfd,F_SETFL,O_NONBLOCK)</code>将套接字设置成非阻塞<br><img src="http://o9zpdspb3.bkt.clouddn.com/noblockingIO.png" alt="非阻塞IO"><br>调用<code>recvfrom</code>接口，无论内核缓冲区是否有可用数据，进程都会立即返回，所以在<em>IO</em>操作的第一阶段是非阻塞的; 若无数据可用，内核将<code>errno</code>设置为为<code>EWOULDBLOCK</code>或者<code>EAGAIN</code>，进程可以使用轮询的方法，保证内核在数据准备好时，能立即拷贝到用户空间; 若有则立即将数据拷贝到用户空间，进程在数据拷贝到用户空间即<em>IO</em>操作的第二阶段是阻塞的;</p><blockquote><p>非阻塞<em>IO</em>过于消耗<em>CPU</em>时间，将大部分时间用于轮询</p></blockquote><h3 id="多路复用IO"><a href="#多路复用IO" class="headerlink" title="多路复用IO"></a>多路复用IO</h3><p>多路复用系统调用：<code>select</code>,<code>poll</code>和<code>epoll</code>，其中<em>windows</em>平台不支持<code>poll</code>和<code>epoll</code>，使用方法可以参考<a href="https://segmentfault.com/a/1190000003063859?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#articleHeader14" target="_blank" rel="noopener">I/O 多路复用之select、poll、epoll详解</a>和<a href="http://www.cnblogs.com/NerdWill/p/4996476.html" target="_blank" rel="noopener">Linux select/poll和epoll实现机制对比</a><br><img src="http://o9zpdspb3.bkt.clouddn.com/multiIO.png" alt=" 多路复用IO"><br>调用<code>select</code>，等待内核数据准备，所以<em>IO</em>操作的第一个阶段，进程是阻塞的，不过是阻塞在多路复用系统调用上，而不是<em>IO</em>系统调用上; 当<code>select</code>返回套接字可读条件时，再调用<code>recvfrom</code>将数据从内核拷贝到用户空间，<em>IO</em>操作的第二阶段，进程是阻塞的</p><p>多路复用<em>IO</em>和阻塞<em>IO</em>，在<em>IO</em>操作的两个阶段都是阻塞的，不过多路复用<em>IO</em>使用了两个系统调用，而阻塞<em>IO</em>只使用了一个，所以在连接数不是很多的情况下，阻塞<em>IO</em>可能性能更佳; 多路复用<em>IO</em>的优势在于可以同时监控多个用于<em>IO</em>的文件描述符。</p><blockquote><p>多线程中的阻塞<em>IO</em>，与多路复用<em>IO</em>极为相似</p></blockquote><h3 id="信号驱动IO"><a href="#信号驱动IO" class="headerlink" title="信号驱动IO"></a>信号驱动IO</h3><p><img src="http://o9zpdspb3.bkt.clouddn.com/signalIO.png" alt="信号驱动IO"><br>调用<code>sigaction</code>等系统调用安装信号处理函数，并立即返回，所以<em>IO</em>操作的第一阶段，进程是非阻塞的; 当内核数据准备好时，内核会产生一个信号，通知进程将数据从内核拷贝到用户空间，<em>IO</em>操作的第二阶段，进程是阻塞的</p><blockquote><p>使用方法：<a href="http://www.cnblogs.com/ittinybird/p/4574397.html" target="_blank" rel="noopener">IO的多路复用和信号驱动</a></p></blockquote><h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><p>异步<em>IO</em>有一组以<code>aio</code>开头的系统调用，使用方法可参考<a href="http://blog.csdn.net/tq02h2a/article/details/3825114" target="_blank" rel="noopener">Linux AIO机制</a><br><img src="http://o9zpdspb3.bkt.clouddn.com/asynIO.png" alt="异步IO"><br>调用异步<em>IO</em>系统调用，给内核传递描述字、缓冲区指针、缓冲区大小（与<code>read</code>相同的三个参数）、文件偏移（与<code>lseek</code>类似），告诉内核当整个操作完成时如何通知我们，并立即返回，在<em>IO</em>操作的两个阶段，进程都不阻塞</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="http://o9zpdspb3.bkt.clouddn.com/5IO-compare.png" alt="5种IO模式比较"></p><ul><li>同步<em>IO</em>和异步<em>IO</em>的主要区别是将数据从内核拷贝到用户空间是否阻塞，前者会在将数据从内核拷贝到用户空间时即<em>IO</em>操作的第二个阶段发生阻塞，而后者则在系统调用后直接返回，直到内核发送信号通知<em>IO</em>操作完成，在<em>IO</em>操作的两个阶段都没有阻塞</li><li>阻塞<em>IO</em>和非阻塞<em>IO</em>的主要区别是系统调用是否立即返回（默认将数据从内核拷贝到用户空间即<em>IO</em>操作的第二个阶段是立即返回的），前者会在<em>IO</em>操作的两个阶段完成前一直阻塞，后者在内核没有准备好数据的情况下立即返回，即只会在<em>IO</em>操作的第二个阶段阻塞</li><li>信号驱动<em>IO</em>和异步<em>IO</em>的主要区别在于前者由内核通知我们何时启动一个<em>IO</em>操作，在将数据从内核拷贝到用户空间过程中即<em>IO</em>操作的第一个阶段依旧是阻塞的，而后者是由内核通知我们<em>IO</em>操作何时完成，在<em>IO</em>操作的两个阶段都没有阻塞</li></ul><blockquote><p><a href="https://www.zhihu.com/question/19732473/answer/20851256" target="_blank" rel="noopener">知乎</a>上有一个比较生动的例子可以说明这几种模型之间的关系。</p></blockquote><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="http://about:blank" target="_blank" rel="noopener">UNIX网络编程 卷1：套接字联网API</a></li><li><a href="https://segmentfault.com/a/1190000003063859?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="noopener">Linux IO模式及 select、poll、epoll详解</a></li><li><a href="http://www.cnblogs.com/ittinybird/p/4666044.html" target="_blank" rel="noopener">Linux下5种IO模型的小结</a></li><li><a href="http://www.cnblogs.com/nufangrensheng/p/3588690.html" target="_blank" rel="noopener">UNIX网络编程读书笔记：I/O模型（阻塞、非阻塞、I/O复用、信号驱动、异步）</a></li><li><a href="http://blog.csdn.net/historyasamirror/article/details/5778378" target="_blank" rel="noopener"> IO - 同步，异步，阻塞，非阻塞 （亡羊补牢篇）</a></li><li><a href="http://blog.csdn.net/jay900323/article/details/18141217" target="_blank" rel="noopener">Linux五种IO模型性能分析</a></li></ul><h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p><ul><li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li><li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li><li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li><li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li><li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li></ul><p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对&lt;em&gt;UNIX&lt;/em&gt;下的五种常见&lt;em&gt;IO&lt;/em&gt;模型分析，帮助理解&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://answerywj.com/categories/Linux/"/>
    
    
      <category term="IO" scheme="http://answerywj.com/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>笔记 | OpenResty系列课程</title>
    <link href="http://answerywj.com/2017/06/20/note-of-openresty-study/"/>
    <id>http://answerywj.com/2017/06/20/note-of-openresty-study/</id>
    <published>2017-06-20T09:30:40.000Z</published>
    <updated>2019-03-16T07:13:16.621Z</updated>
    
    <content type="html"><![CDATA[<p>观看<a href="http://www.stuq.org/course/1015/study" target="_blank" rel="noopener">OpenResty 系列课程</a>的学习笔记<br><a id="more"></a></p><h2 id="用-OpenResty-快乐的搭建高性能服务端"><a href="#用-OpenResty-快乐的搭建高性能服务端" class="headerlink" title="用 OpenResty 快乐的搭建高性能服务端"></a>用 OpenResty 快乐的搭建高性能服务端</h2><h3 id="1-1-OpenResty简介"><a href="#1-1-OpenResty简介" class="headerlink" title="1.1 OpenResty简介"></a>1.1 OpenResty简介</h3><p>高性能服务端的两个特点：</p><ul><li>缓存（内存&gt;SSD&gt;机械磁盘，本机&gt;网络，进程内&gt;进程外）</li><li>异步非阻塞（事件驱动）</li></ul><h3 id="1-2-hello-world"><a href="#1-2-hello-world" class="headerlink" title="1.2 hello world"></a>1.2 hello world</h3><p>参考资料：</p><ul><li><a href="http://openresty.org/en/" target="_blank" rel="noopener">官网</a></li><li><a href="https://github.com/openresty/lua-nginx-module/blob/master/README.markdown" target="_blank" rel="noopener">文档</a></li></ul><p><code>OpenResty = Nginx + LuaJIT（LuaJIT虚拟机嵌在Nginx worker中）</code></p><p><a href="https://github.com/openresty/lua-nginx-module#lua_code_cache" target="_blank" rel="noopener">lua_code_cache</a>：<code>lua</code>代码缓存，默认开启，支持<code>set_by_lua_file</code>和<code>content_by_lua_file</code>等指令和<code>lua</code>模块，关闭后方便开发（不用重启Nginx），生产环境建议开启（影响性能）</p><p><a href="https://github.com/openresty/lua-nginx-module#content_by_lua_file" target="_blank" rel="noopener">content_by_lua_file</a>：指定要执行的<code>lua</code>文件</p><h3 id="1-3-OpenResty入门"><a href="#1-3-OpenResty入门" class="headerlink" title="1.3 OpenResty入门"></a>1.3 OpenResty入门</h3><p>书籍：<a href="https://moonbingbing.gitbooks.io/openresty-best-practices/content/index.html" target="_blank" rel="noopener">openresty最佳实践</a></p><p>运行时的错误日志保存在<code>logs/error.log</code>中</p><p><code>nginx.conf</code>示例片段：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">location</span> <span class="title">= /api</span>/random &#123;</span><br><span class="line"> content_by_lua_file lua/random.lua;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>random.lua</code>：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> args = ngx.req.get_uri_args() <span class="comment">--max is 100，set 0 to unlimit</span></span><br><span class="line"><span class="keyword">local</span> salt = args.salt</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> salt <span class="keyword">then</span></span><br><span class="line">  ngx.<span class="keyword">exit</span>(ngx.HTTP_BAD_REQUEST)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="built_in">string</span> = ngx.md5(ngx.<span class="built_in">time</span>() .. salt)</span><br><span class="line">ngx.<span class="built_in">say</span>(<span class="built_in">string</span>)</span><br></pre></td></tr></table></figure></p><h3 id="1-4-ngx-lua-API介绍"><a href="#1-4-ngx-lua-API介绍" class="headerlink" title="1.4 ngx lua API介绍"></a>1.4 ngx lua API介绍</h3><blockquote><p>Tips： 不要使用 <code>lua API</code>（阻塞），要用<code>ngx lua API</code>（非阻塞）</p></blockquote><h3 id="1-5-连接数据库"><a href="#1-5-连接数据库" class="headerlink" title="1.5 连接数据库"></a>1.5 连接数据库</h3><blockquote><p>Tips： 数据库操作的代码逻辑看上去是同步的，但是内部实现是异步的</p></blockquote><p>主要有<a href="https://github.com/openresty/lua-resty-redis" target="_blank" rel="noopener">lua-resty-redis</a>和<a href="https://github.com/openresty/lua-resty-mysql" target="_blank" rel="noopener">lua-resty-mysql</a></p><h3 id="1-6-OpenResty缓存"><a href="#1-6-OpenResty缓存" class="headerlink" title="1.6 OpenResty缓存"></a>1.6 OpenResty缓存</h3><ul><li><a href="https://github.com/openresty/lua-nginx-module#ngxshareddict" target="_blank" rel="noopener">share_dict</a>： 字典缓存，纯内存缓存，可以预设内存大小，多个<code>worker</code>共享，需要锁操作</li><li><a href="https://github.com/openresty/lua-resty-lrucache" target="_blank" rel="noopener">lua-resty-lrucache</a>：可以预设<code>key</code>个数，单个<code>worker</code>使用，内存使用翻倍  </li></ul><p>缓存失效风暴：在缓存超时时间触发的瞬间，所有的并发请求都同时执行数据库查询操作，数据库压力瞬间变大，下次请求又全部进入缓存，压力瞬间变小，出现两个极值。可以使用<a href="https://github.com/openresty/lua-resty-lock" target="_blank" rel="noopener">lua-resty-lock</a>对数据库查询操作加锁，使数据库查询只进行一次</p><h3 id="1-7-FFI和第三方模块"><a href="#1-7-FFI和第三方模块" class="headerlink" title="1.7 FFI和第三方模块"></a>1.7 FFI和第三方模块</h3><p><code>FFI</code>：<code>LuaJIT</code>的一个库，可以在<code>LuaJIT</code>中调用<code>C</code>的数据结构和外部<code>C</code>函数。如<a href="https://github.com/openresty/lua-resty-string/blob/master/lib/resty/random.lua" target="_blank" rel="noopener">random.lua</a><br>第三方模块：放在<code>/openresty/lualib/resty</code>目录下。</p><h3 id="1-8-子查询"><a href="#1-8-子查询" class="headerlink" title="1.8 子查询"></a>1.8 子查询</h3><p><code>ngx.location.capture</code>和<code>ngx.location.capture_multi</code>：在一个<code>location</code>内部，对另一个<code>location</code>进行请求，因为这不是<code>http</code>请求，是<code>C</code>级别的调用，所以有开销小的优点; 同时可以降级服务（某一个非关键服务<code>down</code>掉，可以继续使用），开放给前端就一个<code>api</code>接口即可，在这个<code>api</code>接口内做多个子查询，不需要前端调用多个<code>api</code>进行查询，避免由于某一个<code>api</code>服务挂掉而导致阻塞<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">location = /api/test_parallels &#123;</span><br><span class="line">content_by_lua_block &#123;</span><br><span class="line">local start_time = ngx.now()</span><br><span class="line">local res1, res2 = ngx.location.capture_multi(&#123;</span><br><span class="line">  &#123;<span class="string">"/sum"</span>,&#123;args=&#123;<span class="attribute">a</span>=3, <span class="attribute">b</span>=8&#125;&#125;&#125;,</span><br><span class="line">  &#123;<span class="string">"/subduction"</span>,&#123;args=&#123;<span class="attribute">a</span>=3, <span class="attribute">b</span>=8&#125;&#125;&#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">ngx.say(<span class="string">"status:"</span>, res1.status, <span class="string">"response:"</span>, res1.body)</span><br><span class="line">ngx.say(<span class="string">"status:"</span>, res2.status, <span class="string">"response:"</span>, res2.body)</span><br><span class="line">ngx.say(<span class="string">"time used:"</span>, ngx.now()-start_time)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="1-9-执行阶段"><a href="#1-9-执行阶段" class="headerlink" title="1.9 执行阶段"></a>1.9 执行阶段</h3><p>这个是<code>Nginx</code>和<code>OpenResty</code>独有的概念，不同的阶段有不同的处理行为，可参考<a href="https://moonbingbing.gitbooks.io/openresty-best-practices/content/ngx_lua/phase.html" target="_blank" rel="noopener">执行阶段概念</a></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>更改conf后，检查conf文件是否正确：<code>nginx -t -c [conf]</code><br>重启：<code>nginx：nginx -s reload -p [path]</code></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="http://www.stuq.org/course/1015/study" target="_blank" rel="noopener">OpenResty 系列课程</a></li><li><a href="http://openresty.org/en/" target="_blank" rel="noopener">OpenResty官网</a></li><li><a href="https://github.com/openresty" target="_blank" rel="noopener">OpenResty</a></li></ul><h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p><ul><li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li><li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li><li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li><li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li><li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li></ul><p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;观看&lt;a href=&quot;http://www.stuq.org/course/1015/study&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OpenResty 系列课程&lt;/a&gt;的学习笔记&lt;br&gt;
    
    </summary>
    
      <category term="OpenResty" scheme="http://answerywj.com/categories/OpenResty/"/>
    
    
      <category term="OpenResty" scheme="http://answerywj.com/tags/OpenResty/"/>
    
  </entry>
  
  <entry>
    <title>记一次踩坑|空table应该编码为数组还是对象</title>
    <link href="http://answerywj.com/2017/06/16/table-encode-as-array-or-object/"/>
    <id>http://answerywj.com/2017/06/16/table-encode-as-array-or-object/</id>
    <published>2017-06-16T07:58:40.000Z</published>
    <updated>2019-03-16T07:13:16.625Z</updated>
    
    <content type="html"><![CDATA[<p><code>Json</code>有两种比较常用的数据类型：被<code>{}</code>包裹的对象（<code>object</code>），被<code>[]</code>包裹的数组（<code>array</code>）</p><a id="more"></a><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>从第三方<code>API</code>返回的<code>json</code>数据，存在一个<code>key</code>的值为空数组，可是经过<code>decode</code>和<code>encode</code>这两步操作后，这个<code>key</code>的值就变为空对象了：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span>(<span class="string">'cjson'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> raw = &#123;&#125;</span><br><span class="line">raw.name = <span class="string">'answer'</span></span><br><span class="line">raw.list = &#123;&#125;</span><br><span class="line"><span class="keyword">local</span> str = cjson.encode(raw)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'after cjson encode:'</span>, str)</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">after</span> cjson encode:&#123;<span class="string">"name"</span>:<span class="string">"answer"</span>,<span class="string">"list"</span>:&#123;&#125;&#125;</span><br></pre></td></tr></table></figure></p><p><code>cjson</code>对于空的<code>table</code>，会默认处理为<code>object</code>，对于<code>Lua</code>本身，是无法区分空数组和空字典的（数组和字典融合到一起了），但是对于强类型语言(<code>C/C++, Java</code>等)，这时候就会出现问题，必须作容错处理</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="使用encode-empty-table-as-object方法"><a href="#使用encode-empty-table-as-object方法" class="headerlink" title="使用encode_empty_table_as_object方法"></a>使用<code>encode_empty_table_as_object</code>方法</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span>(<span class="string">'cjson'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> raw = &#123;&#125;</span><br><span class="line">raw.name = <span class="string">'answer'</span></span><br><span class="line">raw.list = &#123;&#125;</span><br><span class="line">cjson.encode_empty_table_as_object(<span class="literal">false</span>)</span><br><span class="line"><span class="keyword">local</span> str = cjson.encode(raw)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'after cjson encode:'</span>, str)</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">after cjson encode:&#123;<span class="string">"name"</span>:<span class="string">"answer"</span>,<span class="string">"list"</span>:<span class="string">[]</span>&#125;</span><br></pre></td></tr></table></figure></p><h3 id="更换dkjson库"><a href="#更换dkjson库" class="headerlink" title="更换dkjson库"></a>更换<code>dkjson</code>库</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> dkjson = <span class="built_in">require</span>(<span class="string">'dkjson'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> raw = &#123;&#125;</span><br><span class="line">raw.name = <span class="string">'answer'</span></span><br><span class="line">raw.list = &#123;&#125;</span><br><span class="line"><span class="keyword">local</span> str = dkjson.encode(raw)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'after cjson encode:'</span>, str)</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">after cjson encode:&#123;<span class="string">"name"</span>:<span class="string">"answer"</span>,<span class="string">"list"</span>:<span class="string">[]</span>&#125;</span><br></pre></td></tr></table></figure></p><h3 id="使用metatable将table标记为array"><a href="#使用metatable将table标记为array" class="headerlink" title="使用metatable将table标记为array"></a>使用<code>metatable</code>将<code>table</code>标记为<code>array</code></h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span>(<span class="string">'cjson'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> raw = &#123;&#125;</span><br><span class="line">raw.name = <span class="string">'answer'</span></span><br><span class="line">raw.list = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(raw.list, cjson.empty_array_mt)</span><br><span class="line"><span class="keyword">local</span> str = cjson.encode(raw)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'after cjson encode:'</span>, str)</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">after cjson encode:&#123;<span class="string">"name"</span>:<span class="string">"answer"</span>,<span class="string">"list"</span>:<span class="string">[]</span>&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://moonbingbing.gitbooks.io/openresty-best-practices/content/json/array_or_object.html" target="_blank" rel="noopener">编码为 array 还是 object</a></li><li><a href="http://blog.csdn.net/ljfrocky/article/details/53034932?_t=t" target="_blank" rel="noopener">使用lua CJSON库如何将空table编码成数组</a></li><li><a href="https://github.com/openresty/lua-cjson" target="_blank" rel="noopener">openresty/lua-cjson</a></li></ul><h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p><ul><li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li><li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li><li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li><li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li><li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li></ul><p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Json&lt;/code&gt;有两种比较常用的数据类型：被&lt;code&gt;{}&lt;/code&gt;包裹的对象（&lt;code&gt;object&lt;/code&gt;），被&lt;code&gt;[]&lt;/code&gt;包裹的数组（&lt;code&gt;array&lt;/code&gt;）&lt;/p&gt;
    
    </summary>
    
      <category term="Lua" scheme="http://answerywj.com/categories/Lua/"/>
    
    
      <category term="lua-cjson" scheme="http://answerywj.com/tags/lua-cjson/"/>
    
  </entry>
  
  <entry>
    <title>科普|云计算的四种服务模式介绍</title>
    <link href="http://answerywj.com/2017/03/23/Introduction-to-four-service-of-cloud-computing/"/>
    <id>http://answerywj.com/2017/03/23/Introduction-to-four-service-of-cloud-computing/</id>
    <published>2017-03-23T06:18:40.000Z</published>
    <updated>2019-03-16T07:13:16.537Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍<em>SaaS</em>，<em>BaaS</em>，<em>PaaS</em>和<em>IaaS</em>这四种云计算服务模式，并分析之间的联系和区别。</p><a id="more"></a><h2 id="四种服务模式介绍"><a href="#四种服务模式介绍" class="headerlink" title="四种服务模式介绍"></a>四种服务模式介绍</h2><ul><li>SaaS（Software as a Service）：软件即服务，<em>SaaS</em>公司提供完整并可直接使用的应用程序，用户通过网页浏览器即可接入使用。比较知名的<em>SaaS</em>有<em>GoToMeeting</em>，<em>WebEx</em>和<em>Salesforce</em>。</li><li>BaaS（Backend as a Service）：后端即服务，为移动应用开发者提供后端云服务，包括云端数据存储、账户管理和消息推送等，简化了应用开发流程。这里推荐一篇对<em>BaaS</em>介绍的<a href="http://www.jianshu.com/p/4381f0a0692e" target="_blank" rel="noopener">文章</a>。</li><li>PaaS（Platform as a Service）：平台即服务，也被叫做中间件。用户通过<em>Internet</em>可以使用<em>PaaS</em>公司在网上提供的各种开发和分发应用的解决方案，比如虚拟服务器和操作系统等，软件的开发和运行都可以在提供的平台上进行。不仅节约了硬件成本，更大大提高了协作开发的效率。比较知名的<em>PaaS</em>有<em>Google App Engine</em>，<em>Microsoft Azure</em>和<em>AppFog</em>。</li><li>IaaS（Infrastructure as a Service）：基础设施即服务，用户通过租用<em>IaaS</em>公司的服务器，存储和网络硬件，利用<em>Internet</em>就可以完善地获取计算机基础设施服务，大大节约了硬件成本。比较知名的<em>IaaS</em>有<em>Amazon</em>，<em>Microsoft</em>和<em>Aliyun</em>等。</li></ul><h2 id="四种服务模式的关系"><a href="#四种服务模式的关系" class="headerlink" title="四种服务模式的关系"></a>四种服务模式的关系</h2><ul><li><em>PaaS</em>构建在<em>IaaS</em>之上，在基础架构之外还提供了业务软件的运行环境。</li><li><em>SaaS</em>同<em>PaaS</em>的区别在于，使用<em>SaaS</em>的不是软件的开发人员，而是软件的最终用户。</li><li><em>BaaS</em>属于<em>PaaS</em>的范畴，但两者也有区别。<em>BaaS</em>简化了应用开发流程，而<em>PaaS</em>简化了应用部署流程。</li></ul><p><img src="http://o9zpdspb3.bkt.clouddn.com/Introduction-to-four-service-of-cloud-computing.jpg" alt></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="http://www.jianshu.com/p/6148c47792c3" target="_blank" rel="noopener">云计算的三种服务模式</a></li><li><a href="http://www.jianshu.com/p/4381f0a0692e" target="_blank" rel="noopener">三分钟了解什么是 BaaS</a></li></ul><h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p><ul><li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li><li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li><li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li><li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li><li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li></ul><p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍&lt;em&gt;SaaS&lt;/em&gt;，&lt;em&gt;BaaS&lt;/em&gt;，&lt;em&gt;PaaS&lt;/em&gt;和&lt;em&gt;IaaS&lt;/em&gt;这四种云计算服务模式，并分析之间的联系和区别。&lt;/p&gt;
    
    </summary>
    
      <category term="Knowledge" scheme="http://answerywj.com/categories/Knowledge/"/>
    
    
      <category term="Cloud Computing" scheme="http://answerywj.com/tags/Cloud-Computing/"/>
    
  </entry>
  
  <entry>
    <title>UNIX网络编程-listen函数及其包裹函数介绍</title>
    <link href="http://answerywj.com/2017/02/23/listen-in-unix/"/>
    <id>http://answerywj.com/2017/02/23/listen-in-unix/</id>
    <published>2017-02-23T09:14:17.000Z</published>
    <updated>2019-03-16T07:13:16.621Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍UNIX网络编程中<code>listen</code>函数及其包裹函数。</p><hr><a id="more"></a><h3 id="函数简介"><a href="#函数简介" class="headerlink" title="函数简介"></a>函数简介</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line">                                返回：若成功则为<span class="number">0</span>，若出错则为<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>目前<code>listen</code>函数仅为<code>TCP</code>服务器调用，主要完成两个任务：</p><ol><li>将<code>socket</code>函数创建的还未建立连接的主动套接字转换为被动(监听)套接字，使内核接受指向该套接字的连接。</li><li>使用第二个参数规定了内核为相应套接字排队的最大连接个数。</li></ol><blockquote><p>tips：<code>socket</code>函数创建的套接字被默认为一个主动套接字，即该套接字为将调用<code>connect</code>函数发起连接的客户套接字。而<code>listen</code>函数导致该套接字从<code>CLOSED</code>状态转换为<code>LISTEN</code>状态。</p></blockquote><h3 id="包裹函数-下载"><a href="#包裹函数-下载" class="headerlink" title="包裹函数(下载)"></a>包裹函数(<a href="https://github.com/AnSwErYWJ/UNP/blob/master/TCP/Listen.c" target="_blank" rel="noopener">下载</a>)</h3><p>历史上总是将<code>backlog</code>设为5，但已无法满足现在服务器的需求了，所以需要指定一个较大的<code>backlog</code>才能满足繁忙的需求。一种方法是使用一个常值，可是每次增长都需要重新编译，比较麻烦；另一种方法是设定默认值，然后允许通过命令行或环境变量覆盖默认值：<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">void Listen(<span class="built_in">int</span> fd,<span class="built_in">int</span> backlog)</span><br><span class="line">&#123;</span><br><span class="line">    char *<span class="built_in">ptr</span><span class="comment">;</span></span><br><span class="line">    <span class="keyword">if</span>((<span class="built_in">ptr</span> = getenv(<span class="string">"LISTENQ"</span>)) != <span class="literal">NULL</span>)</span><br><span class="line">        backlog = atoi(<span class="built_in">ptr</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(listen(fd,backlog) == <span class="number">-1</span>)</span><br><span class="line">        perror(<span class="string">"Listen error"</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样就可以通过设置环境变量<code>LISTENQ</code>来动态配置<code>backlog</code>的大小。</p><blockquote><p>tips：<code>backlog</code>为0不代表就不会有客户连接到你的机器。如果不想让客户连接，请直接关闭该套接字。</p></blockquote><h3 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h3><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p><ul><li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li><li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li><li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li><li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li><li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li></ul><p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍UNIX网络编程中&lt;code&gt;listen&lt;/code&gt;函数及其包裹函数。&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="C" scheme="http://answerywj.com/categories/C/"/>
    
    
      <category term="tcp" scheme="http://answerywj.com/tags/tcp/"/>
    
      <category term="listen" scheme="http://answerywj.com/tags/listen/"/>
    
  </entry>
  
  <entry>
    <title>WAVE音频文件格式分析--实现C语言读写文件头</title>
    <link href="http://answerywj.com/2017/01/09/wave/"/>
    <id>http://answerywj.com/2017/01/09/wave/</id>
    <published>2017-01-09T06:54:17.000Z</published>
    <updated>2019-03-16T07:13:16.649Z</updated>
    
    <content type="html"><![CDATA[<p>本文将详细分析WAVE音频文件的格式,并通过C语言对wave文件头进行读写操作。</p><hr><a id="more"></a><h2 id="WAVE音频文件格式分析–实现C语言读写文件头"><a href="#WAVE音频文件格式分析–实现C语言读写文件头" class="headerlink" title="WAVE音频文件格式分析–实现C语言读写文件头"></a>WAVE音频文件格式分析–实现C语言读写文件头</h2><h3 id="WAVE音频文件"><a href="#WAVE音频文件" class="headerlink" title="WAVE音频文件"></a>WAVE音频文件</h3><p>WAVE文件格式是一种由微软和IBM联合开发的用于音频数字存储的标准, 它采用<em>RIFF(Resource Interchange File Format,资源交换文件标准)</em>文件格式结构文件的扩展名为<em>“WAV”</em>, 所有的<em>WAV</em>都有一个文件头, 数据本身的格式为<em>PCM</em>或压缩型.  </p><h3 id="WAVE文件头"><a href="#WAVE文件头" class="headerlink" title="WAVE文件头"></a>WAVE文件头</h3><p><em>WAVE</em>文件分成两部分:文件头和数据块. <em>WAV</em>格式文件主要有两种文件头: 标准的44字节文件头和经过了一些软件处理的58字节文件头.<br><em>WAVE</em>文件头包含RIFF数据块,一个<em>“fmt”</em>数据块和一个<em>“data”</em>数据块</p><blockquote><p>本文所介绍的<em>WAV</em>文件头是标准的44字节文件头.</p></blockquote><h3 id="WAVE文件格式"><a href="#WAVE文件格式" class="headerlink" title="WAVE文件格式"></a>WAVE文件格式</h3><p><img src="http://o9zpdspb3.bkt.clouddn.com/wave.png" alt="wave format"></p><blockquote><p><strong>纠正</strong>: ByteRate应该为每秒存储的字节数</p></blockquote><p>通过<em>WAVE</em>文件头信息,我们可以计算出播放时长:<br><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">文件播放时长 </span>=<span class="string"> Subchunk2Size/ByteRate</span></span><br></pre></td></tr></table></figure></p><h3 id="C语言实现对WAVE文件头的读写"><a href="#C语言实现对WAVE文件头的读写" class="headerlink" title="C语言实现对WAVE文件头的读写"></a>C语言实现对<strong>WAVE</strong>文件头的读写</h3><p>这里我提供了几个接口供大家使用,<a href="https://github.com/AnSwErYWJ/AudioResamplerate/blob/master/src/waveHeader/handle_wave.c" target="_blank" rel="noopener">handle_wave.c</a> 和 <a href="https://github.com/AnSwErYWJ/AudioResamplerate/blob/master/include/waveHeader/handle_wave.h" target="_blank" rel="noopener">handle_wave.h</a>.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _HANDLE_WAVE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _HANDLE_WAVE_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span>  riff_id[<span class="number">4</span>];                       <span class="comment">//"RIFF"</span></span><br><span class="line">    <span class="keyword">int</span>   riff_datasize;                    <span class="comment">// RIFF chunk data size,exclude riff_id[4] and riff_datasize,total - 8</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>  riff_type[<span class="number">4</span>];                     <span class="comment">// "WAVE"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>  fmt_id[<span class="number">4</span>];                        <span class="comment">// "fmt "</span></span><br><span class="line">    <span class="keyword">int</span>   fmt_datasize;                     <span class="comment">// fmt chunk data size,16 for pcm</span></span><br><span class="line">    <span class="keyword">short</span> fmt_compression_code;             <span class="comment">// 1 for PCM</span></span><br><span class="line">    <span class="keyword">short</span> fmt_channels;                     <span class="comment">// 1(mono) or 2(stereo)</span></span><br><span class="line">    <span class="keyword">int</span>   fmt_sample_rate;                  <span class="comment">// samples per second</span></span><br><span class="line">    <span class="keyword">int</span>   fmt_avg_bytes_per_sec;            <span class="comment">// sample_rate * channels * bit_per_sample / 8</span></span><br><span class="line">    <span class="keyword">short</span> fmt_block_align;                  <span class="comment">// number bytes per sample, bit_per_sample * channels / 8</span></span><br><span class="line">    <span class="keyword">short</span> fmt_bit_per_sample;               <span class="comment">// bits of each sample(8,16,32).</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>  data_id[<span class="number">4</span>];                       <span class="comment">// "data"</span></span><br><span class="line">    <span class="keyword">int</span>   data_datasize;                    <span class="comment">// data chunk size,pcm_size - 44</span></span><br><span class="line">&#125;WaveHeader_t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_wavheader</span><span class="params">(WaveHeader_t *wavheader)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_wavheader</span><span class="params">(FILE *fp,WaveHeader_t *wavheader)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write_wavheader</span><span class="params">(FILE *fp,WaveHeader_t wavheader)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_wavheader</span><span class="params">(WaveHeader_t wavheader)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"handle_wave.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* read and write integer from file stream */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_int</span><span class="params">(FILE *fp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *s;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    s = (<span class="keyword">char</span> *)&amp;i;</span><br><span class="line">    <span class="keyword">size_t</span> len = <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;n &lt; len;n++)</span><br><span class="line">    &#123;</span><br><span class="line">    s[n]=getc(fp);</span><br><span class="line">    <span class="comment">//printf("%x\n",s[n]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">put_int</span><span class="params">(<span class="keyword">int</span> i,FILE *fp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *s;</span><br><span class="line">    s=(<span class="keyword">char</span> *)&amp;i;</span><br><span class="line">    <span class="keyword">size_t</span> len = <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;n &lt; len;n++)</span><br><span class="line">    &#123;</span><br><span class="line">    putc(s[n],fp);</span><br><span class="line">        <span class="comment">//printf("%x\n",s[n]);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="title">get_sint</span><span class="params">(FILE *fp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *s;</span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> i;</span><br><span class="line">    s = (<span class="keyword">char</span> *)&amp;i;</span><br><span class="line">    <span class="keyword">size_t</span> len = <span class="keyword">sizeof</span>(<span class="keyword">short</span>);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;n &lt; len;n++)</span><br><span class="line">    &#123;</span><br><span class="line">    s[n]=getc(fp);</span><br><span class="line">    <span class="comment">//printf("%x\n",s[n]);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="title">put_sint</span><span class="params">(<span class="keyword">short</span> <span class="keyword">int</span> i,FILE *fp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *s;</span><br><span class="line">    s=(<span class="keyword">char</span> *)&amp;i;</span><br><span class="line">    <span class="keyword">size_t</span> len = <span class="keyword">sizeof</span>(<span class="keyword">short</span>);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;n &lt; len;n++)</span><br><span class="line">    &#123;</span><br><span class="line">    putc(s[n],fp);</span><br><span class="line">        <span class="comment">//printf("%x\n",s[n]);</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_wavheader</span><span class="params">(WaveHeader_t *wavheader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">sprintf</span>(wavheader-&gt;riff_id,<span class="string">"RIFF"</span>);</span><br><span class="line">    wavheader-&gt;riff_datasize = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(wavheader-&gt;riff_type,<span class="string">"WAVE"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(wavheader-&gt;fmt_id,<span class="string">"fmt "</span>);</span><br><span class="line">    wavheader-&gt;fmt_datasize = <span class="number">16</span>;</span><br><span class="line">    wavheader-&gt;fmt_compression_code = <span class="number">1</span>;</span><br><span class="line">    wavheader-&gt;fmt_channels = <span class="number">-1</span>;</span><br><span class="line">    wavheader-&gt;fmt_sample_rate = <span class="number">-1</span>;</span><br><span class="line">    wavheader-&gt;fmt_avg_bytes_per_sec = <span class="number">-1</span>;</span><br><span class="line">    wavheader-&gt;fmt_block_align = <span class="number">-1</span>;</span><br><span class="line">    wavheader-&gt;fmt_bit_per_sample = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(wavheader-&gt;data_id,<span class="string">"data"</span>);</span><br><span class="line">    wavheader-&gt;data_datasize = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_wavheader</span><span class="params">(FILE *fp,WaveHeader_t *wavheader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (fp ==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    fread(wavheader-&gt;riff_id,<span class="number">4</span>,<span class="number">1</span>,fp);</span><br><span class="line">    wavheader-&gt;riff_datasize = get_int(fp);</span><br><span class="line">    fread(wavheader-&gt;riff_type,<span class="number">4</span>,<span class="number">1</span>,fp);</span><br><span class="line">    fread(wavheader-&gt;fmt_id,<span class="number">4</span>,<span class="number">1</span>,fp);</span><br><span class="line">    wavheader-&gt;fmt_datasize = get_int(fp);</span><br><span class="line">    wavheader-&gt;fmt_compression_code = get_sint(fp);</span><br><span class="line">    wavheader-&gt;fmt_channels = get_sint(fp);</span><br><span class="line">    wavheader-&gt;fmt_sample_rate = get_int(fp);</span><br><span class="line">    wavheader-&gt;fmt_avg_bytes_per_sec = get_int(fp);</span><br><span class="line">    wavheader-&gt;fmt_block_align = get_sint(fp);</span><br><span class="line">    wavheader-&gt;fmt_bit_per_sample = get_sint(fp);</span><br><span class="line">    fread(wavheader-&gt;data_id,<span class="number">4</span>,<span class="number">1</span>,fp);</span><br><span class="line">    wavheader-&gt;data_datasize = get_int(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write_wavheader</span><span class="params">(FILE *fp,WaveHeader_t wavheader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (fp ==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    fwrite(wavheader.riff_id,<span class="number">4</span>,<span class="number">1</span>,fp);</span><br><span class="line">    put_int(wavheader.riff_datasize,fp);</span><br><span class="line">    fwrite(wavheader.riff_type,<span class="number">4</span>,<span class="number">1</span>,fp);</span><br><span class="line">    fwrite(wavheader.fmt_id,<span class="number">4</span>,<span class="number">1</span>,fp);</span><br><span class="line">    put_int(wavheader.fmt_datasize,fp);</span><br><span class="line">    put_sint(wavheader.fmt_compression_code,fp);</span><br><span class="line">    put_sint(wavheader.fmt_channels,fp);</span><br><span class="line">    put_int(wavheader.fmt_sample_rate,fp);</span><br><span class="line">    put_int(wavheader.fmt_avg_bytes_per_sec,fp);</span><br><span class="line">    put_sint(wavheader.fmt_block_align,fp);</span><br><span class="line">    put_sint(wavheader.fmt_bit_per_sample,fp);</span><br><span class="line">    fwrite(wavheader.data_id,<span class="number">4</span>,<span class="number">1</span>,fp);</span><br><span class="line">    put_int(wavheader.data_datasize,fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_wavheader</span><span class="params">(WaveHeader_t wavheader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"wavheader.riff_id: %c%c%c%c\n"</span>,wavheader.riff_id[<span class="number">0</span>],wavheader.riff_id[<span class="number">1</span>],wavheader.riff_id[<span class="number">2</span>],wavheader.riff_id[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"wavheader.riff_datasize: %d\n"</span>,wavheader.riff_datasize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"wavheader.riff_type: %c%c%c%c\n"</span>,wavheader.riff_type[<span class="number">0</span>],wavheader.riff_type[<span class="number">1</span>],wavheader.riff_type[<span class="number">2</span>],wavheader.riff_type[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"wavheader.fmt_id: %c%c%c%c\n"</span>,wavheader.fmt_id[<span class="number">0</span>],wavheader.fmt_id[<span class="number">1</span>],wavheader.fmt_id[<span class="number">2</span>],wavheader.fmt_id[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"wavheader.fmt_datasize: %d\n"</span>,wavheader.fmt_datasize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"wavheader.fmt_compression_code: %hd\n"</span>,wavheader.fmt_compression_code);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"wavheader.fmt_channels: %hd\n"</span>,wavheader.fmt_channels);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"wavheader.fmt_sample_rate: %d\n"</span>,wavheader.fmt_sample_rate);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"wavheader.fmt_avg_bytes_per_sec: %d\n"</span>,wavheader.fmt_avg_bytes_per_sec);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"wavheader.fmt_block_align: %hd\n"</span>,wavheader.fmt_block_align);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"wavheader.fmt_bit_per_sample: %hd\n"</span>,wavheader.fmt_bit_per_sample);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"wavheader.data_id: %c%c%c%c\n"</span>,wavheader.data_id[<span class="number">0</span>],wavheader.data_id[<span class="number">1</span>],wavheader.data_id[<span class="number">2</span>],wavheader.data_id[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"wavheader.data_datasize: %d\n"</span>,wavheader.data_datasize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p><ul><li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li><li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li><li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li><li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li><li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li></ul><p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将详细分析WAVE音频文件的格式,并通过C语言对wave文件头进行读写操作。&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="C" scheme="http://answerywj.com/categories/C/"/>
    
    
      <category term="wave文件头" scheme="http://answerywj.com/tags/wave%E6%96%87%E4%BB%B6%E5%A4%B4/"/>
    
  </entry>
  
  <entry>
    <title>C程序判断你主机的数据存储方式(大端和小端)</title>
    <link href="http://answerywj.com/2016/12/07/big-endian-and-little-endian/"/>
    <id>http://answerywj.com/2016/12/07/big-endian-and-little-endian/</id>
    <published>2016-12-07T03:16:51.000Z</published>
    <updated>2019-03-16T07:13:16.537Z</updated>
    
    <content type="html"><![CDATA[<p>本文将使用C语言编写一个可以判断你主机数据存储方式(大端和小端)的程序.</p><hr><a id="more"></a><h2 id="C程序判断你主机的数据存储方式-大端和小端"><a href="#C程序判断你主机的数据存储方式-大端和小端" class="headerlink" title="C程序判断你主机的数据存储方式(大端和小端)"></a>C程序判断你主机的数据存储方式(大端和小端)</h2><h3 id="大端和小端字节序"><a href="#大端和小端字节序" class="headerlink" title="大端和小端字节序"></a>大端和小端字节序</h3><p>计算机硬件存储数据的方式有两种: 大端字节序(big endian) 和 小端字节序(little endian),两者的区别可以简单理解为:</p><ul><li>大端: 数据高位字节放在内存低地址(人类读写的习惯).</li><li>小端: 数据高位字节放在内存高地址.</li></ul><p>如现在有数 0x1234,则两者存储方式如下:<br><img src="http://o9zpdspb3.bkt.clouddn.com/%E5%A4%A7%E5%B0%8F%E7%AB%AF.png" alt="大小端"></p><blockquote><p> 既然大端字节序符合人类读写的习惯,那么为什么会有小端字节序呢？<br>因为大多数默认情况下计算机的电路先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，计算机的内部处理都是小端字节序。但是，人类还是习惯读写大端字节序。所以，除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存。</p></blockquote><p>当然并不是所有的计算机处理器都是小端模式的,目前IBM和Freescale的一些处理器以及一些常见的单片机芯片等都是采用大端字节序存储数据.而市面上大部分CPU则是采用小端字节序,如intel等.</p><h3 id="实现-完整代码"><a href="#实现-完整代码" class="headerlink" title="实现(完整代码)"></a>实现(<a href="https://github.com/AnSwErYWJ/DogFood/blob/master/C/host_byte_order.c" target="_blank" rel="noopener">完整代码</a>)</h3><p>本例都认为short占2个字节,不考虑可移植的情况.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> _byteorder</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">short</span> s;</span><br><span class="line">    <span class="keyword">char</span> c[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> _byteorder un;</span><br><span class="line"></span><br><span class="line">    un.s = <span class="number">0x0102</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">sizeof</span>(<span class="keyword">short</span>) == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(un.c[<span class="number">0</span>] == <span class="number">2</span> &amp;&amp; un.c[<span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"little-endian\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(un.c[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; un.c[<span class="number">1</span>] == <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"big-endian\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Error:can not judge host byte order.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"sizeof(short) = %ld\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">short</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里利用了<code>union</code> 中所有的数据成员共用一个空间，同一时间只能储存其中一个数据成员的特性.<br>首先分配了一个占2个字节的内存空间(<code>union</code>分配的空间需要容纳最大长度的数据成员),将<code>0x0102</code>赋予<code>short</code>型变量.<br>然后利用<code>char</code>数组,按一个字节的长度依次取出数据,然后利用上节介绍的大小端存储方式的不同进行判断.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2016/11/byte-order.html" target="_blank" rel="noopener">理解字节序</a></li></ul><h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p><ul><li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li><li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li><li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li><li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li><li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li></ul><p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将使用C语言编写一个可以判断你主机数据存储方式(大端和小端)的程序.&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="C" scheme="http://answerywj.com/categories/C/"/>
    
    
      <category term="大小端字节序" scheme="http://answerywj.com/tags/%E5%A4%A7%E5%B0%8F%E7%AB%AF%E5%AD%97%E8%8A%82%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>从文件流中读写整数--C语言</title>
    <link href="http://answerywj.com/2016/12/06/getw-and-putw/"/>
    <id>http://answerywj.com/2016/12/06/getw-and-putw/</id>
    <published>2016-12-06T06:16:51.000Z</published>
    <updated>2019-03-16T07:13:16.585Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍在文本流中,读写整数的两个接口– <code>int getw(FILE *fp)</code>和<code>int putw(int w, FILE *fp)</code>,并且与你分享改进后的更实用的接口– <code>unsigned int get_uint(FILE *fp)</code>和<code>unsigned int put_uint(unsigned int i,FILE *fp)</code>.</p><hr><a id="more"></a><h2 id="从文件流中读写整数–C语言"><a href="#从文件流中读写整数–C语言" class="headerlink" title="从文件流中读写整数–C语言"></a>从文件流中读写整数–C语言</h2><p>我们都知道,数据在计算机内存中都是以二进制的形式存储的,大多数PC的存储方式为小端存储,关于大小端字节序的讨论请参考<a href="http://www.ruanyifeng.com/blog/2016/11/byte-order.html" target="_blank" rel="noopener">阮一峰的理解字节序</a>. 如果想直接读写整数,并不是很方便,这里就为你介绍两个接口,需要注意的是这两个接口非ANSI标准函数.</p><h3 id="getw"><a href="#getw" class="headerlink" title="getw"></a>getw</h3><p>函数原型：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getw</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure></p><p>函数功能：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从<span class="built_in">fp</span>所指向文件读取下一个整数.</span><br></pre></td></tr></table></figure></p><p>返回值：<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回输入的整数,如果文件结束或者出错返回-<span class="number">1</span>.</span><br></pre></td></tr></table></figure></p><h3 id="putw"><a href="#putw" class="headerlink" title="putw"></a>putw</h3><p>函数原型：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putw</span><span class="params">(<span class="keyword">int</span> w, FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure></p><p>函数功能：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将整型w写进<span class="built_in">fp</span>指向的文件.</span><br></pre></td></tr></table></figure></p><p>返回值：<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回输出的整数,如果出错,则返回EOF.</span><br></pre></td></tr></table></figure></p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>代码:<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"></span><br><span class="line">int main(int argc,char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">FILE *<span class="built_in">fp</span> = NULL<span class="comment">;</span></span><br><span class="line">    int num[<span class="number">2</span>] = &#123;-<span class="number">2147483648</span>,<span class="number">2147483647</span>&#125;<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">fp</span> = fopen(<span class="string">"./log"</span>, <span class="string">"wb"</span>)<span class="comment">;</span></span><br><span class="line">    if (<span class="built_in">fp</span> == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,<span class="string">"open file failed"</span>)<span class="comment">;</span></span><br><span class="line">        exit(EXIT_FAILURE)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    putw(num[<span class="number">0</span>],<span class="built_in">fp</span>)<span class="comment">;</span></span><br><span class="line">    putw(num[<span class="number">1</span>],<span class="built_in">fp</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    fclose(<span class="built_in">fp</span>)<span class="comment">;</span></span><br><span class="line">    <span class="built_in">fp</span> = NULL<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">fp</span> = fopen(<span class="string">"./log"</span>, <span class="string">"rb"</span>)<span class="comment">;</span></span><br><span class="line">    if (<span class="built_in">fp</span> == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,<span class="string">"open file failed"</span>)<span class="comment">;</span></span><br><span class="line">        exit(EXIT_FAILURE)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(<span class="string">"%d %d\n"</span>,getw(<span class="built_in">fp</span>),getw(<span class="built_in">fp</span>))<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    fclose(<span class="built_in">fp</span>)<span class="comment">;</span></span><br><span class="line"><span class="built_in">fp</span> = NULL<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    return <span class="number">0</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果为:<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="number">2147483647</span> -<span class="number">2147483648</span></span><br></pre></td></tr></table></figure></p><blockquote><p>注意: 函数参数的压栈顺序是从左到右的,所以最后一个参数<code>getw(fp)</code>在栈顶,第一个出栈执行.</p></blockquote><h3 id="实现与改进-完整代码"><a href="#实现与改进-完整代码" class="headerlink" title="实现与改进(完整代码)"></a>实现与改进(<a href="https://github.com/AnSwErYWJ/DogFood/blob/master/C/file/io2stream.c" target="_blank" rel="noopener">完整代码</a>)</h3><p>由于上述两个接口支持的是int型,所以取值范围为<code>-2147483648～2147483647</code>.(此文认为int型都为4个字节).笔者需要使用这两个接口去读写文件的大小,负数无用处的,所以决定改装一下这两个函数,顺便探究一下这个函数的实现:<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">unsigned int get_uint(FILE *<span class="built_in">fp</span>)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char *s<span class="comment">;</span></span><br><span class="line">    unsigned int i<span class="comment">;</span></span><br><span class="line">    s = (unsigned char *)&amp;i<span class="comment">;</span></span><br><span class="line">    s[<span class="number">0</span>]=getc(<span class="built_in">fp</span>)<span class="comment">;</span></span><br><span class="line">    printf(<span class="string">"%x\n"</span>,s[<span class="number">0</span>])<span class="comment">;</span></span><br><span class="line">    s[<span class="number">1</span>]=getc(<span class="built_in">fp</span>)<span class="comment">;</span></span><br><span class="line">    printf(<span class="string">"%x\n"</span>,s[<span class="number">1</span>])<span class="comment">;</span></span><br><span class="line">    s[<span class="number">2</span>]=getc(<span class="built_in">fp</span>)<span class="comment">;</span></span><br><span class="line">    printf(<span class="string">"%x\n"</span>,s[<span class="number">2</span>])<span class="comment">;</span></span><br><span class="line">    s[<span class="number">3</span>]=getc(<span class="built_in">fp</span>)<span class="comment">;</span></span><br><span class="line">    printf(<span class="string">"%x\n"</span>,s[<span class="number">3</span>])<span class="comment">;</span></span><br><span class="line">    return i<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">put_uint</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> i,FILE *fp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *s;</span><br><span class="line">    s=(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)&amp;i;</span><br><span class="line">    putc(s[<span class="number">0</span>],fp);</span><br><span class="line">    <span class="comment">//printf("%x\n",s[0]);</span></span><br><span class="line">    putc(s[<span class="number">1</span>],fp);</span><br><span class="line">    <span class="comment">//printf("%x\n",s[1]);</span></span><br><span class="line">    putc(s[<span class="number">2</span>],fp);</span><br><span class="line">    <span class="comment">//printf("%x\n",s[2]);</span></span><br><span class="line">    putc(s[<span class="number">3</span>],fp);</span><br><span class="line">    <span class="comment">//printf("%x\n",s[3]);</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>改进后取值范围为<code>0~4294967295</code>.</p></blockquote><p>同理,你也可以将这两个接口改为支持 <code>long long</code>和<code>unsigned long int</code>等不同长度的整数类型.</p><h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p><ul><li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li><li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li><li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li><li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li><li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li></ul><p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍在文本流中,读写整数的两个接口– &lt;code&gt;int getw(FILE *fp)&lt;/code&gt;和&lt;code&gt;int putw(int w, FILE *fp)&lt;/code&gt;,并且与你分享改进后的更实用的接口– &lt;code&gt;unsigned int get_uint(FILE *fp)&lt;/code&gt;和&lt;code&gt;unsigned int put_uint(unsigned int i,FILE *fp)&lt;/code&gt;.&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="C" scheme="http://answerywj.com/categories/C/"/>
    
    
      <category term="getw" scheme="http://answerywj.com/tags/getw/"/>
    
  </entry>
  
  <entry>
    <title>Linux下处理json数据</title>
    <link href="http://answerywj.com/2016/10/10/jq/"/>
    <id>http://answerywj.com/2016/10/10/jq/</id>
    <published>2016-10-10T02:50:40.000Z</published>
    <updated>2019-03-16T07:13:16.621Z</updated>
    
    <content type="html"><![CDATA[<p>当我们在Linux下需要处理json数据时,第一反应是用脚本编写一个工具,这样即耗时又不通用. 本文将介绍专门的命令行json处理工具<strong>jq</strong>.<br><a id="more"></a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Ubuntu用户可以直接使用下列命令安装:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-<span class="builtin-name">get</span> install jq</span><br></pre></td></tr></table></figure></p><p>也可以选择<a href="https://github.com/stedolan/jq" target="_blank" rel="noopener">源码</a>安装,当然最简单的方法是直接下载<a href="https://stedolan.github.io/jq/" target="_blank" rel="noopener">可执行文件</a>,不过需要找到适配你系统的版本.</p><p>详细的安装方法可以参考<a href="https://stedolan.github.io/jq/download/" target="_blank" rel="noopener">这里</a>.</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>首先构建一个基本的字符串作为示例 test.json:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"中国"</span>,</span><br><span class="line">    <span class="attr">"province"</span>: [&#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"黑龙江"</span>,</span><br><span class="line">        <span class="attr">"cities"</span>: &#123;</span><br><span class="line">            <span class="attr">"city"</span>: [<span class="string">"哈尔滨"</span>, <span class="string">"大庆"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"广东"</span>,</span><br><span class="line">        <span class="attr">"cities"</span>: &#123;</span><br><span class="line">            <span class="attr">"city"</span>: [<span class="string">"广州"</span>, <span class="string">"深圳"</span>, <span class="string">"珠海"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"台湾"</span>,</span><br><span class="line">        <span class="attr">"cities"</span>: &#123;</span><br><span class="line">            <span class="attr">"city"</span>: [<span class="string">"台北"</span>, <span class="string">"高雄"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"新疆"</span>,</span><br><span class="line">        <span class="attr">"cities"</span>: &#123;</span><br><span class="line">            <span class="attr">"city"</span>: [<span class="string">"乌鲁木齐"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="解析json对象"><a href="#解析json对象" class="headerlink" title="解析json对象"></a>解析json对象</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>cat test.json | jq <span class="string">'.name'</span></span><br><span class="line"><span class="string">"中国"</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$ </span>cat test.json | jq <span class="string">'.province[0].name'</span></span><br><span class="line"><span class="string">"黑龙江"</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$ </span>cat test.json | jq <span class="string">'.province[].name'</span></span><br><span class="line"><span class="string">"黑龙江"</span></span><br><span class="line"><span class="string">"广东"</span></span><br><span class="line"><span class="string">"台湾"</span></span><br><span class="line"><span class="string">"新疆"</span></span><br></pre></td></tr></table></figure><h3 id="提取字段"><a href="#提取字段" class="headerlink" title="提取字段"></a>提取字段</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">$ cat test.json | jq <span class="string">'.province[0]'</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"cities"</span>: &#123;</span><br><span class="line">    <span class="string">"city"</span>: [</span><br><span class="line">      <span class="string">"哈尔滨"</span>,</span><br><span class="line">      <span class="string">"大庆"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"黑龙江"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ cat test.json | jq <span class="string">'.province[]'</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"cities"</span>: &#123;</span><br><span class="line">    <span class="string">"city"</span>: [</span><br><span class="line">      <span class="string">"哈尔滨"</span>,</span><br><span class="line">      <span class="string">"大庆"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"黑龙江"</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"cities"</span>: &#123;</span><br><span class="line">    <span class="string">"city"</span>: [</span><br><span class="line">      <span class="string">"广州"</span>,</span><br><span class="line">      <span class="string">"深圳"</span>,</span><br><span class="line">      <span class="string">"珠海"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"广东"</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"cities"</span>: &#123;</span><br><span class="line">    <span class="string">"city"</span>: [</span><br><span class="line">      <span class="string">"台北"</span>,</span><br><span class="line">      <span class="string">"高雄"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"台湾"</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"cities"</span>: &#123;</span><br><span class="line">    <span class="string">"city"</span>: [</span><br><span class="line">      <span class="string">"乌鲁木齐"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"新疆"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ cat test.json | jq <span class="string">'.province[0] | &#123;name ,cities&#125;'</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"cities"</span>: &#123;</span><br><span class="line">    <span class="string">"city"</span>: [</span><br><span class="line">      <span class="string">"哈尔滨"</span>,</span><br><span class="line">      <span class="string">"大庆"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"黑龙江"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ cat test.json | jq <span class="string">'.province[0] | &#123;name&#125;'</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"黑龙江"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h2><p>keys用来提取json中的key元素:<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">$ cat test.json | jq <span class="string">'keys'</span></span><br><span class="line">[<span class="meta"></span></span><br><span class="line"><span class="meta">  <span class="meta-string">"name"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"province"</span></span></span><br><span class="line"><span class="meta"></span>]</span><br><span class="line"></span><br><span class="line">$ cat test.json | jq <span class="string">'.|keys'</span></span><br><span class="line">[<span class="meta"></span></span><br><span class="line"><span class="meta">  <span class="meta-string">"name"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"province"</span></span></span><br><span class="line"><span class="meta"></span>]</span><br><span class="line"></span><br><span class="line">$ cat test.json | jq <span class="string">'.province[0]|keys'</span></span><br><span class="line">[<span class="meta"></span></span><br><span class="line"><span class="meta">  <span class="meta-string">"cities"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"name"</span></span></span><br><span class="line"><span class="meta"></span>]</span><br><span class="line"></span><br><span class="line">$ cat test.json | jq <span class="string">'.province[]|keys'</span></span><br><span class="line">[<span class="meta"></span></span><br><span class="line"><span class="meta">  <span class="meta-string">"cities"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"name"</span></span></span><br><span class="line"><span class="meta"></span>]</span><br><span class="line">[<span class="meta"></span></span><br><span class="line"><span class="meta">  <span class="meta-string">"cities"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"name"</span></span></span><br><span class="line"><span class="meta"></span>]</span><br><span class="line">[<span class="meta"></span></span><br><span class="line"><span class="meta">  <span class="meta-string">"cities"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"name"</span></span></span><br><span class="line"><span class="meta"></span>]</span><br><span class="line">[<span class="meta"></span></span><br><span class="line"><span class="meta">  <span class="meta-string">"cities"</span>,</span></span><br><span class="line"><span class="meta">  <span class="meta-string">"name"</span></span></span><br><span class="line"><span class="meta"></span>]</span><br></pre></td></tr></table></figure></p><p>has用来判断是否存在某个key:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat <span class="keyword">test</span>.json | jq 'has(<span class="string">"name"</span>)'</span><br><span class="line"><span class="keyword">true</span></span><br><span class="line">$ cat <span class="keyword">test</span>.json | jq '.province[<span class="number">0</span>] | has(<span class="string">"name"</span>)'</span><br><span class="line"><span class="keyword">true</span></span><br><span class="line">$ cat <span class="keyword">test</span>.json | jq 'has(<span class="string">"noname"</span>)'</span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure></p><h3 id="验证json"><a href="#验证json" class="headerlink" title="验证json"></a>验证json</h3><p>若json串格式错误的话,可以直接使用jq运行,会报出具体错误.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有了这个工具.你就可以直接在命令行或者shell脚本对json数据进行操作了.</p><h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p><ul><li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li><li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li><li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li><li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li><li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li></ul><p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们在Linux下需要处理json数据时,第一反应是用脚本编写一个工具,这样即耗时又不通用. 本文将介绍专门的命令行json处理工具&lt;strong&gt;jq&lt;/strong&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://answerywj.com/categories/Linux/"/>
    
    
      <category term="json" scheme="http://answerywj.com/tags/json/"/>
    
  </entry>
  
  <entry>
    <title>Linux下C调用静态库和动态库</title>
    <link href="http://answerywj.com/2016/10/10/use-dynamic-and-static-library/"/>
    <id>http://answerywj.com/2016/10/10/use-dynamic-and-static-library/</id>
    <published>2016-10-10T02:50:40.000Z</published>
    <updated>2019-03-16T07:13:16.649Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍Linux下C调用静态库和动态库,使用的样例文件请点击<a href="https://github.com/AnSwErYWJ/DogFood/tree/master/C/aso" target="_blank" rel="noopener">这里</a>.<br><a id="more"></a></p><h2 id="样例文件"><a href="#样例文件" class="headerlink" title="样例文件"></a>样例文件</h2><p>welcome.c:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"welcome.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">welcome</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"welcome to my code world!\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>这是一个样例程序,打印一句话.</p></blockquote><p>welcome.h:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _WELCOME_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _WELCOME_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">welcome</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><blockquote><p>为上一个文件的声明.</p></blockquote><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>动态库和静态库二者的不同点在于代码被载入的时刻不同。</p><p>静态库的代码在编译过程中已经被载入可执行程序,因此体积比较大。动态库(共享库)的代码在可执行程序运行时才载入内存，在编译过程中仅简单的引用，因此代码体积比较小。</p><p>静态情况下,把库直接加载到程序中,而动态库链接的时候,它只是保留接口,将动态库与程序代码独立,这样就可以提高代码的可复用度，和降低程序的耦合度。</p><p>静态库在程序编译时会被连接到目标代码中，程序运行时将不再需要该静态库。动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入，因此在程序运行时还需要动态库存在.</p><h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><p>生成静态库文件:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -Wall -O2 -fPIC -I./  -c -o welcome<span class="selector-class">.o</span> welcome.c</span><br><span class="line">$ ar crv libwelcome<span class="selector-class">.a</span> welcome.o</span><br></pre></td></tr></table></figure></p><p>ar命令的参数如下:<br><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">参数        意义</span><br><span class="line"><span class="deletion">-r      将objfile文件插入静态库尾或者替换静态库中同名文件</span></span><br><span class="line"><span class="deletion">-x      从静态库文件中抽取文件objfile</span></span><br><span class="line"><span class="deletion">-t      打印静态库的成员文件列表</span></span><br><span class="line"><span class="deletion">-d      从静态库中删除文件objfile</span></span><br><span class="line"><span class="deletion">-s      重置静态库文件索引</span></span><br><span class="line"><span class="deletion">-v      创建文件冗余信息</span></span><br><span class="line"><span class="deletion">-c      创建静态库文件</span></span><br></pre></td></tr></table></figure></p><p>test-sta.c:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    welcome();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc <span class="built_in">test</span>-sta.c -o <span class="built_in">test</span>-sta ./libwelcome.a</span></span><br></pre></td></tr></table></figure></p><p>运行:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./<span class="built_in">test</span>-sta </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> welcome to my code world!</span></span><br></pre></td></tr></table></figure></p><h2 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h2><p>生成动态库文件:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o2 -fPIC -shared welcome<span class="selector-class">.c</span> -o libwelcome.so</span><br><span class="line">or</span><br><span class="line">$ gcc -o2 -fPIC -c welcome<span class="selector-class">.c</span> </span><br><span class="line">$ gcc -shared -o libwelcome<span class="selector-class">.so</span> welcome.o</span><br></pre></td></tr></table></figure></p><p>其中:</p><ul><li>fPIC : 产生与位置无关代码,全部使用相对地址.</li><li>shared : 生成动态库.</li></ul><h3 id="编译时加载-隐式"><a href="#编译时加载-隐式" class="headerlink" title="编译时加载(隐式)"></a>编译时加载(隐式)</h3><p>test-implicit.c:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    welcome();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>和静态库一样,测试代码不需要包含导出函数的头文件.</p></blockquote><p>编译:<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o2 -Wall -L. -lwelcome test-<span class="keyword">implicit</span>.c -o test-<span class="keyword">implicit</span></span><br></pre></td></tr></table></figure></p><p>查看<code>test-implicit</code>动态段信息,发现已经依赖<code>libwelcome.so</code>:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ldd test-implicit </span><br><span class="line">linux-vdso<span class="selector-class">.so</span>.<span class="number">1</span> =&gt;  (<span class="number">0</span>x00007f0902951000)</span><br><span class="line">libwelcome<span class="selector-class">.so</span> =&gt; ./libwelcome<span class="selector-class">.so</span> (<span class="number">0</span>x00007f090274f000)</span><br><span class="line">libstdc++<span class="selector-class">.so</span>.<span class="number">6</span> =&gt; /usr/lib64/libstdc++<span class="selector-class">.so</span>.<span class="number">6</span> (<span class="number">0</span>x0000003548600000)</span><br><span class="line">libm<span class="selector-class">.so</span>.<span class="number">6</span> =&gt; /lib64/libm<span class="selector-class">.so</span>.<span class="number">6</span> (<span class="number">0</span>x000000353de00000)</span><br><span class="line">libgcc_s<span class="selector-class">.so</span>.<span class="number">1</span> =&gt; /lib64/libgcc_s<span class="selector-class">.so</span>.<span class="number">1</span> (<span class="number">0</span>x0000003548200000)</span><br><span class="line">libc<span class="selector-class">.so</span>.<span class="number">6</span> =&gt; /lib64/libc<span class="selector-class">.so</span>.<span class="number">6</span> (<span class="number">0</span>x000000353da00000)</span><br><span class="line">/lib64/ld-linux-x86-<span class="number">64</span><span class="selector-class">.so</span>.<span class="number">2</span> (<span class="number">0</span>x000000353d600000)</span><br></pre></td></tr></table></figure></p><p>若此时直接运行,会提示找不到动态库:<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./test-<span class="keyword">implicit</span></span><br><span class="line">$ ./test-<span class="keyword">implicit</span>: error <span class="keyword">while</span> loading shared libraries: libwelcome.so: cannot open shared object <span class="keyword">file</span>: No such <span class="keyword">file</span> or directory</span><br></pre></td></tr></table></figure></p><p>可以通过下列三种方法解决:<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一 修改环境变量</span></span><br><span class="line">$ export LD_LIBRARY_PATH=$(pwd):$LD_LIBRARY_PATH</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二 将库文件链接到系统目录下</span></span><br><span class="line">$ ln -s ./libwelcome.so /usr/<span class="class"><span class="keyword">lib</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法三 修改/etc/ld.so.conf</span></span><br><span class="line">$ sudo echo $(pwd) &gt;&gt; <span class="regexp">/etc/ld</span>.so.conf</span><br><span class="line">$ sudo ldconfig</span><br></pre></td></tr></table></figure></p><p>再次运行:<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./test-<span class="keyword">implicit</span></span><br><span class="line">$ welcome to my code world<span class="comment">!</span></span><br></pre></td></tr></table></figure></p><h3 id="运行时链接-显式"><a href="#运行时链接-显式" class="headerlink" title="运行时链接(显式)"></a>运行时链接(显式)</h3><p>test-explicit.c:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIB <span class="meta-string">"./libwelcome.so"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * RTLD_NOW：将共享库中的所有函数加载到内存 </span></span><br><span class="line"><span class="comment">     * RTLD_LAZY：会推后共享库中的函数的加载操作，直到调用dlsym()时方加载某函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *dl = dlopen(LIB,RTLD_LAZY); <span class="comment">//打开动态库</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dl == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Error:failed to load libary.\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *error = dlerror(); <span class="comment">//检测错误</span></span><br><span class="line">    <span class="keyword">if</span> (error != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"%s\n"</span>,error);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*func)() = dlsym(dl,<span class="string">"welcome"</span>); <span class="comment">// 获取函数地址</span></span><br><span class="line">    error = dlerror(); <span class="comment">//检测错误</span></span><br><span class="line">    <span class="keyword">if</span> (error != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"%s\n"</span>,error);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func(); <span class="comment">//调用动态库中的函数</span></span><br><span class="line"></span><br><span class="line">    dlclose(dl); <span class="comment">//关闭动态库</span></span><br><span class="line">    error = dlerror(); <span class="comment">//检测错误</span></span><br><span class="line">    <span class="keyword">if</span> (error != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"%s\n"</span>,error);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc  -ldl <span class="built_in">test</span>-explicit.c -o <span class="built_in">test</span>-explicit</span></span><br></pre></td></tr></table></figure></p><p>查看<code>test-explicit</code>动态段信息,没有发现依赖<code>libwelcome.so</code>:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ldd test-explicit</span><br><span class="line">linux-vdso<span class="selector-class">.so</span>.<span class="number">1</span> =&gt;  (<span class="number">0</span>x00007ffed89e5000)</span><br><span class="line">libdl<span class="selector-class">.so</span>.<span class="number">2</span> =&gt; /lib64/libdl<span class="selector-class">.so</span>.<span class="number">2</span> (<span class="number">0</span>x000000353e600000)</span><br><span class="line">libstdc++<span class="selector-class">.so</span>.<span class="number">6</span> =&gt; /usr/lib64/libstdc++<span class="selector-class">.so</span>.<span class="number">6</span> (<span class="number">0</span>x0000003548600000)</span><br><span class="line">libm<span class="selector-class">.so</span>.<span class="number">6</span> =&gt; /lib64/libm<span class="selector-class">.so</span>.<span class="number">6</span> (<span class="number">0</span>x000000353de00000)</span><br><span class="line">libgcc_s<span class="selector-class">.so</span>.<span class="number">1</span> =&gt; /lib64/libgcc_s<span class="selector-class">.so</span>.<span class="number">1</span> (<span class="number">0</span>x0000003548200000)</span><br><span class="line">libc<span class="selector-class">.so</span>.<span class="number">6</span> =&gt; /lib64/libc<span class="selector-class">.so</span>.<span class="number">6</span> (<span class="number">0</span>x000000353da00000)</span><br><span class="line">/lib64/ld-linux-x86-<span class="number">64</span><span class="selector-class">.so</span>.<span class="number">2</span> (<span class="number">0</span>x000000353d600000)</span><br></pre></td></tr></table></figure></p><p>运行:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./<span class="built_in">test</span>-explicit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> welcome to my code world!</span></span><br></pre></td></tr></table></figure></p><blockquote><p> 区别: 隐式调用在编译可执行程序时需要指定库文件的搜索路径，而显式调用编译可执行程序时不用加上.</p></blockquote><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="http://blog.csdn.net/star_xiong/article/details/17301191" target="_blank" rel="noopener">Linux下静态、动态库（隐式、显式调用）的创建和使用及区别</a></li><li><a href="http://hbprotoss.github.io/posts/linuxxia-bian-yi-lian-jie-dong-tai-ku.html" target="_blank" rel="noopener">Linux下编译链接动态库</a></li><li><a href="http://blog.csdn.net/felixit0120/article/details/7652907" target="_blank" rel="noopener">Linux下动态库(.so)和静态库(.a)</a></li></ul><h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p><ul><li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li><li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li><li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li><li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li><li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li></ul><p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍Linux下C调用静态库和动态库,使用的样例文件请点击&lt;a href=&quot;https://github.com/AnSwErYWJ/DogFood/tree/master/C/aso&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="C" scheme="http://answerywj.com/categories/C/"/>
    
    
      <category term="lib" scheme="http://answerywj.com/tags/lib/"/>
    
  </entry>
  
  <entry>
    <title>科普|3.5mm耳机国标和美标</title>
    <link href="http://answerywj.com/2016/09/20/standard-of-headphone/"/>
    <id>http://answerywj.com/2016/09/20/standard-of-headphone/</id>
    <published>2016-09-20T03:37:40.000Z</published>
    <updated>2019-03-16T07:13:16.625Z</updated>
    
    <content type="html"><![CDATA[<p>现在3.5mm规格的耳机已经普遍使用，但是用户会发现一些国外厂家的耳机并不适用国产手机，下面就为大家科普一下，解开这个迷题。</p><a id="more"></a><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul><li><p>美标也称为国际标准(CTIA)，从头开始分别是左声道/右声道/地线/MIC。目前在市场上最流行</p></li><li><p>国标(OMTP)，从头开始分别是左声道/右声道/MIC/地线。</p></li></ul><p><img src="http://o9zpdspb3.bkt.clouddn.com/headset.png" alt="headset"></p><p>从上图可以发现美标和国标的差别就在于MIC和地线的位置不同，导致会出现在听音乐时只有伴奏没有人声，只有按住接听键才正常的现象。</p><p>另外一个区别是，美标的中间三节隔离绝缘圈，一般是都是白色的。而国标为了有所分别，一般是都是黑色的，大部分耳机可以通过此方法来区别。</p><h2 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h2><ul><li><p>美标耳机适用手机范围：苹果（全系列）、小米（全系列）、魅族（全系列）、索尼（全系列）、LG（全系列）、HTC官方产品、三星（咨询客服）、摩托罗拉部分机型（ME865）、联想W101、诺基亚Lumia和WP7系列、华为(C8812/U9200)、亿通T900等。</p></li><li><p>国标耳机适用手机范围：诺基亚、索尼爱立信（全系列）、中兴（全系列）、步步高（全系列）、酷派（全系列）、HTC 非官方产品（A3380、A3360、T9188、A9188、Z510D）、三星旧产品（i8910、M3510C、M7500、F278、F700、F408、F490、G810、G818、G818E、i550W、8510、i560、S8000C、i8000、M2710C、i7500U、i9000、i6500U、F809、i8000、F859）、摩托罗拉XT531、联想A520/A750/P700、OPPO（全系列）等国产系列手机。</p></li></ul><blockquote><p>若发现国标/美标不适配自己的手机，某宝上面有转接线可以买，可以通过转换国标/美标。</p></blockquote><h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p><ul><li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li><li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li><li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li><li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li><li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li></ul><p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在3.5mm规格的耳机已经普遍使用，但是用户会发现一些国外厂家的耳机并不适用国产手机，下面就为大家科普一下，解开这个迷题。&lt;/p&gt;
    
    </summary>
    
      <category term="Knowledge" scheme="http://answerywj.com/categories/Knowledge/"/>
    
    
      <category term="headset" scheme="http://answerywj.com/tags/headset/"/>
    
  </entry>
  
  <entry>
    <title>Shell脚本浮点运算</title>
    <link href="http://answerywj.com/2016/09/05/floating-point-operation-in-script/"/>
    <id>http://answerywj.com/2016/09/05/floating-point-operation-in-script/</id>
    <published>2016-09-05T06:58:50.000Z</published>
    <updated>2019-03-16T07:13:16.577Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍几种Linux下通过Shell脚本进行浮点数计算的方法。</p><hr><a id="more"></a><h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p>Bash Shell本身不具备处理浮点计算的能力, 如<code>expr</code>命令只支持整数运算 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">a=59</span><br><span class="line">b=60</span><br><span class="line">expr <span class="variable">$a</span> / <span class="variable">$b</span></span><br></pre></td></tr></table></figure></p><p>运行结果 :<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./cal.sh</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure></p><h2 id="Plan-A"><a href="#Plan-A" class="headerlink" title="Plan A"></a>Plan A</h2><p>使用<code>bc</code>进行处理。<br>代码 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">a=59</span><br><span class="line">b=60</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"scale=4; <span class="variable">$a</span> / <span class="variable">$b</span>"</span> | bc</span><br></pre></td></tr></table></figure></p><p>运行结果 :<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="string">./bc.sh</span></span><br><span class="line"><span class="string">.9833</span></span><br></pre></td></tr></table></figure></p><blockquote><p><code>scale</code>表示结果的小数精度。</p></blockquote><h2 id="Plan-B"><a href="#Plan-B" class="headerlink" title="Plan B"></a>Plan B</h2><p>使用<code>awk</code>进行处理。<br>代码 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">a=59</span><br><span class="line">b=60</span><br><span class="line">awk <span class="string">'BEGIN&#123;printf "%.2f\n",('</span><span class="variable">$a</span><span class="string">'/'</span><span class="variable">$b</span><span class="string">')&#125;'</span></span><br></pre></td></tr></table></figure></p><p>运行结果 :<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./awk.sh</span><br><span class="line"><span class="number">0.98</span></span><br></pre></td></tr></table></figure></p><h2 id="Compare"><a href="#Compare" class="headerlink" title="Compare"></a>Compare</h2><p>使用bc :<br><img src="http://o9zpdspb3.bkt.clouddn.com/bc.png" alt="bc"></p><p>使用awk :<br><img src="http://o9zpdspb3.bkt.clouddn.com/awk.png" alt="awk"></p><blockquote><p>可以看出使用<code>awk</code>的效率更高,特别是运算次数比较大时。</p></blockquote><h2 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h2><p><a href="http://forthebadge.com" target="_blank" rel="noopener"><img src="http://forthebadge.com/images/badges/ages-20-30.svg" alt="forthebadge"></a></p><ul><li>GitHub：<a href="https://github.com/AnSwErYWJ" target="_blank" rel="noopener">AnSwErYWJ</a></li><li>Blog：<a href="http://www.answerywj.com" target="_blank" rel="noopener">http://www.answerywj.com</a></li><li>Email：<a href="https://mail.google.com" target="_blank" rel="noopener">yuanweijie1993@gmail.com</a></li><li>Weibo：<a href="http://weibo.com/1783591593" target="_blank" rel="noopener">@AnSwEr不是答案</a></li><li>CSDN：<a href="http://blog.csdn.net/u011192270" target="_blank" rel="noopener">AnSwEr不是答案的专栏</a></li></ul><p><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> This work is licensed under a <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>本作品采用知识共享署名-相同方式共享 4.0 国际许可协议进行许可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍几种Linux下通过Shell脚本进行浮点数计算的方法。&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://answerywj.com/categories/Linux/"/>
    
    
      <category term="script" scheme="http://answerywj.com/tags/script/"/>
    
  </entry>
  
</feed>
